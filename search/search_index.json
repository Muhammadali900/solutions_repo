{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"1. Theoretical Foundation: Equations of Motion Projectile motion can be understood by decomposing it into horizontal and vertical components. Assuming no air resistance and that the projectile is launched from ground level, the motion is governed by the following kinematic equations: Horizontal Motion Velocity: \\[ v_x = v_0 \\cdot \\cos(\\theta) \\] Displacement: \\[ x(t) = v_0 \\cdot \\cos(\\theta) \\cdot t \\] Vertical Motion Velocity: \\[ v_y = v_0 \\cdot \\sin(\\theta) - g \\cdot t \\] Displacement: \\[ y(t) = v_0 \\cdot \\sin(\\theta) \\cdot t - \\frac{1}{2} g \\cdot t^2 \\] Here: \\(v_0\\) is the initial launch speed. \\(\\theta\\) is the angle of projection. \\(g\\) is the acceleration due to gravity (approximately 9.8 m/s\u00b2). \\(t\\) is the time elapsed. The time of flight \\(T\\) can be found by setting \\(y(T) = 0\\) : \\[ 0 = v_0 \\cdot \\sin(\\theta) \\cdot T - \\frac{1}{2} g \\cdot T^2 \\] Solving for \\(T\\) : \\[ T = \\frac{2 v_0 \\cdot \\sin(\\theta)}{g} \\] The range \\(R\\) , which is the horizontal distance traveled, is then: \\[ R = x(T) = v_0 \\cdot \\cos(\\theta) \\cdot T = \\frac{v_0^2 \\cdot \\sin(2\\theta)}{g} \\] This equation shows that the range depends on both the initial speed and the angle of projection. 2. Analysis of the Range The horizontal range \\(R\\) of a projectile is influenced by several factors, including the angle of projection \\(\\theta\\) , the initial velocity \\(v_0\\) , and the acceleration due to gravity \\(g\\) . Let's analyze how each of these parameters affects the range. 1. Dependence on the Angle of Projection The range equation for a projectile launched from ground level is: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This equation indicates that the range depends on \\(\\sin(2\\theta)\\) : Maximum Range: The function \\(\\sin(2\\theta)\\) reaches its maximum value of 1 when \\(2\\theta = 90^\\circ\\) , or \\(\\theta = 45^\\circ\\) . Therefore, the projectile achieves its maximum range when launched at a 45-degree angle. Symmetric Angles: Angles equidistant from 45 degrees (e.g., 30\u00b0 and 60\u00b0) yield the same range because \\(\\sin(60^\\circ) = \\sin(120^\\circ)\\) . However, the trajectories differ; a lower angle results in a flatter trajectory with shorter flight time, while a higher angle produces a steeper trajectory with longer flight time. 2. Influence of Initial Velocity The initial velocity \\(v_0\\) has a quadratic effect on the range: Direct Relationship: Since \\(R \\propto v_0^2\\) , doubling the initial velocity quadruples the range. This quadratic relationship underscores the significant impact of initial speed on how far the projectile travels. 3. Effect of Gravitational Acceleration Gravity \\(g\\) inversely affects the range: Inverse Relationship: An increase in gravitational acceleration results in a decrease in range. For instance, on the Moon, where gravity is weaker than on Earth, a projectile would travel farther than it would with the same initial conditions on Earth. 3. Practical Applications Projectile motion models, while foundational in physics, often assume ideal conditions such as uniform terrain and negligible air resistance. However, real-world scenarios frequently involve complexities like uneven terrain and aerodynamic forces. Adapting the basic projectile motion model to account for these factors enhances its applicability across various fields. 1. Basic Projectile Motion (Neglecting Air Resistance) Time of Flight (T): \\[ T = \\frac{2 v_0 \\sin(\\theta)}{g} \\] Maximum Height (H): \\[ H = \\frac{(v_0 \\sin(\\theta))^2}{2g} \\] Horizontal Range (R): \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] The range is maximized when \\(\\theta = 45^\\circ\\) . Where: - \\(v_0\\) = initial velocity - \\(\\theta\\) = launch angle - \\(g\\) = acceleration due to gravity 2. Uneven Terrain When launching from a height \\(y_0\\) , the range equation adjusts to: \\[ R = \\frac{v_0 \\cos(\\theta)}{g} \\left( v_0 \\sin(\\theta) + \\sqrt{(v_0 \\sin(\\theta))^2 + 2 g y_0} \\right) \\] 3. Air Resistance Accounting for air resistance complicates the equations, often requiring numerical methods for precise solutions. However, for small projectiles at high speeds, the range \\(R\\) can be approximated by: \\[ R \\approx \\frac{v_0 v_t}{g} \\] Where \\(v_t\\) is the terminal velocity. 4. Implementation import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # Acceleration due to gravity (m/s\u00b2) # Function to calculate the range of a projectile def calculate_range(v0, theta): theta_rad = np.radians(theta) range = (v0**2) * np.sin(2 * theta_rad) / g return range # Function to plot range vs. launch angle for different initial velocities def plot_range_vs_angle(initial_velocities, angles): plt.figure(figsize=(10, 6)) for v in initial_velocities: ranges = [calculate_range(v, angle) for angle in angles] plt.plot(angles, ranges, label=f'v0 = {v} m/s') plt.title('Projectile Range vs. Launch Angle') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (meters)') plt.legend() plt.grid(True) plt.show() # Function to simulate and plot projectile motion def plot_trajectory(v0, theta): theta_rad = np.radians(theta) t_flight = 2 * v0 * np.sin(theta_rad) / g t = np.linspace(0, t_flight, num=500) x = v0 * np.cos(theta_rad) * t y = v0 * np.sin(theta_rad) * t - 0.5 * g * t**2 plt.plot(x, y, label=f'v0 = {v0} m/s, \u03b8 = {theta}\u00b0') # Main execution if __name__ == \"__main__\": # Parameters initial_velocities = [20, 30, 40] # Different initial velocities in m/s angles = np.linspace(0, 90, num=91) # Angles from 0 to 90 degrees # Plot range vs. launch angle for different initial velocities plot_range_vs_angle(initial_velocities, angles) # Plot trajectories for different initial conditions plt.figure(figsize=(10, 6)) for v0 in initial_velocities: for theta in [30, 45, 60]: # Example angles plot_trajectory(v0, theta) plt.title('Projectile Motion Trajectories') plt.xlabel('Horizontal Distance (meters)') plt.ylabel('Vertical Distance (meters)') plt.legend() plt.grid(True) plt.show() Explanation: Constants and Functions Gravitational Acceleration : The constant \\(g\\) represents gravitational acceleration, typically defined as \\(9.8 \\, \\text{m/s}^2\\) . calculate_range : Computes the horizontal range \\(R\\) for a given initial velocity \\(v_0\\) and launch angle \\(\\theta\\) . The standard formula is: $$ R = \\frac{v_0^2 \\sin(2\\theta)}{g} $$ plot_range_vs_angle : Generates a plot of range \\(R\\) versus launch angle \\(\\theta\\) for a list of initial velocities \\(v_0\\) . This visualizes how \\(R\\) peaks at \\(\\theta = 45^\\circ\\) and varies with \\(v_0\\) . plot_trajectory : Simulates and plots the projectile\u2019s trajectory ( \\(x-y\\) path) for given initial conditions. The parametric equations are: $$ x(t) = v_0 \\cos(\\theta) \\cdot t $$ $$ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 $$ Main Execution The simulation follows these steps: Input Definition : A list of initial velocities \\(v_0\\) is defined (e.g., [ \\(10, 20, 30\\) ] m/s). A range of launch angles \\(\\theta\\) is specified (e.g., \\(0^\\circ\\) to \\(90^\\circ\\) in increments). Range Visualization : The plot_range_vs_angle function is called to plot \\(R\\) versus \\(\\theta\\) for each \\(v_0\\) . This shows the maximum range at \\(\\theta = 45^\\circ\\) and the quadratic effect of \\(v_0\\) . Trajectory Visualization : The plot_trajectory function plots trajectories for combinations of the specified \\(v_0\\) values and example angles: \\(30^\\circ\\) , \\(45^\\circ\\) , and \\(60^\\circ\\) . This illustrates differences in height, range, and flight time.","title":"1. Theoretical Foundation: Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation-equations-of-motion","text":"Projectile motion can be understood by decomposing it into horizontal and vertical components. Assuming no air resistance and that the projectile is launched from ground level, the motion is governed by the following kinematic equations:","title":"1. Theoretical Foundation: Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-motion","text":"Velocity: \\[ v_x = v_0 \\cdot \\cos(\\theta) \\] Displacement: \\[ x(t) = v_0 \\cdot \\cos(\\theta) \\cdot t \\]","title":"Horizontal Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#vertical-motion","text":"Velocity: \\[ v_y = v_0 \\cdot \\sin(\\theta) - g \\cdot t \\] Displacement: \\[ y(t) = v_0 \\cdot \\sin(\\theta) \\cdot t - \\frac{1}{2} g \\cdot t^2 \\] Here: \\(v_0\\) is the initial launch speed. \\(\\theta\\) is the angle of projection. \\(g\\) is the acceleration due to gravity (approximately 9.8 m/s\u00b2). \\(t\\) is the time elapsed. The time of flight \\(T\\) can be found by setting \\(y(T) = 0\\) : \\[ 0 = v_0 \\cdot \\sin(\\theta) \\cdot T - \\frac{1}{2} g \\cdot T^2 \\] Solving for \\(T\\) : \\[ T = \\frac{2 v_0 \\cdot \\sin(\\theta)}{g} \\] The range \\(R\\) , which is the horizontal distance traveled, is then: \\[ R = x(T) = v_0 \\cdot \\cos(\\theta) \\cdot T = \\frac{v_0^2 \\cdot \\sin(2\\theta)}{g} \\] This equation shows that the range depends on both the initial speed and the angle of projection.","title":"Vertical Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"The horizontal range \\(R\\) of a projectile is influenced by several factors, including the angle of projection \\(\\theta\\) , the initial velocity \\(v_0\\) , and the acceleration due to gravity \\(g\\) . Let's analyze how each of these parameters affects the range.","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-dependence-on-the-angle-of-projection","text":"The range equation for a projectile launched from ground level is: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This equation indicates that the range depends on \\(\\sin(2\\theta)\\) : Maximum Range: The function \\(\\sin(2\\theta)\\) reaches its maximum value of 1 when \\(2\\theta = 90^\\circ\\) , or \\(\\theta = 45^\\circ\\) . Therefore, the projectile achieves its maximum range when launched at a 45-degree angle. Symmetric Angles: Angles equidistant from 45 degrees (e.g., 30\u00b0 and 60\u00b0) yield the same range because \\(\\sin(60^\\circ) = \\sin(120^\\circ)\\) . However, the trajectories differ; a lower angle results in a flatter trajectory with shorter flight time, while a higher angle produces a steeper trajectory with longer flight time.","title":"1. Dependence on the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-influence-of-initial-velocity","text":"The initial velocity \\(v_0\\) has a quadratic effect on the range: Direct Relationship: Since \\(R \\propto v_0^2\\) , doubling the initial velocity quadruples the range. This quadratic relationship underscores the significant impact of initial speed on how far the projectile travels.","title":"2. Influence of Initial Velocity"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-effect-of-gravitational-acceleration","text":"Gravity \\(g\\) inversely affects the range: Inverse Relationship: An increase in gravitational acceleration results in a decrease in range. For instance, on the Moon, where gravity is weaker than on Earth, a projectile would travel farther than it would with the same initial conditions on Earth.","title":"3. Effect of Gravitational Acceleration"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Projectile motion models, while foundational in physics, often assume ideal conditions such as uniform terrain and negligible air resistance. However, real-world scenarios frequently involve complexities like uneven terrain and aerodynamic forces. Adapting the basic projectile motion model to account for these factors enhances its applicability across various fields.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-basic-projectile-motion-neglecting-air-resistance","text":"Time of Flight (T): \\[ T = \\frac{2 v_0 \\sin(\\theta)}{g} \\] Maximum Height (H): \\[ H = \\frac{(v_0 \\sin(\\theta))^2}{2g} \\] Horizontal Range (R): \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] The range is maximized when \\(\\theta = 45^\\circ\\) . Where: - \\(v_0\\) = initial velocity - \\(\\theta\\) = launch angle - \\(g\\) = acceleration due to gravity","title":"1. Basic Projectile Motion (Neglecting Air Resistance)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-uneven-terrain","text":"When launching from a height \\(y_0\\) , the range equation adjusts to: \\[ R = \\frac{v_0 \\cos(\\theta)}{g} \\left( v_0 \\sin(\\theta) + \\sqrt{(v_0 \\sin(\\theta))^2 + 2 g y_0} \\right) \\]","title":"2. Uneven Terrain"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-air-resistance","text":"Accounting for air resistance complicates the equations, often requiring numerical methods for precise solutions. However, for small projectiles at high speeds, the range \\(R\\) can be approximated by: \\[ R \\approx \\frac{v_0 v_t}{g} \\] Where \\(v_t\\) is the terminal velocity.","title":"3. Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # Acceleration due to gravity (m/s\u00b2) # Function to calculate the range of a projectile def calculate_range(v0, theta): theta_rad = np.radians(theta) range = (v0**2) * np.sin(2 * theta_rad) / g return range # Function to plot range vs. launch angle for different initial velocities def plot_range_vs_angle(initial_velocities, angles): plt.figure(figsize=(10, 6)) for v in initial_velocities: ranges = [calculate_range(v, angle) for angle in angles] plt.plot(angles, ranges, label=f'v0 = {v} m/s') plt.title('Projectile Range vs. Launch Angle') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (meters)') plt.legend() plt.grid(True) plt.show() # Function to simulate and plot projectile motion def plot_trajectory(v0, theta): theta_rad = np.radians(theta) t_flight = 2 * v0 * np.sin(theta_rad) / g t = np.linspace(0, t_flight, num=500) x = v0 * np.cos(theta_rad) * t y = v0 * np.sin(theta_rad) * t - 0.5 * g * t**2 plt.plot(x, y, label=f'v0 = {v0} m/s, \u03b8 = {theta}\u00b0') # Main execution if __name__ == \"__main__\": # Parameters initial_velocities = [20, 30, 40] # Different initial velocities in m/s angles = np.linspace(0, 90, num=91) # Angles from 0 to 90 degrees # Plot range vs. launch angle for different initial velocities plot_range_vs_angle(initial_velocities, angles) # Plot trajectories for different initial conditions plt.figure(figsize=(10, 6)) for v0 in initial_velocities: for theta in [30, 45, 60]: # Example angles plot_trajectory(v0, theta) plt.title('Projectile Motion Trajectories') plt.xlabel('Horizontal Distance (meters)') plt.ylabel('Vertical Distance (meters)') plt.legend() plt.grid(True) plt.show()","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#explanation","text":"","title":"Explanation:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#constants-and-functions","text":"Gravitational Acceleration : The constant \\(g\\) represents gravitational acceleration, typically defined as \\(9.8 \\, \\text{m/s}^2\\) . calculate_range : Computes the horizontal range \\(R\\) for a given initial velocity \\(v_0\\) and launch angle \\(\\theta\\) . The standard formula is: $$ R = \\frac{v_0^2 \\sin(2\\theta)}{g} $$ plot_range_vs_angle : Generates a plot of range \\(R\\) versus launch angle \\(\\theta\\) for a list of initial velocities \\(v_0\\) . This visualizes how \\(R\\) peaks at \\(\\theta = 45^\\circ\\) and varies with \\(v_0\\) . plot_trajectory : Simulates and plots the projectile\u2019s trajectory ( \\(x-y\\) path) for given initial conditions. The parametric equations are: $$ x(t) = v_0 \\cos(\\theta) \\cdot t $$ $$ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 $$","title":"Constants and Functions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#main-execution","text":"The simulation follows these steps: Input Definition : A list of initial velocities \\(v_0\\) is defined (e.g., [ \\(10, 20, 30\\) ] m/s). A range of launch angles \\(\\theta\\) is specified (e.g., \\(0^\\circ\\) to \\(90^\\circ\\) in increments). Range Visualization : The plot_range_vs_angle function is called to plot \\(R\\) versus \\(\\theta\\) for each \\(v_0\\) . This shows the maximum range at \\(\\theta = 45^\\circ\\) and the quadratic effect of \\(v_0\\) . Trajectory Visualization : The plot_trajectory function plots trajectories for combinations of the specified \\(v_0\\) values and example angles: \\(30^\\circ\\) , \\(45^\\circ\\) , and \\(60^\\circ\\) . This illustrates differences in height, range, and flight time.","title":"Main Execution"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Forced Damped Pendulum Analysis 1. Theoretical Foundation 1: Starting Differential Equation The motion of a forced damped pendulum is governed by the nonlinear second-order differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A \\cos(\\omega t) \\] Where: - \\(\\theta(t)\\) is the angular displacement. - \\(b\\) is the damping coefficient. - \\(g\\) is gravitational acceleration. - \\(L\\) is the length of the pendulum. - \\(A\\) is the amplitude of the external periodic force. - \\(\\omega\\) is the angular frequency of the driving force. 2: Small-Angle Approximation For small angles ( \\(\\theta \\ll 1\\) ), we can use the approximation: \\[ \\sin\\theta \\approx \\theta \\] Substitute into the original equation: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\] This is now a linear second-order nonhomogeneous ODE\u2014a classic form of the driven damped harmonic oscillator. 3: General Solution (Small-Angle Linear Case) The general solution is: \\[ \\theta(t) = \\theta_{\\text{hom}}(t) + \\theta_{\\text{part}}(t) \\] Homogeneous (Natural) Solution Solve: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = 0 \\] This describes the natural damped oscillations. The solution form depends on damping: Underdamped : \\(b^2 < 4 \\frac{g}{L}\\) \\[ \\theta_{\\text{hom}}(t) = e^{-\\frac{b}{2} t} \\left( C_1 \\cos(\\omega_0 t) + C_2 \\sin(\\omega_0 t) \\right) \\] where: \\[ \\omega_0 = \\sqrt{\\frac{g}{L} - \\left(\\frac{b}{2}\\right)^2} \\] Particular (Forced) Solution Try: \\[ \\theta_{\\text{part}}(t) = B \\cos(\\omega t - \\delta) \\] After substitution and solving, you find: \\[ B = \\frac{A}{\\sqrt{\\left(\\frac{g}{L} - \\omega^2\\right)^2 + b^2 \\omega^2}} \\] \\[ \\tan(\\delta) = \\frac{b \\omega}{\\frac{g}{L} - \\omega^2} \\] 4: Resonance Condition Resonance occurs when the driving frequency \\(\\omega\\) approaches the natural frequency of the system: \\[ \\omega_{\\text{res}} \\approx \\sqrt{\\frac{g}{L} - \\frac{b^2}{2}} \\] At or near this frequency, the amplitude \\(B\\) of the steady-state oscillation becomes maximum. For very small damping ( \\(b \\to 0\\) ), the amplitude can become very large. 5: Energy Implications of Resonance When resonance occurs, the driving force efficiently transfers energy to the system. If not limited by damping, this would cause the system's energy to grow unbounded. Damping is essential to balance energy input and loss, resulting in steady-state oscillations instead of infinite growth. 2. Analysis of Dynamics 1. Governing Equation The motion is described by the nonlinear, second-order, driven differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A \\cos(\\omega t) \\] This equation models a forced damped pendulum. We now investigate the effects of its key parameters. 2. Influence of Key Parameters Damping Coefficient \\(b\\) Low damping : Allows larger oscillations; more prone to resonance and chaotic behavior. High damping : Motion dies out or settles into low-amplitude oscillations. Moderate damping : Can lead to steady periodic behavior or quasi-periodic motion, depending on other parameters. Driving Amplitude \\(A\\) Low amplitude : Typically leads to regular, periodic motion. Moderate amplitude : May induce quasi-periodic behavior. High amplitude : Often results in chaotic motion, especially when combined with low damping. Driving Frequency \\(\\omega\\) Near natural frequency : Resonance effects dominate (amplitude peaks). Off-resonance : Motion is often simpler or less energetic. Critical frequencies : Certain values cause the system to become chaotic or display strange attractors. 3. Types of Motion Observed Motion Type Behavior Conditions Periodic Repeats after a fixed time Low \\(A\\) , moderate \\(b\\) , off-resonance Quasi-periodic Almost regular, with shifting phase Slight mismatch between natural and driving frequency Chaotic Unpredictable, sensitive to initial conditions High \\(A\\) , low \\(b\\) , near resonance 4. Detecting Chaos: Physical Interpretations Sensitive Dependence on Initial Conditions : Two almost identical starting points lead to vastly different trajectories. Poincar\u00e9 Section : A stroboscopic map showing whether the system lands on: A single point (periodic). A closed curve (quasi-periodic). Scattered points (chaos). Phase Portrait : A plot of \\(\\theta\\) vs \\(\\dot{\\theta}\\) : Regular motion creates closed loops. Chaos produces tangled trajectories. Bifurcation Diagram : As a parameter (e.g., \\(A\\) or \\(\\omega\\) ) varies, the system transitions from one steady state to multiple, eventually leading to chaos. 5. Interpretation in Real Systems Engineering : Systems must avoid chaotic regimes to prevent mechanical failure (e.g., bridges, engines). Climate Models : Quasi-periodic and chaotic behavior are common due to complex forcing patterns. Biological Rhythms : Can switch between periodic and chaotic under stress or disease. 3. Practical Applications The dynamics of a forced damped pendulum serve as a foundational analogy for many physical and engineered systems where oscillations, damping, and external forces are present. Below are key examples: 1. Energy Harvesting Devices Example : Piezoelectric energy harvesters in shoes, roads, or structural components. Why it's similar : These devices involve damped mechanical systems driven by external periodic forces (e.g., walking). Model connection : - Energy input (walking) corresponds to the driving force: $$ A \\cos(\\omega t) $$ - Damping represents energy losses, and the harvested power corresponds to the amplitude of oscillations. 2. Suspension Bridges & Building Oscillations Example : The infamous Tacoma Narrows Bridge collapse. Why it's similar : Wind acts as a periodic driving force; internal friction and air resistance provide damping. Model connection : The system can be modeled as: $$ \\theta'' + b \\theta' + \\frac{g}{L} \\theta = A \\cos(\\omega t) $$ If the driving frequency matches a structural mode (resonance), large-amplitude oscillations can occur\u2014even leading to failure. 3. Oscillating Electrical Circuits (Driven RLC Circuits) Example : AC circuits with a resistor ( \\(R\\) ), inductor ( \\(L\\) ), and capacitor ( \\(C\\) ) driven by an alternating voltage. Why it's similar : Mathematically analogous to the forced damped pendulum. Electrical analogy : The governing equation is: $$ L \\frac{d^2q}{dt^2} + R \\frac{dq}{dt} + \\frac{1}{C} q = V_0 \\cos(\\omega t) $$ This maps directly to the mechanical form: $$ m \\theta'' + b \\theta' + k \\theta = A \\cos(\\omega t) $$ 4.Implementation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Step 1: Simulation function def forced_damped_pendulum(t, y, b, A, omega): theta, omega_dot = y dtheta_dt = omega_dot domega_dt = -b * omega_dot - (9.81 / 1.0) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] def simulate_pendulum(theta0, omega0, b, A, omega_drive, t_max=100, dt=0.01): t_span = (0, t_max) t_eval = np.arange(0, t_max, dt) y0 = [theta0, omega0] sol = solve_ivp(forced_damped_pendulum, t_span, y0, args=(b, A, omega_drive), t_eval=t_eval, method='RK45') return sol.t, sol.y[0], sol.y[1] # Step 2: Plotting function def plot_all(t, theta, omega_dot, drive_freq): theta = (theta + np.pi) % (2 * np.pi) - np.pi # Normalize # Time series plt.figure(figsize=(10, 4)) plt.plot(t, theta, label='\u03b8(t)') plt.plot(t, omega_dot, label='\u03c9(t)', alpha=0.6) plt.title('Time Series') plt.xlabel('Time (s)') plt.ylabel('Value') plt.legend() plt.grid(True) plt.show() # Phase portrait plt.figure(figsize=(6, 6)) plt.plot(theta, omega_dot, '.', markersize=0.5) plt.title('Phase Portrait') plt.xlabel('\u03b8 (rad)') plt.ylabel('\u03c9 (rad/s)') plt.grid(True) plt.show() # Poincar\u00e9 section T = 2 * np.pi / drive_freq poincare_times = np.arange(0, t[-1], T) poincare_indices = [np.argmin(np.abs(t - pt)) for pt in poincare_times] plt.figure(figsize=(6, 6)) plt.plot(theta[poincare_indices], omega_dot[poincare_indices], 'ro', markersize=3) plt.title('Poincar\u00e9 Section') plt.xlabel('\u03b8 (rad)') plt.ylabel('\u03c9 (rad/s)') plt.grid(True) plt.show() # Step 3: Run the simulation and plot t, theta, omega_dot = simulate_pendulum( theta0=0.2, omega0=0.0, b=0.3, A=1.2, omega_drive=2.0 ) plot_all(t, theta, omega_dot, drive_freq=2.0) Explanation 1. Time Series Plot ( \\(\\theta(t)\\) and \\(\\omega(t)\\) ) This plot shows the angular position \\(\\theta(t)\\) and angular velocity \\(\\omega(t)\\) over time. The oscillations are regular and consistent, suggesting periodic behavior. The system has reached a steady state, where energy input from the driving force is balanced by damping. 2. Phase Portrait ( \\(\\theta\\) vs. \\(\\omega\\) ) This shows how the system evolves in state space. The near-perfect elliptical shape indicates regular, bounded, and stable motion. There is no sign of chaos; instead, the system follows a predictable trajectory. 3. Poincar\u00e9 Section This stroboscopically samples the system once per driving cycle. The clustering of points in a tight region indicates periodic or quasi-periodic behavior. If the system were chaotic, the points would be scattered without forming a structure.","title":"Forced Damped Pendulum Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#forced-damped-pendulum-analysis","text":"","title":"Forced Damped Pendulum Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-starting-differential-equation","text":"The motion of a forced damped pendulum is governed by the nonlinear second-order differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A \\cos(\\omega t) \\] Where: - \\(\\theta(t)\\) is the angular displacement. - \\(b\\) is the damping coefficient. - \\(g\\) is gravitational acceleration. - \\(L\\) is the length of the pendulum. - \\(A\\) is the amplitude of the external periodic force. - \\(\\omega\\) is the angular frequency of the driving force.","title":"1: Starting Differential Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-small-angle-approximation","text":"For small angles ( \\(\\theta \\ll 1\\) ), we can use the approximation: \\[ \\sin\\theta \\approx \\theta \\] Substitute into the original equation: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\] This is now a linear second-order nonhomogeneous ODE\u2014a classic form of the driven damped harmonic oscillator.","title":"2: Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-general-solution-small-angle-linear-case","text":"The general solution is: \\[ \\theta(t) = \\theta_{\\text{hom}}(t) + \\theta_{\\text{part}}(t) \\]","title":"3: General Solution (Small-Angle Linear Case)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#homogeneous-natural-solution","text":"Solve: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = 0 \\] This describes the natural damped oscillations. The solution form depends on damping: Underdamped : \\(b^2 < 4 \\frac{g}{L}\\) \\[ \\theta_{\\text{hom}}(t) = e^{-\\frac{b}{2} t} \\left( C_1 \\cos(\\omega_0 t) + C_2 \\sin(\\omega_0 t) \\right) \\] where: \\[ \\omega_0 = \\sqrt{\\frac{g}{L} - \\left(\\frac{b}{2}\\right)^2} \\]","title":"Homogeneous (Natural) Solution"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#particular-forced-solution","text":"Try: \\[ \\theta_{\\text{part}}(t) = B \\cos(\\omega t - \\delta) \\] After substitution and solving, you find: \\[ B = \\frac{A}{\\sqrt{\\left(\\frac{g}{L} - \\omega^2\\right)^2 + b^2 \\omega^2}} \\] \\[ \\tan(\\delta) = \\frac{b \\omega}{\\frac{g}{L} - \\omega^2} \\]","title":"Particular (Forced) Solution"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-resonance-condition","text":"Resonance occurs when the driving frequency \\(\\omega\\) approaches the natural frequency of the system: \\[ \\omega_{\\text{res}} \\approx \\sqrt{\\frac{g}{L} - \\frac{b^2}{2}} \\] At or near this frequency, the amplitude \\(B\\) of the steady-state oscillation becomes maximum. For very small damping ( \\(b \\to 0\\) ), the amplitude can become very large.","title":"4: Resonance Condition"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-energy-implications-of-resonance","text":"When resonance occurs, the driving force efficiently transfers energy to the system. If not limited by damping, this would cause the system's energy to grow unbounded. Damping is essential to balance energy input and loss, resulting in steady-state oscillations instead of infinite growth.","title":"5: Energy Implications of Resonance"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-governing-equation","text":"The motion is described by the nonlinear, second-order, driven differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A \\cos(\\omega t) \\] This equation models a forced damped pendulum. We now investigate the effects of its key parameters.","title":"1. Governing Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-influence-of-key-parameters","text":"","title":"2. Influence of Key Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#damping-coefficient-b","text":"Low damping : Allows larger oscillations; more prone to resonance and chaotic behavior. High damping : Motion dies out or settles into low-amplitude oscillations. Moderate damping : Can lead to steady periodic behavior or quasi-periodic motion, depending on other parameters.","title":"Damping Coefficient \\(b\\)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#driving-amplitude-a","text":"Low amplitude : Typically leads to regular, periodic motion. Moderate amplitude : May induce quasi-periodic behavior. High amplitude : Often results in chaotic motion, especially when combined with low damping.","title":"Driving Amplitude \\(A\\)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#driving-frequency-omega","text":"Near natural frequency : Resonance effects dominate (amplitude peaks). Off-resonance : Motion is often simpler or less energetic. Critical frequencies : Certain values cause the system to become chaotic or display strange attractors.","title":"Driving Frequency \\(\\omega\\)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-types-of-motion-observed","text":"Motion Type Behavior Conditions Periodic Repeats after a fixed time Low \\(A\\) , moderate \\(b\\) , off-resonance Quasi-periodic Almost regular, with shifting phase Slight mismatch between natural and driving frequency Chaotic Unpredictable, sensitive to initial conditions High \\(A\\) , low \\(b\\) , near resonance","title":"3. Types of Motion Observed"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-detecting-chaos-physical-interpretations","text":"Sensitive Dependence on Initial Conditions : Two almost identical starting points lead to vastly different trajectories. Poincar\u00e9 Section : A stroboscopic map showing whether the system lands on: A single point (periodic). A closed curve (quasi-periodic). Scattered points (chaos). Phase Portrait : A plot of \\(\\theta\\) vs \\(\\dot{\\theta}\\) : Regular motion creates closed loops. Chaos produces tangled trajectories. Bifurcation Diagram : As a parameter (e.g., \\(A\\) or \\(\\omega\\) ) varies, the system transitions from one steady state to multiple, eventually leading to chaos.","title":"4. Detecting Chaos: Physical Interpretations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-interpretation-in-real-systems","text":"Engineering : Systems must avoid chaotic regimes to prevent mechanical failure (e.g., bridges, engines). Climate Models : Quasi-periodic and chaotic behavior are common due to complex forcing patterns. Biological Rhythms : Can switch between periodic and chaotic under stress or disease.","title":"5. Interpretation in Real Systems"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"The dynamics of a forced damped pendulum serve as a foundational analogy for many physical and engineered systems where oscillations, damping, and external forces are present. Below are key examples:","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-energy-harvesting-devices","text":"Example : Piezoelectric energy harvesters in shoes, roads, or structural components. Why it's similar : These devices involve damped mechanical systems driven by external periodic forces (e.g., walking). Model connection : - Energy input (walking) corresponds to the driving force: $$ A \\cos(\\omega t) $$ - Damping represents energy losses, and the harvested power corresponds to the amplitude of oscillations.","title":"1. Energy Harvesting Devices"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-suspension-bridges-building-oscillations","text":"Example : The infamous Tacoma Narrows Bridge collapse. Why it's similar : Wind acts as a periodic driving force; internal friction and air resistance provide damping. Model connection : The system can be modeled as: $$ \\theta'' + b \\theta' + \\frac{g}{L} \\theta = A \\cos(\\omega t) $$ If the driving frequency matches a structural mode (resonance), large-amplitude oscillations can occur\u2014even leading to failure.","title":"2. Suspension Bridges &amp; Building Oscillations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-oscillating-electrical-circuits-driven-rlc-circuits","text":"Example : AC circuits with a resistor ( \\(R\\) ), inductor ( \\(L\\) ), and capacitor ( \\(C\\) ) driven by an alternating voltage. Why it's similar : Mathematically analogous to the forced damped pendulum. Electrical analogy : The governing equation is: $$ L \\frac{d^2q}{dt^2} + R \\frac{dq}{dt} + \\frac{1}{C} q = V_0 \\cos(\\omega t) $$ This maps directly to the mechanical form: $$ m \\theta'' + b \\theta' + k \\theta = A \\cos(\\omega t) $$","title":"3. Oscillating Electrical Circuits (Driven RLC Circuits)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4implementation","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Step 1: Simulation function def forced_damped_pendulum(t, y, b, A, omega): theta, omega_dot = y dtheta_dt = omega_dot domega_dt = -b * omega_dot - (9.81 / 1.0) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] def simulate_pendulum(theta0, omega0, b, A, omega_drive, t_max=100, dt=0.01): t_span = (0, t_max) t_eval = np.arange(0, t_max, dt) y0 = [theta0, omega0] sol = solve_ivp(forced_damped_pendulum, t_span, y0, args=(b, A, omega_drive), t_eval=t_eval, method='RK45') return sol.t, sol.y[0], sol.y[1] # Step 2: Plotting function def plot_all(t, theta, omega_dot, drive_freq): theta = (theta + np.pi) % (2 * np.pi) - np.pi # Normalize # Time series plt.figure(figsize=(10, 4)) plt.plot(t, theta, label='\u03b8(t)') plt.plot(t, omega_dot, label='\u03c9(t)', alpha=0.6) plt.title('Time Series') plt.xlabel('Time (s)') plt.ylabel('Value') plt.legend() plt.grid(True) plt.show() # Phase portrait plt.figure(figsize=(6, 6)) plt.plot(theta, omega_dot, '.', markersize=0.5) plt.title('Phase Portrait') plt.xlabel('\u03b8 (rad)') plt.ylabel('\u03c9 (rad/s)') plt.grid(True) plt.show() # Poincar\u00e9 section T = 2 * np.pi / drive_freq poincare_times = np.arange(0, t[-1], T) poincare_indices = [np.argmin(np.abs(t - pt)) for pt in poincare_times] plt.figure(figsize=(6, 6)) plt.plot(theta[poincare_indices], omega_dot[poincare_indices], 'ro', markersize=3) plt.title('Poincar\u00e9 Section') plt.xlabel('\u03b8 (rad)') plt.ylabel('\u03c9 (rad/s)') plt.grid(True) plt.show() # Step 3: Run the simulation and plot t, theta, omega_dot = simulate_pendulum( theta0=0.2, omega0=0.0, b=0.3, A=1.2, omega_drive=2.0 ) plot_all(t, theta, omega_dot, drive_freq=2.0)","title":"4.Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#explanation","text":"","title":"Explanation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-time-series-plot-thetat-and-omegat","text":"This plot shows the angular position \\(\\theta(t)\\) and angular velocity \\(\\omega(t)\\) over time. The oscillations are regular and consistent, suggesting periodic behavior. The system has reached a steady state, where energy input from the driving force is balanced by damping.","title":"1. Time Series Plot (\\(\\theta(t)\\) and \\(\\omega(t)\\))"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-phase-portrait-theta-vs-omega","text":"This shows how the system evolves in state space. The near-perfect elliptical shape indicates regular, bounded, and stable motion. There is no sign of chaos; instead, the system follows a predictable trajectory.","title":"2. Phase Portrait (\\(\\theta\\) vs. \\(\\omega\\))"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-poincare-section","text":"This stroboscopically samples the system once per driving cycle. The clustering of points in a tight region indicates periodic or quasi-periodic behavior. If the system were chaotic, the points would be scattered without forming a structure.","title":"3. Poincar\u00e9 Section"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"1. Derivation of Kepler\u2019s Third Law for Circular Orbits We begin with two key physical laws: 1. Newton's Law of Universal Gravitation \\[ F_{\\text{gravity}} = \\frac{G M m}{r^2} \\] Where: - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of the central body (e.g., planet or star), - \\(m\\) is the mass of the orbiting body, - \\(r\\) is the orbital radius. 2. Centripetal Force for Circular Motion \\[ F_{\\text{centripetal}} = \\frac{m v^2}{r} \\] For a circular orbit, the gravitational force provides the necessary centripetal force, so: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Cancel \\(m\\) (assuming \\(m \\neq 0\\) ) and rearrange: \\[ v^2 = \\frac{G M}{r} \\] Relating Orbital Velocity to Orbital Period Now, relate orbital velocity \\(v\\) to the orbital period \\(T\\) : \\[ v = \\frac{2 \\pi r}{T} \\] Square both sides: \\[ v^2 = \\left( \\frac{2 \\pi r}{T} \\right)^2 = \\frac{4 \\pi^2 r^2}{T^2} \\] Substitute into the previous equation: \\[ \\frac{4 \\pi^2 r^2}{T^2} = \\frac{G M}{r} \\] Multiply both sides by \\(T^2\\) and rearrange: \\[ 4 \\pi^2 r^3 = G M T^2 \\] Finally, solve for \\(T^2\\) : \\[ T^2 = \\frac{4 \\pi^2}{G M} r^3 \\] Final Form (Kepler\u2019s Third Law for Circular Orbits) \\[ T^2 \\propto r^3 \\] This shows that the square of the orbital period is proportional to the cube of the orbital radius, which is exactly Kepler\u2019s Third Law\u2014now derived from Newtonian mechanics. 2. Implications of Kepler\u2019s Third Law in Astronomy The relationship: \\[ T^2 = \\frac{4 \\pi^2}{G M} r^3 \\] connects the orbital period \\(T\\) and the radius \\(r\\) of a body orbiting a much larger mass \\(M\\) . This has profound applications in astronomy: 1. Calculating the Mass of Celestial Bodies Rearranging the formula: \\[ M = \\frac{4 \\pi^2 r^3}{G T^2} \\] This allows astronomers to determine the mass of stars or planets by observing: - The orbital period \\(T\\) of a satellite or planet, - The orbital radius \\(r\\) . Example : Measuring a moon\u2019s orbit around a planet reveals the planet\u2019s mass. 2. Determining Orbital Distances If the mass \\(M\\) of the central object is known, and the period \\(T\\) is measured: \\[ r^3 = \\frac{G M T^2}{4 \\pi^2} \\] This is used to: - Determine planetary distances from stars, - Locate satellites\u2019 positions in Earth\u2019s orbit, - Plan space missions (e.g., calculating transfer orbits). 3. Understanding Planetary Systems Comparing planets within a solar system shows that those farther out orbit more slowly. Confirming Kepler\u2019s law across many systems supports the universal nature of gravity. 4. Applications in Space Missions and Satellites Engineers use this law to place satellites into stable orbits at precise altitudes (e.g., GPS satellites). It\u2019s crucial in designing interplanetary missions, where timing and distance must be exact. 3. Examples and Applications of Kepler\u2019s Third Law Example 1: The Moon\u2019s Orbit Around Earth Observed Orbital Period : \\(T_{\\text{Moon}} \\approx 27.3\\) days = \\(2.36 \\times 10^6\\) seconds Orbital Radius : \\(r \\approx 3.84 \\times 10^8\\) meters Using Kepler\u2019s Third Law: \\[ M_{\\text{Earth}} = \\frac{4 \\pi^2 r^3}{G T^2} \\] Plug in values: - \\(r = 3.84 \\times 10^8 \\, \\text{m}\\) - \\(T = 2.36 \\times 10^6 \\, \\text{s}\\) - \\(G = 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) (gravitational constant) This yields: $$ M_{\\text{Earth}} \\approx 5.97 \\times 10^{24} \\, \\text{kg} $$ This matches the known mass of Earth, confirming the accuracy of the law. Example 2: Planets Orbiting the Sun Planet Orbital Radius (AU) Orbital Period (years) \\(T^2\\) \\(r^3\\) Earth 1.00 1.00 1.00 1.00 Mars 1.52 1.88 3.53 3.51 Jupiter 5.20 11.86 140.7 140.6 Result : \\(T^2 \\approx r^3\\) for all planets, validating Kepler\u2019s Third Law across the Solar System. Application in Space Missions NASA and ESA use these calculations to: - Place satellites in orbit. - Time planetary flybys (e.g., Voyager, Juno). - Determine exoplanet distances and host star masses using orbital data. 4. Python Implementation: Simulating Circular Orbits This simulation will: Simulate circular orbits for different radii. Compute orbital periods numerically. Compare with Kepler\u2019s Third Law: $$ T^2 \\propto r^3 $$ import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # mass of central body (Earth) in kg # Radii for orbits (in meters) radii = np.linspace(7e6, 4.2e7, 100) # from low Earth orbit to geostationary # Calculate periods for each radius using Kepler's Third Law # T = 2\u03c0 * sqrt(r^3 / GM) periods = 2 * np.pi * np.sqrt(radii**3 / (G * M)) # Plotting T^2 vs r^3 to verify linearity T_squared = periods**2 r_cubed = radii**3 plt.figure(figsize=(8, 6)) plt.plot(r_cubed, T_squared, label=r\"$T^2$ vs $r^3$\") plt.xlabel(\"Orbital Radius Cubed ($r^3$) [m\u00b3]\") plt.ylabel(\"Orbital Period Squared ($T^2$) [s\u00b2]\") plt.title(\"Verification of Kepler's Third Law for Circular Orbits\") plt.grid(True) plt.legend() plt.show() 5.Static Visualization of Circular Orbit + Period This simulation will: Shows a full circular orbit for one satellite around Earth. Displays Earth as a blue dot and the satellite path in red. Includes the orbital period in the title for clarity. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # mass of Earth (kg) r = 2.0e7 # orbital radius (m) # Orbital period using Kepler's Third Law T = 2 * np.pi * np.sqrt(r**3 / (G * M)) # seconds # Time array for one full orbit t = np.linspace(0, T, 1000) # Calculate position coordinates x = r * np.cos(2 * np.pi * t / T) y = r * np.sin(2 * np.pi * t / T) # Plotting the orbit plt.figure(figsize=(7, 7)) plt.plot(x, y, label=\"Satellite Orbit\", color='red') plt.scatter(0, 0, color='blue', s=300, label=\"Earth\") plt.title(f\"Circular Orbit (r = {r/1e6:.1f} Mm)\\nOrbital Period = {T/3600:.2f} hours\") plt.xlabel(\"x-position (m)\") plt.ylabel(\"y-position (m)\") plt.axis('equal') plt.grid(True) plt.legend() plt.show() 6. Multiple Orbits + Kepler Verification This simulation will: Plots multiple orbits at different radii on the same graph for comparison. Also plots \\(T^2\\) vs \\(r^3\\) for those orbits to confirm Kepler\u2019s Law. Combines visual clarity and physics verification in one figure. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant M = 5.972e24 # mass of Earth earth_radius = 6.371e6 # Define multiple orbital radii (in meters) radii = np.array([1e7, 1.5e7, 2e7, 2.5e7, 3e7]) # from LEO to geostationary-ish # Prepare figure for orbit plots plt.figure(figsize=(10, 5)) # ---------- Subplot 1: Orbits ---------- plt.subplot(1, 2, 1) theta = np.linspace(0, 2 * np.pi, 500) for r in radii: x = r * np.cos(theta) y = r * np.sin(theta) plt.plot(x, y, label=f\"r = {r/1e6:.1f} Mm\") # Plot Earth earth = plt.Circle((0, 0), earth_radius, color='blue', label=\"Earth\") plt.gca().add_patch(earth) plt.axis('equal') plt.title(\"Circular Orbits of Satellites\") plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.grid(True) plt.legend() # ---------- Subplot 2: Kepler T\u00b2 vs r\u00b3 ---------- T = 2 * np.pi * np.sqrt(radii**3 / (G * M)) T_squared = T**2 r_cubed = radii**3 plt.subplot(1, 2, 2) plt.plot(r_cubed, T_squared, 'o-', color='green') plt.title(\"Verification of Kepler's Third Law\") plt.xlabel(\"Orbital Radius\u00b3 (r\u00b3) [m\u00b3]\") plt.ylabel(\"Orbital Period\u00b2 (T\u00b2) [s\u00b2]\") plt.grid(True) plt.tight_layout() plt.show()","title":"1. Derivation of Kepler\u2019s Third Law for Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-derivation-of-keplers-third-law-for-circular-orbits","text":"We begin with two key physical laws:","title":"1. Derivation of Kepler\u2019s Third Law for Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-newtons-law-of-universal-gravitation","text":"\\[ F_{\\text{gravity}} = \\frac{G M m}{r^2} \\] Where: - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of the central body (e.g., planet or star), - \\(m\\) is the mass of the orbiting body, - \\(r\\) is the orbital radius.","title":"1. Newton's Law of Universal Gravitation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-centripetal-force-for-circular-motion","text":"\\[ F_{\\text{centripetal}} = \\frac{m v^2}{r} \\] For a circular orbit, the gravitational force provides the necessary centripetal force, so: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Cancel \\(m\\) (assuming \\(m \\neq 0\\) ) and rearrange: \\[ v^2 = \\frac{G M}{r} \\]","title":"2. Centripetal Force for Circular Motion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#relating-orbital-velocity-to-orbital-period","text":"Now, relate orbital velocity \\(v\\) to the orbital period \\(T\\) : \\[ v = \\frac{2 \\pi r}{T} \\] Square both sides: \\[ v^2 = \\left( \\frac{2 \\pi r}{T} \\right)^2 = \\frac{4 \\pi^2 r^2}{T^2} \\] Substitute into the previous equation: \\[ \\frac{4 \\pi^2 r^2}{T^2} = \\frac{G M}{r} \\] Multiply both sides by \\(T^2\\) and rearrange: \\[ 4 \\pi^2 r^3 = G M T^2 \\] Finally, solve for \\(T^2\\) : \\[ T^2 = \\frac{4 \\pi^2}{G M} r^3 \\]","title":"Relating Orbital Velocity to Orbital Period"},{"location":"1%20Physics/2%20Gravity/Problem_1/#final-form-keplers-third-law-for-circular-orbits","text":"\\[ T^2 \\propto r^3 \\] This shows that the square of the orbital period is proportional to the cube of the orbital radius, which is exactly Kepler\u2019s Third Law\u2014now derived from Newtonian mechanics.","title":"Final Form (Kepler\u2019s Third Law for Circular Orbits)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-implications-of-keplers-third-law-in-astronomy","text":"The relationship: \\[ T^2 = \\frac{4 \\pi^2}{G M} r^3 \\] connects the orbital period \\(T\\) and the radius \\(r\\) of a body orbiting a much larger mass \\(M\\) . This has profound applications in astronomy:","title":"2. Implications of Kepler\u2019s Third Law in Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-calculating-the-mass-of-celestial-bodies","text":"Rearranging the formula: \\[ M = \\frac{4 \\pi^2 r^3}{G T^2} \\] This allows astronomers to determine the mass of stars or planets by observing: - The orbital period \\(T\\) of a satellite or planet, - The orbital radius \\(r\\) . Example : Measuring a moon\u2019s orbit around a planet reveals the planet\u2019s mass.","title":"1. Calculating the Mass of Celestial Bodies"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-determining-orbital-distances","text":"If the mass \\(M\\) of the central object is known, and the period \\(T\\) is measured: \\[ r^3 = \\frac{G M T^2}{4 \\pi^2} \\] This is used to: - Determine planetary distances from stars, - Locate satellites\u2019 positions in Earth\u2019s orbit, - Plan space missions (e.g., calculating transfer orbits).","title":"2. Determining Orbital Distances"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-understanding-planetary-systems","text":"Comparing planets within a solar system shows that those farther out orbit more slowly. Confirming Kepler\u2019s law across many systems supports the universal nature of gravity.","title":"3. Understanding Planetary Systems"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-applications-in-space-missions-and-satellites","text":"Engineers use this law to place satellites into stable orbits at precise altitudes (e.g., GPS satellites). It\u2019s crucial in designing interplanetary missions, where timing and distance must be exact.","title":"4. Applications in Space Missions and Satellites"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-examples-and-applications-of-keplers-third-law","text":"","title":"3. Examples and Applications of Kepler\u2019s Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-1-the-moons-orbit-around-earth","text":"Observed Orbital Period : \\(T_{\\text{Moon}} \\approx 27.3\\) days = \\(2.36 \\times 10^6\\) seconds Orbital Radius : \\(r \\approx 3.84 \\times 10^8\\) meters Using Kepler\u2019s Third Law: \\[ M_{\\text{Earth}} = \\frac{4 \\pi^2 r^3}{G T^2} \\] Plug in values: - \\(r = 3.84 \\times 10^8 \\, \\text{m}\\) - \\(T = 2.36 \\times 10^6 \\, \\text{s}\\) - \\(G = 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) (gravitational constant) This yields: $$ M_{\\text{Earth}} \\approx 5.97 \\times 10^{24} \\, \\text{kg} $$ This matches the known mass of Earth, confirming the accuracy of the law.","title":"Example 1: The Moon\u2019s Orbit Around Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-2-planets-orbiting-the-sun","text":"Planet Orbital Radius (AU) Orbital Period (years) \\(T^2\\) \\(r^3\\) Earth 1.00 1.00 1.00 1.00 Mars 1.52 1.88 3.53 3.51 Jupiter 5.20 11.86 140.7 140.6 Result : \\(T^2 \\approx r^3\\) for all planets, validating Kepler\u2019s Third Law across the Solar System.","title":"Example 2: Planets Orbiting the Sun"},{"location":"1%20Physics/2%20Gravity/Problem_1/#application-in-space-missions","text":"NASA and ESA use these calculations to: - Place satellites in orbit. - Time planetary flybys (e.g., Voyager, Juno). - Determine exoplanet distances and host star masses using orbital data.","title":"Application in Space Missions"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-python-implementation-simulating-circular-orbits","text":"This simulation will: Simulate circular orbits for different radii. Compute orbital periods numerically. Compare with Kepler\u2019s Third Law: $$ T^2 \\propto r^3 $$ import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # mass of central body (Earth) in kg # Radii for orbits (in meters) radii = np.linspace(7e6, 4.2e7, 100) # from low Earth orbit to geostationary # Calculate periods for each radius using Kepler's Third Law # T = 2\u03c0 * sqrt(r^3 / GM) periods = 2 * np.pi * np.sqrt(radii**3 / (G * M)) # Plotting T^2 vs r^3 to verify linearity T_squared = periods**2 r_cubed = radii**3 plt.figure(figsize=(8, 6)) plt.plot(r_cubed, T_squared, label=r\"$T^2$ vs $r^3$\") plt.xlabel(\"Orbital Radius Cubed ($r^3$) [m\u00b3]\") plt.ylabel(\"Orbital Period Squared ($T^2$) [s\u00b2]\") plt.title(\"Verification of Kepler's Third Law for Circular Orbits\") plt.grid(True) plt.legend() plt.show()","title":"4. Python Implementation: Simulating Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5static-visualization-of-circular-orbit-period","text":"This simulation will: Shows a full circular orbit for one satellite around Earth. Displays Earth as a blue dot and the satellite path in red. Includes the orbital period in the title for clarity. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # mass of Earth (kg) r = 2.0e7 # orbital radius (m) # Orbital period using Kepler's Third Law T = 2 * np.pi * np.sqrt(r**3 / (G * M)) # seconds # Time array for one full orbit t = np.linspace(0, T, 1000) # Calculate position coordinates x = r * np.cos(2 * np.pi * t / T) y = r * np.sin(2 * np.pi * t / T) # Plotting the orbit plt.figure(figsize=(7, 7)) plt.plot(x, y, label=\"Satellite Orbit\", color='red') plt.scatter(0, 0, color='blue', s=300, label=\"Earth\") plt.title(f\"Circular Orbit (r = {r/1e6:.1f} Mm)\\nOrbital Period = {T/3600:.2f} hours\") plt.xlabel(\"x-position (m)\") plt.ylabel(\"y-position (m)\") plt.axis('equal') plt.grid(True) plt.legend() plt.show()","title":"5.Static Visualization of Circular Orbit + Period"},{"location":"1%20Physics/2%20Gravity/Problem_1/#6-multiple-orbits-kepler-verification","text":"This simulation will: Plots multiple orbits at different radii on the same graph for comparison. Also plots \\(T^2\\) vs \\(r^3\\) for those orbits to confirm Kepler\u2019s Law. Combines visual clarity and physics verification in one figure. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant M = 5.972e24 # mass of Earth earth_radius = 6.371e6 # Define multiple orbital radii (in meters) radii = np.array([1e7, 1.5e7, 2e7, 2.5e7, 3e7]) # from LEO to geostationary-ish # Prepare figure for orbit plots plt.figure(figsize=(10, 5)) # ---------- Subplot 1: Orbits ---------- plt.subplot(1, 2, 1) theta = np.linspace(0, 2 * np.pi, 500) for r in radii: x = r * np.cos(theta) y = r * np.sin(theta) plt.plot(x, y, label=f\"r = {r/1e6:.1f} Mm\") # Plot Earth earth = plt.Circle((0, 0), earth_radius, color='blue', label=\"Earth\") plt.gca().add_patch(earth) plt.axis('equal') plt.title(\"Circular Orbits of Satellites\") plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.grid(True) plt.legend() # ---------- Subplot 2: Kepler T\u00b2 vs r\u00b3 ---------- T = 2 * np.pi * np.sqrt(radii**3 / (G * M)) T_squared = T**2 r_cubed = radii**3 plt.subplot(1, 2, 2) plt.plot(r_cubed, T_squared, 'o-', color='green') plt.title(\"Verification of Kepler's Third Law\") plt.xlabel(\"Orbital Radius\u00b3 (r\u00b3) [m\u00b3]\") plt.ylabel(\"Orbital Period\u00b2 (T\u00b2) [s\u00b2]\") plt.grid(True) plt.tight_layout() plt.show()","title":"6. Multiple Orbits + Kepler Verification"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"1. Cosmic Velocities \u2013 Definitions & Physical Meaning Cosmic velocities refer to the critical speeds needed to achieve specific motion objectives relative to a celestial body like Earth. These are fundamental in space exploration and orbital mechanics. 1. First Cosmic Velocity (Orbital Velocity) Definition : The minimum speed required to place an object into a stable circular orbit just above the surface of a planet. Formula : \\[ v_1 = \\sqrt{\\frac{G M}{R}} \\] Where: - \\(G\\) = gravitational constant, - \\(M\\) = mass of the planet, - \\(R\\) = radius of the planet (from center to orbit). Physical Meaning : The object doesn\u2019t fall to Earth because it\u2019s \"falling around\" it in a circular path\u2014this is what keeps satellites in orbit. 2. Second Cosmic Velocity (Escape Velocity) Definition : The minimum speed needed to completely escape a planet\u2019s gravitational field without further propulsion. Formula : \\[ v_2 = \\sqrt{\\frac{2 G M}{R}} = \\sqrt{2} \\cdot v_1 \\] Physical Meaning : If launched at this speed (ignoring air resistance), the object will move away from the planet forever\u2014reaching infinite distance with zero final speed. 3. Third Cosmic Velocity Definition : The minimum speed required to escape the gravitational pull of the entire Solar System, starting from Earth. Formula (approximate) : \\[ v_3 \\approx 16.7 \\, \\text{km/s} \\quad (\\text{from Earth\u2019s surface}) \\] Physical Meaning : This is the speed needed for interstellar missions\u2014e.g., what Voyager 1 achieved to escape the Sun\u2019s gravity. 2. Mathematical Derivations Recap First Cosmic Velocity ( \\(v_1\\) ) Derived by equating centripetal force and gravitational force: \\[ \\frac{G M m}{R^2} = \\frac{m v^2}{R} \\Rightarrow v_1 = \\sqrt{\\frac{G M}{R}} \\] Depends on : - \\(G\\) : Gravitational constant, - \\(M\\) : Mass of the planet or central body, - \\(R\\) : Radius from the center of the body to the object. Second Cosmic Velocity ( \\(v_2\\) ) Derived from conservation of energy: \\[ \\frac{1}{2} m v^2 = \\frac{G M m}{R} \\Rightarrow v_2 = \\sqrt{\\frac{2 G M}{R}} = \\sqrt{2} \\cdot v_1 \\] Depends on : Same as \\(v_1\\) \u2014but scaled by \\(\\sqrt{2}\\) . Third Cosmic Velocity ( \\(v_3\\) ) More complex, must account for: - Escape from Earth\u2019s gravity, - Escape from the Sun\u2019s gravity while starting within Earth\u2019s orbit. Approximate from Earth\u2019s surface: \\[ v_3 \\approx \\sqrt{v_2^2 + v_{\\text{Earth orbital}}^2} \\Rightarrow v_3 \\approx \\sqrt{\\left( \\frac{2 G M_{\\text{Earth}}}{R} \\right)^2 + \\left( \\frac{G M_{\\text{Sun}}}{R_{\\text{Earth orbit}}} \\right)^2} \\] Depends on : - Earth\u2019s escape velocity, - Earth\u2019s orbital speed around the Sun, - Sun\u2019s gravitational influence. Parameters That Affect All Velocities Parameter Effect on Velocity \\(M\\) Directly proportional \u2013 more mass \u2192 higher velocity \\(R\\) Inversely proportional to \\(\\sqrt{R}\\) \u2013 higher altitude \u2192 lower velocity \\(G\\) Universal, doesn\u2019t change 3. Python Simulation: 1. Cosmic Velocities import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) # Planetary data: [Mass (kg), Radius (m)] bodies = { 'Earth': [5.972e24, 6.371e6], 'Mars': [6.39e23, 3.39e6], 'Jupiter': [1.898e27, 6.99e7] } # Prepare lists for plotting planet_names = list(bodies.keys()) v1_values = [] v2_values = [] # Compute velocities for name in planet_names: mass, radius = bodies[name] v1 = np.sqrt(G * mass / radius) # First cosmic velocity v2 = np.sqrt(2 * G * mass / radius) # Second cosmic velocity v1_values.append(v1 / 1000) # Convert to km/s v2_values.append(v2 / 1000) # X positions x = np.arange(len(planet_names)) # Plot plt.figure(figsize=(10, 6)) # First Cosmic Velocity plt.plot(x, v1_values, 'o-', label='1st Cosmic Velocity (Orbital)', linewidth=2, markersize=8, color='royalblue') # Second Cosmic Velocity plt.plot(x, v2_values, 's--', label='2nd Cosmic Velocity (Escape)', linewidth=2, markersize=8, color='darkorange') # Formatting plt.xticks(x, planet_names) plt.ylabel('Velocity (km/s)') plt.title('Cosmic Velocities of Earth, Mars, and Jupiter') plt.grid(True, linestyle='--', alpha=0.5) plt.legend() plt.tight_layout() plt.show() 2. Escape Velocity vs. Altitude import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant M = 5.972e24 # mass of Earth R = 6.371e6 # radius of Earth # Altitudes from surface (in meters) altitudes = np.linspace(0, 5e7, 500) # from 0 to 50,000 km radii = R + altitudes # Escape velocity formula: v = sqrt(2GM/r) escape_velocities = np.sqrt(2 * G * M / radii) / 1000 # convert to km/s # Plotting plt.figure(figsize=(10, 6)) plt.plot(altitudes / 1000, escape_velocities, color='crimson', linewidth=2) plt.title(\"Escape Velocity vs. Altitude (from Earth's Surface)\") plt.xlabel(\"Altitude above Earth (km)\") plt.ylabel(\"Escape Velocity (km/s)\") plt.grid(True, linestyle='--', alpha=0.5) plt.tight_layout() plt.show() 3. Escape Velocity vs Mass import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant R = 6.371e6 # Fixed radius (Earth's radius) # Generate a range of masses (from small moon to gas giant) masses = np.logspace(21, 28, 500) # kg # Calculate escape velocities v_escape = np.sqrt(2 * G * masses / R) / 1000 # in km/s # Plot plt.figure(figsize=(10, 6)) plt.plot(masses, v_escape, color='seagreen', linewidth=2) plt.xscale('log') plt.title(\"Escape Velocity vs Planetary Mass (Fixed Radius)\") plt.xlabel(\"Mass (kg, log scale)\") plt.ylabel(\"Escape Velocity (km/s)\") plt.grid(True, which='both', linestyle='--', alpha=0.5) plt.tight_layout() plt.show() Explanation of simulations: 1. Escape Velocity vs Mass This simulation illustrates how escape velocity increases as a planet\u2019s mass increases, assuming the radius stays the same. It demonstrates that a more massive object has a stronger gravitational pull, requiring a higher speed to escape. This helps explain why escaping from Jupiter is much harder than from Mars, even at the same altitude. 2. Escape Velocity vs Altitude This plot reveals how escape velocity decreases with increasing altitude above a planet (e.g., Earth). It shows why spacecraft are launched into low Earth orbit before igniting for deeper missions\u2014less energy is needed to escape from higher altitudes. This is a practical consideration in spaceflight efficiency. 3. Cosmic Velocities (1st, 2nd, and 3rd) vs Radius and Mass This complex plot compares the first (orbital), second (escape), and third (solar escape) cosmic velocities for celestial bodies of different masses and radii (e.g., Mars-like, Earth-like, Jupiter-like). It brings together all three cosmic thresholds and shows how they change with planet size. It helps visualize how deep space missions (e.g., Voyager 1) must exceed even the third cosmic velocity to escape the Sun\u2019s pull. 4. Importance of Cosmic Velocities in Space Exploration Understanding the first, second, and third cosmic velocities is essential for planning and executing missions beyond Earth: 1. First Cosmic Velocity (Orbital Velocity) Purpose : Placing satellites into stable Low Earth Orbit (LEO) or Geostationary Orbits. Why it matters : - Ensures satellites stay in motion without falling back. - Used in GPS, weather monitoring, communication, and the International Space Station (ISS). Mission Example : Launching the Hubble Space Telescope or the International Space Station (ISS). 2. Second Cosmic Velocity (Escape Velocity) Purpose : Sending spacecraft beyond Earth\u2019s gravity\u2014to the Moon, Mars, or other celestial bodies. Why it matters : - Determines the minimum launch energy required to leave Earth. - Critical for interplanetary missions. Mission Example : Apollo missions, Mars rovers, Voyager 2 flybys of outer planets. 3. Third Cosmic Velocity (Interstellar Escape) Purpose : Escaping the gravitational pull of the entire Solar System. Why it matters : - Essential for interstellar probes. - Helps define mission limits and fuel constraints. Mission Example : Voyager 1, which has exceeded the third cosmic velocity and is now in interstellar space.","title":"1. Cosmic Velocities \u2013 Definitions &amp; Physical Meaning"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-cosmic-velocities-definitions-physical-meaning","text":"Cosmic velocities refer to the critical speeds needed to achieve specific motion objectives relative to a celestial body like Earth. These are fundamental in space exploration and orbital mechanics.","title":"1. Cosmic Velocities \u2013 Definitions &amp; Physical Meaning"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity-orbital-velocity","text":"Definition : The minimum speed required to place an object into a stable circular orbit just above the surface of a planet. Formula : \\[ v_1 = \\sqrt{\\frac{G M}{R}} \\] Where: - \\(G\\) = gravitational constant, - \\(M\\) = mass of the planet, - \\(R\\) = radius of the planet (from center to orbit). Physical Meaning : The object doesn\u2019t fall to Earth because it\u2019s \"falling around\" it in a circular path\u2014this is what keeps satellites in orbit.","title":"1. First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity-escape-velocity","text":"Definition : The minimum speed needed to completely escape a planet\u2019s gravitational field without further propulsion. Formula : \\[ v_2 = \\sqrt{\\frac{2 G M}{R}} = \\sqrt{2} \\cdot v_1 \\] Physical Meaning : If launched at this speed (ignoring air resistance), the object will move away from the planet forever\u2014reaching infinite distance with zero final speed.","title":"2. Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-third-cosmic-velocity","text":"Definition : The minimum speed required to escape the gravitational pull of the entire Solar System, starting from Earth. Formula (approximate) : \\[ v_3 \\approx 16.7 \\, \\text{km/s} \\quad (\\text{from Earth\u2019s surface}) \\] Physical Meaning : This is the speed needed for interstellar missions\u2014e.g., what Voyager 1 achieved to escape the Sun\u2019s gravity.","title":"3. Third Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-mathematical-derivations-recap","text":"","title":"2. Mathematical Derivations Recap"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-v_1","text":"Derived by equating centripetal force and gravitational force: \\[ \\frac{G M m}{R^2} = \\frac{m v^2}{R} \\Rightarrow v_1 = \\sqrt{\\frac{G M}{R}} \\] Depends on : - \\(G\\) : Gravitational constant, - \\(M\\) : Mass of the planet or central body, - \\(R\\) : Radius from the center of the body to the object.","title":"First Cosmic Velocity (\\(v_1\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-v_2","text":"Derived from conservation of energy: \\[ \\frac{1}{2} m v^2 = \\frac{G M m}{R} \\Rightarrow v_2 = \\sqrt{\\frac{2 G M}{R}} = \\sqrt{2} \\cdot v_1 \\] Depends on : Same as \\(v_1\\) \u2014but scaled by \\(\\sqrt{2}\\) .","title":"Second Cosmic Velocity (\\(v_2\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-v_3","text":"More complex, must account for: - Escape from Earth\u2019s gravity, - Escape from the Sun\u2019s gravity while starting within Earth\u2019s orbit. Approximate from Earth\u2019s surface: \\[ v_3 \\approx \\sqrt{v_2^2 + v_{\\text{Earth orbital}}^2} \\Rightarrow v_3 \\approx \\sqrt{\\left( \\frac{2 G M_{\\text{Earth}}}{R} \\right)^2 + \\left( \\frac{G M_{\\text{Sun}}}{R_{\\text{Earth orbit}}} \\right)^2} \\] Depends on : - Earth\u2019s escape velocity, - Earth\u2019s orbital speed around the Sun, - Sun\u2019s gravitational influence.","title":"Third Cosmic Velocity (\\(v_3\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#parameters-that-affect-all-velocities","text":"Parameter Effect on Velocity \\(M\\) Directly proportional \u2013 more mass \u2192 higher velocity \\(R\\) Inversely proportional to \\(\\sqrt{R}\\) \u2013 higher altitude \u2192 lower velocity \\(G\\) Universal, doesn\u2019t change","title":"Parameters That Affect All Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-python-simulation","text":"","title":"3. Python Simulation:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-cosmic-velocities","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) # Planetary data: [Mass (kg), Radius (m)] bodies = { 'Earth': [5.972e24, 6.371e6], 'Mars': [6.39e23, 3.39e6], 'Jupiter': [1.898e27, 6.99e7] } # Prepare lists for plotting planet_names = list(bodies.keys()) v1_values = [] v2_values = [] # Compute velocities for name in planet_names: mass, radius = bodies[name] v1 = np.sqrt(G * mass / radius) # First cosmic velocity v2 = np.sqrt(2 * G * mass / radius) # Second cosmic velocity v1_values.append(v1 / 1000) # Convert to km/s v2_values.append(v2 / 1000) # X positions x = np.arange(len(planet_names)) # Plot plt.figure(figsize=(10, 6)) # First Cosmic Velocity plt.plot(x, v1_values, 'o-', label='1st Cosmic Velocity (Orbital)', linewidth=2, markersize=8, color='royalblue') # Second Cosmic Velocity plt.plot(x, v2_values, 's--', label='2nd Cosmic Velocity (Escape)', linewidth=2, markersize=8, color='darkorange') # Formatting plt.xticks(x, planet_names) plt.ylabel('Velocity (km/s)') plt.title('Cosmic Velocities of Earth, Mars, and Jupiter') plt.grid(True, linestyle='--', alpha=0.5) plt.legend() plt.tight_layout() plt.show()","title":"1. Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-escape-velocity-vs-altitude","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant M = 5.972e24 # mass of Earth R = 6.371e6 # radius of Earth # Altitudes from surface (in meters) altitudes = np.linspace(0, 5e7, 500) # from 0 to 50,000 km radii = R + altitudes # Escape velocity formula: v = sqrt(2GM/r) escape_velocities = np.sqrt(2 * G * M / radii) / 1000 # convert to km/s # Plotting plt.figure(figsize=(10, 6)) plt.plot(altitudes / 1000, escape_velocities, color='crimson', linewidth=2) plt.title(\"Escape Velocity vs. Altitude (from Earth's Surface)\") plt.xlabel(\"Altitude above Earth (km)\") plt.ylabel(\"Escape Velocity (km/s)\") plt.grid(True, linestyle='--', alpha=0.5) plt.tight_layout() plt.show()","title":"2. Escape Velocity vs. Altitude"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-escape-velocity-vs-mass","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant R = 6.371e6 # Fixed radius (Earth's radius) # Generate a range of masses (from small moon to gas giant) masses = np.logspace(21, 28, 500) # kg # Calculate escape velocities v_escape = np.sqrt(2 * G * masses / R) / 1000 # in km/s # Plot plt.figure(figsize=(10, 6)) plt.plot(masses, v_escape, color='seagreen', linewidth=2) plt.xscale('log') plt.title(\"Escape Velocity vs Planetary Mass (Fixed Radius)\") plt.xlabel(\"Mass (kg, log scale)\") plt.ylabel(\"Escape Velocity (km/s)\") plt.grid(True, which='both', linestyle='--', alpha=0.5) plt.tight_layout() plt.show()","title":"3. Escape Velocity vs Mass"},{"location":"1%20Physics/2%20Gravity/Problem_2/#explanation-of-simulations","text":"","title":"Explanation of simulations:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-escape-velocity-vs-mass","text":"This simulation illustrates how escape velocity increases as a planet\u2019s mass increases, assuming the radius stays the same. It demonstrates that a more massive object has a stronger gravitational pull, requiring a higher speed to escape. This helps explain why escaping from Jupiter is much harder than from Mars, even at the same altitude.","title":"1. Escape Velocity vs Mass"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-escape-velocity-vs-altitude_1","text":"This plot reveals how escape velocity decreases with increasing altitude above a planet (e.g., Earth). It shows why spacecraft are launched into low Earth orbit before igniting for deeper missions\u2014less energy is needed to escape from higher altitudes. This is a practical consideration in spaceflight efficiency.","title":"2. Escape Velocity vs Altitude"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-cosmic-velocities-1st-2nd-and-3rd-vs-radius-and-mass","text":"This complex plot compares the first (orbital), second (escape), and third (solar escape) cosmic velocities for celestial bodies of different masses and radii (e.g., Mars-like, Earth-like, Jupiter-like). It brings together all three cosmic thresholds and shows how they change with planet size. It helps visualize how deep space missions (e.g., Voyager 1) must exceed even the third cosmic velocity to escape the Sun\u2019s pull.","title":"3. Cosmic Velocities (1st, 2nd, and 3rd) vs Radius and Mass"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-importance-of-cosmic-velocities-in-space-exploration","text":"Understanding the first, second, and third cosmic velocities is essential for planning and executing missions beyond Earth:","title":"4. Importance of Cosmic Velocities in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity-orbital-velocity_1","text":"Purpose : Placing satellites into stable Low Earth Orbit (LEO) or Geostationary Orbits. Why it matters : - Ensures satellites stay in motion without falling back. - Used in GPS, weather monitoring, communication, and the International Space Station (ISS). Mission Example : Launching the Hubble Space Telescope or the International Space Station (ISS).","title":"1. First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity-escape-velocity_1","text":"Purpose : Sending spacecraft beyond Earth\u2019s gravity\u2014to the Moon, Mars, or other celestial bodies. Why it matters : - Determines the minimum launch energy required to leave Earth. - Critical for interplanetary missions. Mission Example : Apollo missions, Mars rovers, Voyager 2 flybys of outer planets.","title":"2. Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-third-cosmic-velocity-interstellar-escape","text":"Purpose : Escaping the gravitational pull of the entire Solar System. Why it matters : - Essential for interstellar probes. - Helps define mission limits and fuel constraints. Mission Example : Voyager 1, which has exceeded the third cosmic velocity and is now in interstellar space.","title":"3. Third Cosmic Velocity (Interstellar Escape)"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"1. Analyze the Possible Trajectories of a Payload Released Near Earth Objective When a payload is released from a spacecraft near Earth, its subsequent trajectory depends on its initial velocity and position relative to Earth. The shape of the path\u2014elliptical, parabolic, or hyperbolic\u2014is governed by Newton\u2019s Law of Gravitation and the conservation of mechanical energy. Understanding these paths is fundamental in planning: - Satellite orbits, - Escape missions, - Reentry maneuvers, - Interplanetary probes. Governing Force \u2013 Newton\u2019s Law of Universal Gravitation The force acting on the payload due to Earth\u2019s gravity is: \\[ F = -\\frac{G M m}{r^2} \\hat{r} \\] Where: - \\(G\\) : Gravitational constant ( \\(6.674 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2\\) ), - \\(M\\) : Mass of Earth, - \\(m\\) : Mass of the payload, - \\(r\\) : Distance from Earth\u2019s center, - \\(\\hat{r}\\) : Unit vector from Earth to the payload. Total Mechanical Energy The motion is governed by conservation of total mechanical energy: \\[ E = \\frac{1}{2} m v^2 - \\frac{G M m}{r} \\] This determines the trajectory type: Energy Condition Trajectory Type Description \\(E < 0\\) Elliptical Closed orbit; bound to Earth \\(E = 0\\) Parabolic Just enough speed to escape; marginal escape \\(E > 0\\) Hyperbolic Unbound; excess speed leads to escape Escape Velocity The minimum speed required to escape Earth\u2019s gravitational pull is: \\[ v_{\\text{escape}} = \\sqrt{\\frac{2 G M}{r}} \\] If the payload\u2019s speed \\(v = v_{\\text{escape}}\\) \u2192 parabolic trajectory. If \\(v < v_{\\text{escape}}\\) \u2192 elliptical (or circular) trajectory. If \\(v > v_{\\text{escape}}\\) \u2192 hyperbolic trajectory. Shape of the Orbit: Conic Sections The orbit a payload follows is a conic section with Earth at one focus. Its shape depends on the specific mechanical energy and eccentricity \\(e\\) : Eccentricity \\(e\\) Orbit Type \\(e = 0\\) Circular \\(0 < e < 1\\) Elliptical \\(e = 1\\) Parabolic \\(e > 1\\) Hyperbolic Eccentricity can be derived using energy and angular momentum, but for initial velocity analysis, energy alone is sufficient to determine the type. 2. Numerical Analysis of Payload Trajectory Based on Initial Conditions Objective Given the initial position, velocity, and altitude of a payload released near Earth, compute its path using numerical methods that solve Newton\u2019s equations of motion under gravity. This analysis helps determine whether the payload: - Falls back to Earth (reentry), - Enters orbit, - Escapes Earth\u2019s gravity. Physical Model We use Newton\u2019s second law and universal gravitation: \\[ F = m a = -\\frac{G M m}{r^3} r \\Rightarrow a = -\\frac{G M}{r^3} r \\] Where: - \\(r\\) : Position vector from Earth\u2019s center, - \\(a\\) : Acceleration, - \\(r = \\|r\\|\\) : Magnitude of the position vector. Numerical Integration: Euler or Runge-Kutta We use a numerical integration scheme (Euler or RK4) to compute \\(r(t)\\) and \\(v(t)\\) over time: \\[ \\frac{dr}{dt} = v, \\quad \\frac{dv}{dt} = -\\frac{G M}{r^3} r \\] 3. How Trajectories Relate to Orbital Insertion, Reentry, and Escape Objective Interpret the numerical results from Task 2 by linking trajectory types to actual space mission outcomes: - Stable orbit (insertion), - Reentry (falling back to Earth), - Escape (leaving Earth\u2019s gravity). 1. Orbital Insertion (Stable Orbit) Scenario : The payload achieves a stable elliptical or circular orbit around Earth. Conditions : - Total mechanical energy \\(E < 0\\) . - Velocity \\(v < v_{\\text{escape}}\\) , but high enough to avoid crashing. - Perigee (lowest point) stays above Earth\u2019s surface. Result in Simulation : - The trajectory curves around Earth and doesn\u2019t intersect with the planet. - Path may be circular (if speed is just right) or elliptical (most common). Real-world Examples : - Satellites (e.g., Starlink), - International Space Station (ISS), - Lunar parking orbits before transfer burns. 2. Reentry (Atmospheric Fall or Crash) Scenario : The payload\u2019s speed is too low to sustain an orbit, causing it to fall back. Conditions : - \\(v < v_{\\text{orbital}}\\) , - Still \\(E < 0\\) , but perigee drops below Earth\u2019s surface, - Or starts with a downward velocity component. Result in Simulation : - The trajectory spirals or curves downward and eventually hits the Earth (passes inside Earth\u2019s radius). Real-world Examples : - Returning space capsules (e.g., SpaceX Dragon), - Space debris reentry, - Rocket stage disposal. 3. Escape Trajectory (Leaving Earth\u2019s Gravity) Scenario : Payload reaches or exceeds escape velocity and is no longer gravitationally bound to Earth. Conditions : - \\(v \\geq v_{\\text{escape}}\\) , - \\(E \\geq 0\\) (total mechanical energy \\(\\geq 0\\) ). Result in Simulation : - The trajectory becomes hyperbolic. - Payload moves away from Earth and never returns. Real-world Examples : - Interplanetary probes (e.g., Voyager, Mars rovers), - Asteroid missions (e.g., OSIRIS-REx), - Escape burns after low Earth orbit (LEO). 4. Simulation import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3/kg/s^2 M = 5.972e24 # kg (mass of Earth) R_earth = 6.371e6 # m (radius of Earth) # Initial conditions altitude = 400e3 # 400 km above Earth r0 = np.array([R_earth + altitude, 0]) # Start on x-axis v0 = np.array([0, 7500], dtype=float) # Tangential velocity (m/s), changed to float # initialize to float array # Time setup dt = 1.0 # seconds, changed to float t_max = 6000 # total simulation time in seconds steps = int(t_max / dt) # Initialize position, velocity r = r0.copy() v = v0.copy() # Storage for path trajectory = [r.copy()] # Euler integration for _ in range(steps): r_mag = np.linalg.norm(r) a = -G * M * r / r_mag**3 v += a * dt r += v * dt trajectory.append(r.copy()) trajectory = np.array(trajectory) # Plot plt.figure(figsize=(7, 7)) plt.plot(trajectory[:, 0], trajectory[:, 1], label='Payload Path') plt.gca().add_patch(plt.Circle((0, 0), R_earth, color='blue', alpha=0.3, label='Earth')) plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Payload Trajectory (Numerical Simulation)') plt.axis('equal') plt.grid(True) plt.legend() plt.show() Explanation: Payload Trajectory Simulation This Python script simulates and visualizes the trajectory of a payload released near Earth, using numerical integration to solve Newton\u2019s equations of motion under gravitational force. The simulation determines the payload\u2019s path based on its initial conditions. Parameters \\(G = 6.67430 \\times 10^{-11} \\, \\text{m}^3/\\text{kg}/\\text{s}^2\\) : Gravitational constant. \\(M = 5.972 \\times 10^{24} \\, \\text{kg}\\) : Mass of Earth. \\(R_{\\text{Earth}} = 6.371 \\times 10^6 \\, \\text{m}\\) : Radius of Earth. \\(\\text{altitude} = 400 \\times 10^3 \\, \\text{m}\\) : Initial altitude above Earth\u2019s surface (400 km). \\(r_0 = [R_{\\text{Earth}} + \\text{altitude}, 0] = [6.771 \\times 10^6, 0] \\, \\text{m}\\) : Initial position (on x-axis). \\(v_0 = [0, 7500] \\, \\text{m/s}\\) : Initial velocity (tangential, along y-axis). \\(dt = 1.0 \\, \\text{s}\\) : Time step for simulation. \\(t_{\\text{max}} = 6000 \\, \\text{s}\\) : Total simulation time. \\(\\text{steps} = 6000\\) : Number of time steps. Simulation Method The script uses Euler\u2019s method to numerically solve the equations of motion under gravitational force: \\[ F = -\\frac{G M m}{r^3} r \\quad \\Rightarrow \\quad a = -\\frac{G M}{r^3} r \\] \\[ \\frac{dr}{dt} = v, \\quad \\frac{dv}{dt} = a \\] Acceleration : Computes \\(a = -\\frac{G M}{r^3} r\\) , where \\(r\\) is the position vector and \\(r = \\|r\\|\\) . Update : Updates velocity ( \\(v \\gets v + a \\cdot dt\\) ) and position ( \\(r \\gets r + v \\cdot dt\\) ). Tracks the trajectory over 6000 steps (6000 seconds, or 100 minutes). Physical Calculations Initial Setup : The payload starts at an altitude of 400 km (low Earth orbit range), with a tangential velocity of 7500 m/s, which is close to the orbital velocity for this altitude. The orbital velocity for a circular orbit at radius \\(r\\) is: $$ v_{\\text{orbital}} = \\sqrt{\\frac{G M}{r}} $$ Substituting \\(r = 6.771 \\times 10^6 \\, \\text{m}\\) : $$ v_{\\text{orbital}} \\approx \\sqrt{\\frac{(6.67430 \\times 10^{-11}) (5.972 \\times 10^{24})}{6.771 \\times 10^6}} \\approx 7670 \\, \\text{m/s} $$ Since \\(v_0 = 7500 \\, \\text{m/s}\\) is slightly less than \\(v_{\\text{orbital}}\\) , the orbit is likely elliptical with a perigee near the starting altitude. Escape Velocity : The escape velocity at this radius is: $$ v_{\\text{escape}} = \\sqrt{\\frac{2 G M}{r}} \\approx \\sqrt{2} \\cdot v_{\\text{orbital}} \\approx 10850 \\, \\text{m/s} $$ Since \\(v_0 < v_{\\text{escape}}\\) , the payload remains bound to Earth (no escape). Total Mechanical Energy : $$ E = \\frac{1}{2} m v^2 - \\frac{G M m}{r} $$ With \\(v_0 = 7500 \\, \\text{m/s}\\) and \\(r = 6.771 \\times 10^6 \\, \\text{m}\\) , \\(E < 0\\) , confirming a bound (elliptical) orbit. Plot Trajectory : Displays the payload\u2019s path in the x-y plane, showing a nearly circular orbit around Earth. The trajectory curves around the origin, consistent with \\(v_0\\) being close to the circular orbital velocity. Earth : Represented as a blue circle with radius \\(R_{\\text{Earth}} = 6.371 \\times 10^6 \\, \\text{m}\\) , centered at the origin. Axes and Labels : x and y axes in meters, with a title \"Payload Trajectory (Numerical Simulation)\" and a legend identifying the payload path and Earth. Equal Axes : Ensures the orbit appears circular (as expected for a near-circular orbit). Grid : Added for better visualization of distances. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 M = 5.972e24 R_earth = 6.371e6 def simulate_angle_effects(speed=7500, alt_km=300): angles = [0, 15, 30, 45, 60, 75] r0_mag = R_earth + alt_km * 1e3 dt = 1 steps = 5000 plt.figure(figsize=(8, 8)) for angle_deg in angles: angle_rad = np.radians(angle_deg) vx = speed * np.cos(angle_rad) vy = speed * np.sin(angle_rad) r = np.array([r0_mag, 0.0]) v = np.array([0.0, vy]) + np.array([vx, 0.0]) path = [] for _ in range(steps): r_mag = np.linalg.norm(r) if r_mag < R_earth: break a = -G * M * r / r_mag**3 v += a * dt r += v * dt path.append(r.copy()) path = np.array(path) plt.plot(path[:, 0], path[:, 1], label=f\"{angle_deg}\u00b0\") # Earth earth = plt.Circle((0, 0), R_earth, color='blue', alpha=0.3) plt.gca().add_patch(earth) plt.title(\"Trajectories at Different Launch Angles\") plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.axis('equal') plt.grid(True) plt.legend(title=\"Launch Angle\") plt.show() simulate_angle_effects() Explanation: Payload Trajectory Simulation at Different Launch Angles This Python script simulates and visualizes the trajectories of a payload released near Earth at various launch angles, using numerical integration to solve Newton\u2019s equations of motion under gravitational force. The simulation explores how the launch angle affects the payload\u2019s path. Simulation Method The script uses Euler\u2019s method to numerically solve the equations of motion under gravitational force for each launch angle: \\[ F = -\\frac{G M m}{r^3} r \\quad \\Rightarrow \\quad a = -\\frac{G M}{r^3} r \\] \\[ \\frac{dr}{dt} = v, \\quad \\frac{dv}{dt} = a \\] Initial Velocity : For each angle \\(\\theta\\) (in radians), the initial velocity components are: \\(v_x = \\text{speed} \\cdot \\cos(\\theta)\\) (radial component), \\(v_y = \\text{speed} \\cdot \\sin(\\theta)\\) (tangential component). At \\(\\theta = 0^\\circ\\) , \\(v = [0, 7500]\\) (purely tangential); at \\(\\theta = 90^\\circ\\) , \\(v = [7500, 0]\\) (purely radial). Acceleration : Computes \\(a = -\\frac{G M}{r^3} r\\) , where \\(r\\) is the position vector and \\(r = \\|r\\|\\) . Update : Updates velocity ( \\(v \\gets v + a \\cdot dt\\) ) and position ( \\(r \\gets r + v \\cdot dt\\) ). Stopping Condition : Stops if the payload hits Earth ( \\(r < R_{\\text{Earth}}\\) ). Simulates each trajectory for up to 5000 steps. Physical Analysis Orbital Velocity : The velocity for a circular orbit at radius \\(r = 6.671 \\times 10^6 \\, \\text{m}\\) is: $$ v_{\\text{orbital}} = \\sqrt{\\frac{G M}{r}} \\approx \\sqrt{\\frac{(6.67430 \\times 10^{-11}) (5.972 \\times 10^{24})}{6.671 \\times 10^6}} \\approx 7728 \\, \\text{m/s} $$ Escape Velocity : The escape velocity at this radius is: $$ v_{\\text{escape}} = \\sqrt{\\frac{2 G M}{r}} \\approx \\sqrt{2} \\cdot v_{\\text{orbital}} \\approx 10930 \\, \\text{m/s} $$ Effect of Launch Angle : The initial speed is \\(7500 \\, \\text{m/s}\\) , which is less than \\(v_{\\text{orbital}}\\) (7728 m/s), suggesting elliptical orbits or reentry unless the angle provides sufficient tangential velocity. At \\(\\theta = 0^\\circ\\) , the velocity is purely tangential ( \\(v = [0, 7500]\\) ), close to orbital velocity, leading to a near-circular or slightly elliptical orbit. As \\(\\theta\\) increases, the tangential component decreases ( \\(v_y = 7500 \\cdot \\sin(\\theta)\\) ), and the radial component increases ( \\(v_x = 7500 \\cdot \\cos(\\theta)\\) ), reducing the angular momentum and causing the perigee to drop. For higher angles (e.g., 60\u00b0, 75\u00b0), the payload lacks sufficient tangential velocity to maintain orbit, leading to reentry (perigee below Earth\u2019s surface). Total Mechanical Energy : Energy \\(E = \\frac{1}{2} m v^2 - \\frac{G M m}{r}\\) is negative for \\(v = 7500 \\, \\text{m/s} < v_{\\text{escape}}\\) , indicating bound trajectories (elliptical or reentry). Angular momentum varies with \\(\\theta\\) , affecting eccentricity and perigee. Plot Trajectories : Displays the payload\u2019s path for each launch angle in the x-y plane. At \\(\\theta = 0^\\circ\\) , the trajectory is a near-circular orbit (blue line), as the tangential velocity is close to \\(v_{\\text{orbital}}\\) . As \\(\\theta\\) increases (15\u00b0 to 75\u00b0), the orbits become more elliptical with lower perigees, eventually intersecting Earth\u2019s surface (reentry) for larger angles (e.g., 60\u00b0, 75\u00b0). Earth : Represented as a blue circle with radius \\(R_{\\text{Earth}} = 6.371 \\times 10^6 \\, \\text{m}\\) , centered at the origin. Axes and Labels : x and y axes in meters, with a title \"Trajectories at Different Launch Angles\" and a legend identifying each angle. Equal Axes : Ensures orbits appear with correct geometry (e.g., circular for \\(\\theta = 0^\\circ\\) ). Grid : Added for better visualization of distances. def energy_plot(speed=7600, alt_km=400, angle_deg=0): r0 = R_earth + alt_km * 1e3 angle = np.radians(angle_deg) v = np.array([speed * np.cos(angle), speed * np.sin(angle)]) r = np.array([r0, 0.0]) dt = 1 steps = 8000 energy = [] for _ in range(steps): r_mag = np.linalg.norm(r) if r_mag < R_earth: break kinetic = 0.5 * np.linalg.norm(v)**2 potential = -G * M / r_mag total = kinetic + potential energy.append(total) a = -G * M * r / r_mag**3 v += a * dt r += v * dt plt.figure(figsize=(7, 4)) plt.plot(energy) plt.title(\"Total Mechanical Energy Over Time\") plt.xlabel(\"Time step\") plt.ylabel(\"Energy (J/kg)\") plt.grid(True) plt.axhline(0, color='red', linestyle='--', label=\"Escape Threshold\") plt.legend() plt.show() energy_plot() Explanation: Total Mechanical Energy Simulation This Python script simulates and visualizes the total mechanical energy of a payload released near Earth over time, using numerical integration to solve Newton\u2019s equations of motion under gravitational force. The simulation helps determine whether the payload remains bound to Earth or can escape. Simulation Method The script uses Euler\u2019s method to numerically solve the equations of motion under gravitational force and computes the total mechanical energy at each step: \\[ F = -\\frac{G M m}{r^3} r \\quad \\Rightarrow \\quad a = -\\frac{G M}{r^3} r \\] \\[ \\frac{dr}{dt} = v, \\quad \\frac{dv}{dt} = a \\] Acceleration : Computes \\(a = -\\frac{G M}{r^3} r\\) , where \\(r\\) is the position vector and \\(r = \\|r\\|\\) . Update : Updates velocity ( \\(v \\gets v + a \\cdot dt\\) ) and position ( \\(r \\gets r + v \\cdot dt\\) ). Energy Calculation : Kinetic energy per unit mass: \\(K = \\frac{1}{2} \\|v\\|^2\\) , Potential energy per unit mass: \\(U = -\\frac{G M}{r}\\) , Total mechanical energy per unit mass: \\(E = K + U\\) . Stopping Condition : Stops if the payload hits Earth ( \\(r < R_{\\text{Earth}}\\) ). Tracks energy over 8000 steps. Physical Analysis Initial Energy : Kinetic energy: \\(K = \\frac{1}{2} (7600)^2 = 2.888 \\times 10^7 \\, \\text{J/kg}\\) , Potential energy: \\(U = -\\frac{G M}{r} = -\\frac{(6.67430 \\times 10^{-11}) (5.972 \\times 10^{24})}{6.771 \\times 10^6} \\approx -5.885 \\times 10^7 \\, \\text{J/kg}\\) , Total energy: \\(E = K + U \\approx 2.888 \\times 10^7 - 5.885 \\times 10^7 = -2.997 \\times 10^7 \\, \\text{J/kg}\\) . Escape Threshold : Escape occurs when \\(E \\geq 0\\) . The plot shows \\(E \\approx -3 \\times 10^7 \\, \\text{J/kg}\\) , which is negative, indicating a bound orbit (elliptical or circular). The escape velocity at \\(r = 6.771 \\times 10^6 \\, \\text{m}\\) is: \\[ v_{\\text{escape}} = \\sqrt{\\frac{2 G M}{r}} \\approx \\sqrt{\\frac{2 (6.67430 \\times 10^{-11}) (5.972 \\times 10^{24})}{6.771 \\times 10^6}} \\approx 10850 \\, \\text{m/s} \\] Since \\(v = 7600 \\, \\text{m/s} < v_{\\text{escape}}\\) , the payload remains bound, consistent with \\(E < 0\\) . Orbital Velocity : Circular orbital velocity at this radius: \\(v_{\\text{orbital}} = \\sqrt{\\frac{G M}{r}} \\approx 7670 \\, \\text{m/s}\\) . With \\(v = 7600 \\, \\text{m/s}\\) , the orbit is slightly elliptical (close to circular), as \\(v\\) is just below \\(v_{\\text{orbital}}\\) . Energy Conservation : The plot shows energy is roughly constant at \\(\\approx -3 \\times 10^7 \\, \\text{J/kg}\\) , as expected in a conservative system (no drag or other forces). Slight variations may be due to numerical errors from Euler\u2019s method. Plot Energy Over Time : Displays the total mechanical energy per unit mass ( \\(E\\) ) over 8000 time steps. The energy remains constant at approximately \\(-3 \\times 10^7 \\, \\text{J/kg}\\) , confirming conservation and a bound orbit. Escape Threshold : A red dashed line at \\(E = 0\\) marks the escape threshold. Since \\(E < 0\\) , the payload does not escape Earth\u2019s gravity. Axes and Labels : x-axis: Time step (each step = 1 second, so 8000 steps = 8000 seconds \u2248 133 minutes). y-axis: Energy in \\(\\text{J/kg}\\) . Title: \"Total Mechanical Energy Over Time\". Grid and Legend : Includes a grid for readability and a legend identifying the escape threshold line.","title":"1. Analyze the Possible Trajectories of a Payload Released Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-analyze-the-possible-trajectories-of-a-payload-released-near-earth","text":"","title":"1. Analyze the Possible Trajectories of a Payload Released Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#objective","text":"When a payload is released from a spacecraft near Earth, its subsequent trajectory depends on its initial velocity and position relative to Earth. The shape of the path\u2014elliptical, parabolic, or hyperbolic\u2014is governed by Newton\u2019s Law of Gravitation and the conservation of mechanical energy. Understanding these paths is fundamental in planning: - Satellite orbits, - Escape missions, - Reentry maneuvers, - Interplanetary probes.","title":"Objective"},{"location":"1%20Physics/2%20Gravity/Problem_3/#governing-force-newtons-law-of-universal-gravitation","text":"The force acting on the payload due to Earth\u2019s gravity is: \\[ F = -\\frac{G M m}{r^2} \\hat{r} \\] Where: - \\(G\\) : Gravitational constant ( \\(6.674 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2\\) ), - \\(M\\) : Mass of Earth, - \\(m\\) : Mass of the payload, - \\(r\\) : Distance from Earth\u2019s center, - \\(\\hat{r}\\) : Unit vector from Earth to the payload.","title":"Governing Force \u2013 Newton\u2019s Law of Universal Gravitation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#total-mechanical-energy","text":"The motion is governed by conservation of total mechanical energy: \\[ E = \\frac{1}{2} m v^2 - \\frac{G M m}{r} \\] This determines the trajectory type: Energy Condition Trajectory Type Description \\(E < 0\\) Elliptical Closed orbit; bound to Earth \\(E = 0\\) Parabolic Just enough speed to escape; marginal escape \\(E > 0\\) Hyperbolic Unbound; excess speed leads to escape","title":"Total Mechanical Energy"},{"location":"1%20Physics/2%20Gravity/Problem_3/#escape-velocity","text":"The minimum speed required to escape Earth\u2019s gravitational pull is: \\[ v_{\\text{escape}} = \\sqrt{\\frac{2 G M}{r}} \\] If the payload\u2019s speed \\(v = v_{\\text{escape}}\\) \u2192 parabolic trajectory. If \\(v < v_{\\text{escape}}\\) \u2192 elliptical (or circular) trajectory. If \\(v > v_{\\text{escape}}\\) \u2192 hyperbolic trajectory.","title":"Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_3/#shape-of-the-orbit-conic-sections","text":"The orbit a payload follows is a conic section with Earth at one focus. Its shape depends on the specific mechanical energy and eccentricity \\(e\\) : Eccentricity \\(e\\) Orbit Type \\(e = 0\\) Circular \\(0 < e < 1\\) Elliptical \\(e = 1\\) Parabolic \\(e > 1\\) Hyperbolic Eccentricity can be derived using energy and angular momentum, but for initial velocity analysis, energy alone is sufficient to determine the type.","title":"Shape of the Orbit: Conic Sections"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-numerical-analysis-of-payload-trajectory-based-on-initial-conditions","text":"","title":"2. Numerical Analysis of Payload Trajectory Based on Initial Conditions"},{"location":"1%20Physics/2%20Gravity/Problem_3/#objective_1","text":"Given the initial position, velocity, and altitude of a payload released near Earth, compute its path using numerical methods that solve Newton\u2019s equations of motion under gravity. This analysis helps determine whether the payload: - Falls back to Earth (reentry), - Enters orbit, - Escapes Earth\u2019s gravity.","title":"Objective"},{"location":"1%20Physics/2%20Gravity/Problem_3/#physical-model","text":"We use Newton\u2019s second law and universal gravitation: \\[ F = m a = -\\frac{G M m}{r^3} r \\Rightarrow a = -\\frac{G M}{r^3} r \\] Where: - \\(r\\) : Position vector from Earth\u2019s center, - \\(a\\) : Acceleration, - \\(r = \\|r\\|\\) : Magnitude of the position vector.","title":"Physical Model"},{"location":"1%20Physics/2%20Gravity/Problem_3/#numerical-integration-euler-or-runge-kutta","text":"We use a numerical integration scheme (Euler or RK4) to compute \\(r(t)\\) and \\(v(t)\\) over time: \\[ \\frac{dr}{dt} = v, \\quad \\frac{dv}{dt} = -\\frac{G M}{r^3} r \\]","title":"Numerical Integration: Euler or Runge-Kutta"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-how-trajectories-relate-to-orbital-insertion-reentry-and-escape","text":"","title":"3. How Trajectories Relate to Orbital Insertion, Reentry, and Escape"},{"location":"1%20Physics/2%20Gravity/Problem_3/#objective_2","text":"Interpret the numerical results from Task 2 by linking trajectory types to actual space mission outcomes: - Stable orbit (insertion), - Reentry (falling back to Earth), - Escape (leaving Earth\u2019s gravity).","title":"Objective"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-orbital-insertion-stable-orbit","text":"Scenario : The payload achieves a stable elliptical or circular orbit around Earth. Conditions : - Total mechanical energy \\(E < 0\\) . - Velocity \\(v < v_{\\text{escape}}\\) , but high enough to avoid crashing. - Perigee (lowest point) stays above Earth\u2019s surface. Result in Simulation : - The trajectory curves around Earth and doesn\u2019t intersect with the planet. - Path may be circular (if speed is just right) or elliptical (most common). Real-world Examples : - Satellites (e.g., Starlink), - International Space Station (ISS), - Lunar parking orbits before transfer burns.","title":"1. Orbital Insertion (Stable Orbit)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-reentry-atmospheric-fall-or-crash","text":"Scenario : The payload\u2019s speed is too low to sustain an orbit, causing it to fall back. Conditions : - \\(v < v_{\\text{orbital}}\\) , - Still \\(E < 0\\) , but perigee drops below Earth\u2019s surface, - Or starts with a downward velocity component. Result in Simulation : - The trajectory spirals or curves downward and eventually hits the Earth (passes inside Earth\u2019s radius). Real-world Examples : - Returning space capsules (e.g., SpaceX Dragon), - Space debris reentry, - Rocket stage disposal.","title":"2. Reentry (Atmospheric Fall or Crash)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-escape-trajectory-leaving-earths-gravity","text":"Scenario : Payload reaches or exceeds escape velocity and is no longer gravitationally bound to Earth. Conditions : - \\(v \\geq v_{\\text{escape}}\\) , - \\(E \\geq 0\\) (total mechanical energy \\(\\geq 0\\) ). Result in Simulation : - The trajectory becomes hyperbolic. - Payload moves away from Earth and never returns. Real-world Examples : - Interplanetary probes (e.g., Voyager, Mars rovers), - Asteroid missions (e.g., OSIRIS-REx), - Escape burns after low Earth orbit (LEO).","title":"3. Escape Trajectory (Leaving Earth\u2019s Gravity)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#4-simulation","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3/kg/s^2 M = 5.972e24 # kg (mass of Earth) R_earth = 6.371e6 # m (radius of Earth) # Initial conditions altitude = 400e3 # 400 km above Earth r0 = np.array([R_earth + altitude, 0]) # Start on x-axis v0 = np.array([0, 7500], dtype=float) # Tangential velocity (m/s), changed to float # initialize to float array # Time setup dt = 1.0 # seconds, changed to float t_max = 6000 # total simulation time in seconds steps = int(t_max / dt) # Initialize position, velocity r = r0.copy() v = v0.copy() # Storage for path trajectory = [r.copy()] # Euler integration for _ in range(steps): r_mag = np.linalg.norm(r) a = -G * M * r / r_mag**3 v += a * dt r += v * dt trajectory.append(r.copy()) trajectory = np.array(trajectory) # Plot plt.figure(figsize=(7, 7)) plt.plot(trajectory[:, 0], trajectory[:, 1], label='Payload Path') plt.gca().add_patch(plt.Circle((0, 0), R_earth, color='blue', alpha=0.3, label='Earth')) plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Payload Trajectory (Numerical Simulation)') plt.axis('equal') plt.grid(True) plt.legend() plt.show()","title":"4. Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#explanation-payload-trajectory-simulation","text":"This Python script simulates and visualizes the trajectory of a payload released near Earth, using numerical integration to solve Newton\u2019s equations of motion under gravitational force. The simulation determines the payload\u2019s path based on its initial conditions.","title":"Explanation: Payload Trajectory Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#parameters","text":"\\(G = 6.67430 \\times 10^{-11} \\, \\text{m}^3/\\text{kg}/\\text{s}^2\\) : Gravitational constant. \\(M = 5.972 \\times 10^{24} \\, \\text{kg}\\) : Mass of Earth. \\(R_{\\text{Earth}} = 6.371 \\times 10^6 \\, \\text{m}\\) : Radius of Earth. \\(\\text{altitude} = 400 \\times 10^3 \\, \\text{m}\\) : Initial altitude above Earth\u2019s surface (400 km). \\(r_0 = [R_{\\text{Earth}} + \\text{altitude}, 0] = [6.771 \\times 10^6, 0] \\, \\text{m}\\) : Initial position (on x-axis). \\(v_0 = [0, 7500] \\, \\text{m/s}\\) : Initial velocity (tangential, along y-axis). \\(dt = 1.0 \\, \\text{s}\\) : Time step for simulation. \\(t_{\\text{max}} = 6000 \\, \\text{s}\\) : Total simulation time. \\(\\text{steps} = 6000\\) : Number of time steps.","title":"Parameters"},{"location":"1%20Physics/2%20Gravity/Problem_3/#simulation-method","text":"The script uses Euler\u2019s method to numerically solve the equations of motion under gravitational force: \\[ F = -\\frac{G M m}{r^3} r \\quad \\Rightarrow \\quad a = -\\frac{G M}{r^3} r \\] \\[ \\frac{dr}{dt} = v, \\quad \\frac{dv}{dt} = a \\] Acceleration : Computes \\(a = -\\frac{G M}{r^3} r\\) , where \\(r\\) is the position vector and \\(r = \\|r\\|\\) . Update : Updates velocity ( \\(v \\gets v + a \\cdot dt\\) ) and position ( \\(r \\gets r + v \\cdot dt\\) ). Tracks the trajectory over 6000 steps (6000 seconds, or 100 minutes).","title":"Simulation Method"},{"location":"1%20Physics/2%20Gravity/Problem_3/#physical-calculations","text":"Initial Setup : The payload starts at an altitude of 400 km (low Earth orbit range), with a tangential velocity of 7500 m/s, which is close to the orbital velocity for this altitude. The orbital velocity for a circular orbit at radius \\(r\\) is: $$ v_{\\text{orbital}} = \\sqrt{\\frac{G M}{r}} $$ Substituting \\(r = 6.771 \\times 10^6 \\, \\text{m}\\) : $$ v_{\\text{orbital}} \\approx \\sqrt{\\frac{(6.67430 \\times 10^{-11}) (5.972 \\times 10^{24})}{6.771 \\times 10^6}} \\approx 7670 \\, \\text{m/s} $$ Since \\(v_0 = 7500 \\, \\text{m/s}\\) is slightly less than \\(v_{\\text{orbital}}\\) , the orbit is likely elliptical with a perigee near the starting altitude. Escape Velocity : The escape velocity at this radius is: $$ v_{\\text{escape}} = \\sqrt{\\frac{2 G M}{r}} \\approx \\sqrt{2} \\cdot v_{\\text{orbital}} \\approx 10850 \\, \\text{m/s} $$ Since \\(v_0 < v_{\\text{escape}}\\) , the payload remains bound to Earth (no escape). Total Mechanical Energy : $$ E = \\frac{1}{2} m v^2 - \\frac{G M m}{r} $$ With \\(v_0 = 7500 \\, \\text{m/s}\\) and \\(r = 6.771 \\times 10^6 \\, \\text{m}\\) , \\(E < 0\\) , confirming a bound (elliptical) orbit.","title":"Physical Calculations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#plot","text":"Trajectory : Displays the payload\u2019s path in the x-y plane, showing a nearly circular orbit around Earth. The trajectory curves around the origin, consistent with \\(v_0\\) being close to the circular orbital velocity. Earth : Represented as a blue circle with radius \\(R_{\\text{Earth}} = 6.371 \\times 10^6 \\, \\text{m}\\) , centered at the origin. Axes and Labels : x and y axes in meters, with a title \"Payload Trajectory (Numerical Simulation)\" and a legend identifying the payload path and Earth. Equal Axes : Ensures the orbit appears circular (as expected for a near-circular orbit). Grid : Added for better visualization of distances. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 M = 5.972e24 R_earth = 6.371e6 def simulate_angle_effects(speed=7500, alt_km=300): angles = [0, 15, 30, 45, 60, 75] r0_mag = R_earth + alt_km * 1e3 dt = 1 steps = 5000 plt.figure(figsize=(8, 8)) for angle_deg in angles: angle_rad = np.radians(angle_deg) vx = speed * np.cos(angle_rad) vy = speed * np.sin(angle_rad) r = np.array([r0_mag, 0.0]) v = np.array([0.0, vy]) + np.array([vx, 0.0]) path = [] for _ in range(steps): r_mag = np.linalg.norm(r) if r_mag < R_earth: break a = -G * M * r / r_mag**3 v += a * dt r += v * dt path.append(r.copy()) path = np.array(path) plt.plot(path[:, 0], path[:, 1], label=f\"{angle_deg}\u00b0\") # Earth earth = plt.Circle((0, 0), R_earth, color='blue', alpha=0.3) plt.gca().add_patch(earth) plt.title(\"Trajectories at Different Launch Angles\") plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.axis('equal') plt.grid(True) plt.legend(title=\"Launch Angle\") plt.show() simulate_angle_effects()","title":"Plot"},{"location":"1%20Physics/2%20Gravity/Problem_3/#explanation-payload-trajectory-simulation-at-different-launch-angles","text":"This Python script simulates and visualizes the trajectories of a payload released near Earth at various launch angles, using numerical integration to solve Newton\u2019s equations of motion under gravitational force. The simulation explores how the launch angle affects the payload\u2019s path.","title":"Explanation: Payload Trajectory Simulation at Different Launch Angles"},{"location":"1%20Physics/2%20Gravity/Problem_3/#simulation-method_1","text":"The script uses Euler\u2019s method to numerically solve the equations of motion under gravitational force for each launch angle: \\[ F = -\\frac{G M m}{r^3} r \\quad \\Rightarrow \\quad a = -\\frac{G M}{r^3} r \\] \\[ \\frac{dr}{dt} = v, \\quad \\frac{dv}{dt} = a \\] Initial Velocity : For each angle \\(\\theta\\) (in radians), the initial velocity components are: \\(v_x = \\text{speed} \\cdot \\cos(\\theta)\\) (radial component), \\(v_y = \\text{speed} \\cdot \\sin(\\theta)\\) (tangential component). At \\(\\theta = 0^\\circ\\) , \\(v = [0, 7500]\\) (purely tangential); at \\(\\theta = 90^\\circ\\) , \\(v = [7500, 0]\\) (purely radial). Acceleration : Computes \\(a = -\\frac{G M}{r^3} r\\) , where \\(r\\) is the position vector and \\(r = \\|r\\|\\) . Update : Updates velocity ( \\(v \\gets v + a \\cdot dt\\) ) and position ( \\(r \\gets r + v \\cdot dt\\) ). Stopping Condition : Stops if the payload hits Earth ( \\(r < R_{\\text{Earth}}\\) ). Simulates each trajectory for up to 5000 steps.","title":"Simulation Method"},{"location":"1%20Physics/2%20Gravity/Problem_3/#physical-analysis","text":"Orbital Velocity : The velocity for a circular orbit at radius \\(r = 6.671 \\times 10^6 \\, \\text{m}\\) is: $$ v_{\\text{orbital}} = \\sqrt{\\frac{G M}{r}} \\approx \\sqrt{\\frac{(6.67430 \\times 10^{-11}) (5.972 \\times 10^{24})}{6.671 \\times 10^6}} \\approx 7728 \\, \\text{m/s} $$ Escape Velocity : The escape velocity at this radius is: $$ v_{\\text{escape}} = \\sqrt{\\frac{2 G M}{r}} \\approx \\sqrt{2} \\cdot v_{\\text{orbital}} \\approx 10930 \\, \\text{m/s} $$ Effect of Launch Angle : The initial speed is \\(7500 \\, \\text{m/s}\\) , which is less than \\(v_{\\text{orbital}}\\) (7728 m/s), suggesting elliptical orbits or reentry unless the angle provides sufficient tangential velocity. At \\(\\theta = 0^\\circ\\) , the velocity is purely tangential ( \\(v = [0, 7500]\\) ), close to orbital velocity, leading to a near-circular or slightly elliptical orbit. As \\(\\theta\\) increases, the tangential component decreases ( \\(v_y = 7500 \\cdot \\sin(\\theta)\\) ), and the radial component increases ( \\(v_x = 7500 \\cdot \\cos(\\theta)\\) ), reducing the angular momentum and causing the perigee to drop. For higher angles (e.g., 60\u00b0, 75\u00b0), the payload lacks sufficient tangential velocity to maintain orbit, leading to reentry (perigee below Earth\u2019s surface). Total Mechanical Energy : Energy \\(E = \\frac{1}{2} m v^2 - \\frac{G M m}{r}\\) is negative for \\(v = 7500 \\, \\text{m/s} < v_{\\text{escape}}\\) , indicating bound trajectories (elliptical or reentry). Angular momentum varies with \\(\\theta\\) , affecting eccentricity and perigee.","title":"Physical Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_3/#plot_1","text":"Trajectories : Displays the payload\u2019s path for each launch angle in the x-y plane. At \\(\\theta = 0^\\circ\\) , the trajectory is a near-circular orbit (blue line), as the tangential velocity is close to \\(v_{\\text{orbital}}\\) . As \\(\\theta\\) increases (15\u00b0 to 75\u00b0), the orbits become more elliptical with lower perigees, eventually intersecting Earth\u2019s surface (reentry) for larger angles (e.g., 60\u00b0, 75\u00b0). Earth : Represented as a blue circle with radius \\(R_{\\text{Earth}} = 6.371 \\times 10^6 \\, \\text{m}\\) , centered at the origin. Axes and Labels : x and y axes in meters, with a title \"Trajectories at Different Launch Angles\" and a legend identifying each angle. Equal Axes : Ensures orbits appear with correct geometry (e.g., circular for \\(\\theta = 0^\\circ\\) ). Grid : Added for better visualization of distances. def energy_plot(speed=7600, alt_km=400, angle_deg=0): r0 = R_earth + alt_km * 1e3 angle = np.radians(angle_deg) v = np.array([speed * np.cos(angle), speed * np.sin(angle)]) r = np.array([r0, 0.0]) dt = 1 steps = 8000 energy = [] for _ in range(steps): r_mag = np.linalg.norm(r) if r_mag < R_earth: break kinetic = 0.5 * np.linalg.norm(v)**2 potential = -G * M / r_mag total = kinetic + potential energy.append(total) a = -G * M * r / r_mag**3 v += a * dt r += v * dt plt.figure(figsize=(7, 4)) plt.plot(energy) plt.title(\"Total Mechanical Energy Over Time\") plt.xlabel(\"Time step\") plt.ylabel(\"Energy (J/kg)\") plt.grid(True) plt.axhline(0, color='red', linestyle='--', label=\"Escape Threshold\") plt.legend() plt.show() energy_plot()","title":"Plot"},{"location":"1%20Physics/2%20Gravity/Problem_3/#explanation-total-mechanical-energy-simulation","text":"This Python script simulates and visualizes the total mechanical energy of a payload released near Earth over time, using numerical integration to solve Newton\u2019s equations of motion under gravitational force. The simulation helps determine whether the payload remains bound to Earth or can escape.","title":"Explanation: Total Mechanical Energy Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#simulation-method_2","text":"The script uses Euler\u2019s method to numerically solve the equations of motion under gravitational force and computes the total mechanical energy at each step: \\[ F = -\\frac{G M m}{r^3} r \\quad \\Rightarrow \\quad a = -\\frac{G M}{r^3} r \\] \\[ \\frac{dr}{dt} = v, \\quad \\frac{dv}{dt} = a \\] Acceleration : Computes \\(a = -\\frac{G M}{r^3} r\\) , where \\(r\\) is the position vector and \\(r = \\|r\\|\\) . Update : Updates velocity ( \\(v \\gets v + a \\cdot dt\\) ) and position ( \\(r \\gets r + v \\cdot dt\\) ). Energy Calculation : Kinetic energy per unit mass: \\(K = \\frac{1}{2} \\|v\\|^2\\) , Potential energy per unit mass: \\(U = -\\frac{G M}{r}\\) , Total mechanical energy per unit mass: \\(E = K + U\\) . Stopping Condition : Stops if the payload hits Earth ( \\(r < R_{\\text{Earth}}\\) ). Tracks energy over 8000 steps.","title":"Simulation Method"},{"location":"1%20Physics/2%20Gravity/Problem_3/#physical-analysis_1","text":"Initial Energy : Kinetic energy: \\(K = \\frac{1}{2} (7600)^2 = 2.888 \\times 10^7 \\, \\text{J/kg}\\) , Potential energy: \\(U = -\\frac{G M}{r} = -\\frac{(6.67430 \\times 10^{-11}) (5.972 \\times 10^{24})}{6.771 \\times 10^6} \\approx -5.885 \\times 10^7 \\, \\text{J/kg}\\) , Total energy: \\(E = K + U \\approx 2.888 \\times 10^7 - 5.885 \\times 10^7 = -2.997 \\times 10^7 \\, \\text{J/kg}\\) . Escape Threshold : Escape occurs when \\(E \\geq 0\\) . The plot shows \\(E \\approx -3 \\times 10^7 \\, \\text{J/kg}\\) , which is negative, indicating a bound orbit (elliptical or circular). The escape velocity at \\(r = 6.771 \\times 10^6 \\, \\text{m}\\) is: \\[ v_{\\text{escape}} = \\sqrt{\\frac{2 G M}{r}} \\approx \\sqrt{\\frac{2 (6.67430 \\times 10^{-11}) (5.972 \\times 10^{24})}{6.771 \\times 10^6}} \\approx 10850 \\, \\text{m/s} \\] Since \\(v = 7600 \\, \\text{m/s} < v_{\\text{escape}}\\) , the payload remains bound, consistent with \\(E < 0\\) . Orbital Velocity : Circular orbital velocity at this radius: \\(v_{\\text{orbital}} = \\sqrt{\\frac{G M}{r}} \\approx 7670 \\, \\text{m/s}\\) . With \\(v = 7600 \\, \\text{m/s}\\) , the orbit is slightly elliptical (close to circular), as \\(v\\) is just below \\(v_{\\text{orbital}}\\) . Energy Conservation : The plot shows energy is roughly constant at \\(\\approx -3 \\times 10^7 \\, \\text{J/kg}\\) , as expected in a conservative system (no drag or other forces). Slight variations may be due to numerical errors from Euler\u2019s method.","title":"Physical Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_3/#plot_2","text":"Energy Over Time : Displays the total mechanical energy per unit mass ( \\(E\\) ) over 8000 time steps. The energy remains constant at approximately \\(-3 \\times 10^7 \\, \\text{J/kg}\\) , confirming conservation and a bound orbit. Escape Threshold : A red dashed line at \\(E = 0\\) marks the escape threshold. Since \\(E < 0\\) , the payload does not escape Earth\u2019s gravity. Axes and Labels : x-axis: Time step (each step = 1 second, so 8000 steps = 8000 seconds \u2248 133 minutes). y-axis: Energy in \\(\\text{J/kg}\\) . Title: \"Total Mechanical Energy Over Time\". Grid and Legend : Includes a grid for readability and a legend identifying the escape threshold line.","title":"Plot"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Wave Interference from Polygonal Sources Problem Statement The task is to analyze the interference patterns that form on the surface of water when multiple circular waves, each originating from a point source, superimpose. These sources are positioned at the vertices of a chosen regular polygon. The goal is to use both wave physics and numerical simulation to understand how coherent waves interact, producing patterns of constructive and destructive interference. Motivation Wave interference is a fundamental concept in physics, where overlapping waves can amplify (constructive) or cancel (destructive) each other. On water, this can be observed beautifully with ripples meeting from multiple sources. This task leverages simple visual physics to explore: - How coherent wave sources interfere. - The influence of geometry on interference patterns. - Superposition of circular waveforms. By using polygonal source arrangements and a hands-on simulation, this becomes an intuitive way to understand wave mechanics and symmetry. Mathematical Model of a Single Wave The wave emitted from a single point source at position \\((x_0, y_0)\\) is modeled as: \\[ \\eta(x, y, t) = \\frac{A}{r} \\cdot \\cos(kr - \\omega t + \\phi) \\] Variables : - \\(\\eta(x, y, t)\\) : Displacement of the water surface at position \\((x, y)\\) and time \\(t\\) . - \\(A\\) : Amplitude of the wave. - \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) : Distance from source to point. - \\(k = \\frac{2\\pi}{\\lambda}\\) : Wave number, with \\(\\lambda\\) as the wavelength. - \\(\\omega = 2\\pi f\\) : Angular frequency, with \\(f\\) as the wave frequency. - \\(\\phi\\) : Initial phase of the wave. Geometry: Polygon Wave Source Arrangement Choose a regular polygon (e.g., triangle, square, pentagon). Place one point wave source at each vertex. All sources emit identical, coherent waves with: Same amplitude \\(A\\) , wavelength \\(\\lambda\\) , and frequency \\(f\\) . Same or constant phase differences. Let the number of sides (and thus number of sources) be: \\(N = \\text{Number of vertices}\\) To calculate their positions, evenly distribute them around a circle: \\[ (x_i, y_i) = \\left( R \\cos(\\theta_i), R \\sin(\\theta_i) \\right), \\quad \\theta_i = \\frac{2\\pi i}{N} \\] Superposition of Waves To calculate the total wave displacement at a point \\((x, y)\\) , sum the contributions from all sources: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^N \\frac{A}{r_i} \\cdot \\cos(kr_i - \\omega t + \\phi_i) \\] Where: - \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) is the distance from the \\(i\\) -th source. - \\(\\phi_i\\) : Phase of the \\(i\\) -th source (typically 0 for all). This creates complex interference patterns on the water surface, especially in symmetric arrangements like polygons. Simulation \u2013 Python Implementation 1.The following Python code simulates and visualizes the interference pattern formed at a fixed time snapshot (e.g., \\(t = 0\\) ). import numpy as np import matplotlib.pyplot as plt # Parameters A = 1.0 # Amplitude of each wave lambda_ = 0.5 # Wavelength (m) k = 2 * np.pi / lambda_ # Wave number omega = 2 * np.pi * 1.0 # Angular frequency (assuming f = 1 Hz) phi = 0.0 # Phase (same for all sources) R = 1.0 # Radius of polygon (m) N = 5 # Number of sources (e.g., pentagon) t = 0.0 # Time snapshot # Define source positions for a regular polygon theta_i = np.linspace(0, 2 * np.pi, N, endpoint=False) # Angles for N vertices x_i = R * np.cos(theta_i) # x-coordinates of sources y_i = R * np.sin(theta_i) # y-coordinates of sources # Create a grid for the simulation x = np.linspace(-3, 3, 200) # x-range (m) y = np.linspace(-3, 3, 200) # y-range (m) X, Y = np.meshgrid(x, y) # 2D grid eta_sum = np.zeros_like(X) # Initialize wave displacement # Calculate total wave displacement for i in range(N): # Distance from i-th source to each point (x, y) r_i = np.sqrt((X - x_i[i])**2 + (Y - y_i[i])**2) # Avoid division by zero near sources r_i = np.where(r_i < 1e-10, 1e-10, r_i) # Wave contribution from i-th source eta_i = (A / r_i) * np.cos(k * r_i - omega * t + phi) eta_sum += eta_i # Plot the interference pattern plt.figure(figsize=(8, 8)) plt.imshow(eta_sum, extent=[-3, 3, -3, 3], cmap='seismic', origin='lower') plt.colorbar(label='Wave Displacement $\\eta(x, y, t=0)$') plt.scatter(x_i, y_i, c='black', s=50, label='Sources') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title(f'Wave Interference Pattern (N={N} Sources, $t=0$)') plt.legend() plt.axis('equal') plt.show() Explanation Parameters \\(A = 1.0\\) : Amplitude of each wave. \\(\\lambda = 0.5 \\, \\text{m}\\) : Wavelength, giving \\(k = \\frac{2\\pi}{\\lambda}\\) . \\(\\omega = 2\\pi \\cdot 1.0\\) : Angular frequency (assuming \\(f = 1 \\, \\text{Hz}\\) ). \\(\\phi = 0.0\\) : Phase (same for all sources). \\(R = 1.0 \\, \\text{m}\\) : Radius of the polygon. \\(N = 5\\) : Number of sources (pentagon arrangement). \\(t = 0\\) : Fixed time snapshot. Source Positions Sources are placed at the vertices of a regular \\(N\\) -sided polygon: \\[ (x_i, y_i) = \\left( R \\cos\\left( \\frac{2\\pi i}{N} \\right), R \\sin\\left( \\frac{2\\pi i}{N} \\right) \\right) \\] Wave Superposition Computes the total displacement: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^N \\frac{A}{r_i} \\cdot \\cos(kr_i - \\omega t + \\phi_i) \\] where \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) . Plot Displays the interference pattern as a 2D heatmap using the seismic colormap (red for positive, blue for negative). Marks source positions as black dots. Includes a colorbar for wave displacement \\(\\eta\\) . Uses equal axes to preserve symmetry. Simulation \u2013 Python Implementation 2.This simulation ignores time and calculates the maximum possible displacement across time \u2014 a kind of \u201cheatmap\u201d showing where the strongest interference consistently occurs. import numpy as np import matplotlib.pyplot as plt # Parameters A = 1 wavelength = 1.0 k = 2 * np.pi / wavelength N = 6 # Number of sources (hexagon) R = 2.5 # Polygon radius # Grid x_vals = np.linspace(-5, 5, 400) y_vals = np.linspace(-5, 5, 400) X, Y = np.meshgrid(x_vals, y_vals) # Source positions source_positions = [ (R * np.cos(2 * np.pi * i / N), R * np.sin(2 * np.pi * i / N)) for i in range(N) ] # Sum peak values over 1 period of wave T = wavelength # Period of the wave frames = 100 t_vals = np.linspace(0, T, frames) # Superposition peak_map = np.zeros_like(X) for t in t_vals: snapshot = np.zeros_like(X) for x0, y0 in source_positions: r = np.sqrt((X - x0)**2 + (Y - y0)**2) + 1e-6 snapshot += A / np.sqrt(r) * np.cos(k * r - 2 * np.pi * t) peak_map = np.maximum(peak_map, np.abs(snapshot)) # Plot plt.figure(figsize=(8, 6)) plt.contourf(X, Y, peak_map, levels=100, cmap='plasma') plt.colorbar(label='Max Displacement |\u03b7|') plt.title('Peak Interference Zones (Constructive Regions)') plt.axis('equal') plt.xlabel('x') plt.ylabel('y') plt.show() Explanation: Wave Interference Simulation This Python script simulates and visualizes the peak interference pattern formed by multiple coherent wave sources arranged at the vertices of a regular hexagon, capturing the maximum displacement over one wave period. Parameters \\(A = 1.0\\) : Amplitude of each wave. \\(\\lambda = 1.0 \\, \\text{m}\\) : Wavelength, giving \\(k = \\frac{2\\pi}{\\lambda}\\) . \\(N = 6\\) : Number of sources (hexagon arrangement). \\(R = 2.5 \\, \\text{m}\\) : Radius of the polygon. \\(T = \\lambda = 1.0 \\, \\text{m}\\) : Period of the wave (assuming wave speed \\(c = 1 \\, \\text{m/s}\\) , so \\(T = \\lambda / c\\) ). \\(t\\) : Time values sampled over one period ( \\(t \\in [0, T]\\) ) with 100 frames. Source Positions Sources are placed at the vertices of a regular \\(N\\) -sided polygon (hexagon): \\[ (x_i, y_i) = \\left( R \\cos\\left( \\frac{2\\pi i}{N} \\right), R \\sin\\left( \\frac{2\\pi i}{N} \\right) \\right) \\] For \\(N = 6\\) and \\(R = 2.5 \\, \\text{m}\\) , the six sources are evenly spaced around a circle of radius 2.5 m. Wave Superposition The script computes the total wave displacement at each point \\((x, y)\\) for multiple time snapshots and tracks the maximum absolute displacement over one period: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^N \\frac{A}{\\sqrt{r_i}} \\cdot \\cos(kr_i - 2\\pi t) \\] Where: - \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) is the distance from the \\(i\\) -th source to point \\((x, y)\\) . - The phase \\(\\phi_i = 0\\) for all sources (coherent waves). - The amplitude scales as \\(1/\\sqrt{r_i}\\) , appropriate for 2D wave propagation (unlike \\(1/r_i\\) in the previous model). - Time term \\(-2\\pi t\\) assumes frequency \\(f = 1/T = 1 \\, \\text{Hz}\\) . The peak map stores the maximum \\(|\\eta_{\\text{sum}}|\\) over all time snapshots \\(t \\in [0, T]\\) . Plot Interference Pattern : Displays the peak displacement as a 2D contour plot using the plasma colormap, highlighting constructive interference zones (high displacement). Grid : Covers a \\(10 \\times 10 \\, \\text{m}\\) area with 400x400 points for high resolution. Colorbar : Indicates maximum displacement \\(|\\eta|\\) . Title and Axes : Labels the plot as \"Peak Interference Zones (Constructive Regions)\" with \\(x\\) and \\(y\\) axes in meters. Equal Axes : Ensures the pattern\u2019s symmetry is preserved visually.","title":"Wave Interference from Polygonal Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-interference-from-polygonal-sources","text":"","title":"Wave Interference from Polygonal Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-statement","text":"The task is to analyze the interference patterns that form on the surface of water when multiple circular waves, each originating from a point source, superimpose. These sources are positioned at the vertices of a chosen regular polygon. The goal is to use both wave physics and numerical simulation to understand how coherent waves interact, producing patterns of constructive and destructive interference.","title":"Problem Statement"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"Wave interference is a fundamental concept in physics, where overlapping waves can amplify (constructive) or cancel (destructive) each other. On water, this can be observed beautifully with ripples meeting from multiple sources. This task leverages simple visual physics to explore: - How coherent wave sources interfere. - The influence of geometry on interference patterns. - Superposition of circular waveforms. By using polygonal source arrangements and a hands-on simulation, this becomes an intuitive way to understand wave mechanics and symmetry.","title":"Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#mathematical-model-of-a-single-wave","text":"The wave emitted from a single point source at position \\((x_0, y_0)\\) is modeled as: \\[ \\eta(x, y, t) = \\frac{A}{r} \\cdot \\cos(kr - \\omega t + \\phi) \\] Variables : - \\(\\eta(x, y, t)\\) : Displacement of the water surface at position \\((x, y)\\) and time \\(t\\) . - \\(A\\) : Amplitude of the wave. - \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) : Distance from source to point. - \\(k = \\frac{2\\pi}{\\lambda}\\) : Wave number, with \\(\\lambda\\) as the wavelength. - \\(\\omega = 2\\pi f\\) : Angular frequency, with \\(f\\) as the wave frequency. - \\(\\phi\\) : Initial phase of the wave.","title":"Mathematical Model of a Single Wave"},{"location":"1%20Physics/3%20Waves/Problem_1/#geometry-polygon-wave-source-arrangement","text":"Choose a regular polygon (e.g., triangle, square, pentagon). Place one point wave source at each vertex. All sources emit identical, coherent waves with: Same amplitude \\(A\\) , wavelength \\(\\lambda\\) , and frequency \\(f\\) . Same or constant phase differences. Let the number of sides (and thus number of sources) be: \\(N = \\text{Number of vertices}\\) To calculate their positions, evenly distribute them around a circle: \\[ (x_i, y_i) = \\left( R \\cos(\\theta_i), R \\sin(\\theta_i) \\right), \\quad \\theta_i = \\frac{2\\pi i}{N} \\]","title":"Geometry: Polygon Wave Source Arrangement"},{"location":"1%20Physics/3%20Waves/Problem_1/#superposition-of-waves","text":"To calculate the total wave displacement at a point \\((x, y)\\) , sum the contributions from all sources: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^N \\frac{A}{r_i} \\cdot \\cos(kr_i - \\omega t + \\phi_i) \\] Where: - \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) is the distance from the \\(i\\) -th source. - \\(\\phi_i\\) : Phase of the \\(i\\) -th source (typically 0 for all). This creates complex interference patterns on the water surface, especially in symmetric arrangements like polygons.","title":"Superposition of Waves"},{"location":"1%20Physics/3%20Waves/Problem_1/#simulation-python-implementation","text":"1.The following Python code simulates and visualizes the interference pattern formed at a fixed time snapshot (e.g., \\(t = 0\\) ). import numpy as np import matplotlib.pyplot as plt # Parameters A = 1.0 # Amplitude of each wave lambda_ = 0.5 # Wavelength (m) k = 2 * np.pi / lambda_ # Wave number omega = 2 * np.pi * 1.0 # Angular frequency (assuming f = 1 Hz) phi = 0.0 # Phase (same for all sources) R = 1.0 # Radius of polygon (m) N = 5 # Number of sources (e.g., pentagon) t = 0.0 # Time snapshot # Define source positions for a regular polygon theta_i = np.linspace(0, 2 * np.pi, N, endpoint=False) # Angles for N vertices x_i = R * np.cos(theta_i) # x-coordinates of sources y_i = R * np.sin(theta_i) # y-coordinates of sources # Create a grid for the simulation x = np.linspace(-3, 3, 200) # x-range (m) y = np.linspace(-3, 3, 200) # y-range (m) X, Y = np.meshgrid(x, y) # 2D grid eta_sum = np.zeros_like(X) # Initialize wave displacement # Calculate total wave displacement for i in range(N): # Distance from i-th source to each point (x, y) r_i = np.sqrt((X - x_i[i])**2 + (Y - y_i[i])**2) # Avoid division by zero near sources r_i = np.where(r_i < 1e-10, 1e-10, r_i) # Wave contribution from i-th source eta_i = (A / r_i) * np.cos(k * r_i - omega * t + phi) eta_sum += eta_i # Plot the interference pattern plt.figure(figsize=(8, 8)) plt.imshow(eta_sum, extent=[-3, 3, -3, 3], cmap='seismic', origin='lower') plt.colorbar(label='Wave Displacement $\\eta(x, y, t=0)$') plt.scatter(x_i, y_i, c='black', s=50, label='Sources') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title(f'Wave Interference Pattern (N={N} Sources, $t=0$)') plt.legend() plt.axis('equal') plt.show()","title":"Simulation \u2013 Python Implementation"},{"location":"1%20Physics/3%20Waves/Problem_1/#explanation","text":"","title":"Explanation"},{"location":"1%20Physics/3%20Waves/Problem_1/#parameters","text":"\\(A = 1.0\\) : Amplitude of each wave. \\(\\lambda = 0.5 \\, \\text{m}\\) : Wavelength, giving \\(k = \\frac{2\\pi}{\\lambda}\\) . \\(\\omega = 2\\pi \\cdot 1.0\\) : Angular frequency (assuming \\(f = 1 \\, \\text{Hz}\\) ). \\(\\phi = 0.0\\) : Phase (same for all sources). \\(R = 1.0 \\, \\text{m}\\) : Radius of the polygon. \\(N = 5\\) : Number of sources (pentagon arrangement). \\(t = 0\\) : Fixed time snapshot.","title":"Parameters"},{"location":"1%20Physics/3%20Waves/Problem_1/#source-positions","text":"Sources are placed at the vertices of a regular \\(N\\) -sided polygon: \\[ (x_i, y_i) = \\left( R \\cos\\left( \\frac{2\\pi i}{N} \\right), R \\sin\\left( \\frac{2\\pi i}{N} \\right) \\right) \\]","title":"Source Positions"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-superposition","text":"Computes the total displacement: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^N \\frac{A}{r_i} \\cdot \\cos(kr_i - \\omega t + \\phi_i) \\] where \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) .","title":"Wave Superposition"},{"location":"1%20Physics/3%20Waves/Problem_1/#plot","text":"Displays the interference pattern as a 2D heatmap using the seismic colormap (red for positive, blue for negative). Marks source positions as black dots. Includes a colorbar for wave displacement \\(\\eta\\) . Uses equal axes to preserve symmetry.","title":"Plot"},{"location":"1%20Physics/3%20Waves/Problem_1/#simulation-python-implementation_1","text":"2.This simulation ignores time and calculates the maximum possible displacement across time \u2014 a kind of \u201cheatmap\u201d showing where the strongest interference consistently occurs. import numpy as np import matplotlib.pyplot as plt # Parameters A = 1 wavelength = 1.0 k = 2 * np.pi / wavelength N = 6 # Number of sources (hexagon) R = 2.5 # Polygon radius # Grid x_vals = np.linspace(-5, 5, 400) y_vals = np.linspace(-5, 5, 400) X, Y = np.meshgrid(x_vals, y_vals) # Source positions source_positions = [ (R * np.cos(2 * np.pi * i / N), R * np.sin(2 * np.pi * i / N)) for i in range(N) ] # Sum peak values over 1 period of wave T = wavelength # Period of the wave frames = 100 t_vals = np.linspace(0, T, frames) # Superposition peak_map = np.zeros_like(X) for t in t_vals: snapshot = np.zeros_like(X) for x0, y0 in source_positions: r = np.sqrt((X - x0)**2 + (Y - y0)**2) + 1e-6 snapshot += A / np.sqrt(r) * np.cos(k * r - 2 * np.pi * t) peak_map = np.maximum(peak_map, np.abs(snapshot)) # Plot plt.figure(figsize=(8, 6)) plt.contourf(X, Y, peak_map, levels=100, cmap='plasma') plt.colorbar(label='Max Displacement |\u03b7|') plt.title('Peak Interference Zones (Constructive Regions)') plt.axis('equal') plt.xlabel('x') plt.ylabel('y') plt.show()","title":"Simulation \u2013 Python Implementation"},{"location":"1%20Physics/3%20Waves/Problem_1/#explanation-wave-interference-simulation","text":"This Python script simulates and visualizes the peak interference pattern formed by multiple coherent wave sources arranged at the vertices of a regular hexagon, capturing the maximum displacement over one wave period.","title":"Explanation: Wave Interference Simulation"},{"location":"1%20Physics/3%20Waves/Problem_1/#parameters_1","text":"\\(A = 1.0\\) : Amplitude of each wave. \\(\\lambda = 1.0 \\, \\text{m}\\) : Wavelength, giving \\(k = \\frac{2\\pi}{\\lambda}\\) . \\(N = 6\\) : Number of sources (hexagon arrangement). \\(R = 2.5 \\, \\text{m}\\) : Radius of the polygon. \\(T = \\lambda = 1.0 \\, \\text{m}\\) : Period of the wave (assuming wave speed \\(c = 1 \\, \\text{m/s}\\) , so \\(T = \\lambda / c\\) ). \\(t\\) : Time values sampled over one period ( \\(t \\in [0, T]\\) ) with 100 frames.","title":"Parameters"},{"location":"1%20Physics/3%20Waves/Problem_1/#source-positions_1","text":"Sources are placed at the vertices of a regular \\(N\\) -sided polygon (hexagon): \\[ (x_i, y_i) = \\left( R \\cos\\left( \\frac{2\\pi i}{N} \\right), R \\sin\\left( \\frac{2\\pi i}{N} \\right) \\right) \\] For \\(N = 6\\) and \\(R = 2.5 \\, \\text{m}\\) , the six sources are evenly spaced around a circle of radius 2.5 m.","title":"Source Positions"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-superposition_1","text":"The script computes the total wave displacement at each point \\((x, y)\\) for multiple time snapshots and tracks the maximum absolute displacement over one period: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^N \\frac{A}{\\sqrt{r_i}} \\cdot \\cos(kr_i - 2\\pi t) \\] Where: - \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) is the distance from the \\(i\\) -th source to point \\((x, y)\\) . - The phase \\(\\phi_i = 0\\) for all sources (coherent waves). - The amplitude scales as \\(1/\\sqrt{r_i}\\) , appropriate for 2D wave propagation (unlike \\(1/r_i\\) in the previous model). - Time term \\(-2\\pi t\\) assumes frequency \\(f = 1/T = 1 \\, \\text{Hz}\\) . The peak map stores the maximum \\(|\\eta_{\\text{sum}}|\\) over all time snapshots \\(t \\in [0, T]\\) .","title":"Wave Superposition"},{"location":"1%20Physics/3%20Waves/Problem_1/#plot_1","text":"Interference Pattern : Displays the peak displacement as a 2D contour plot using the plasma colormap, highlighting constructive interference zones (high displacement). Grid : Covers a \\(10 \\times 10 \\, \\text{m}\\) area with 400x400 points for high resolution. Colorbar : Indicates maximum displacement \\(|\\eta|\\) . Title and Axes : Labels the plot as \"Peak Interference Zones (Constructive Regions)\" with \\(x\\) and \\(y\\) axes in meters. Equal Axes : Ensures the pattern\u2019s symmetry is preserved visually.","title":"Plot"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"1. Exploration of Applications of the Lorentz Force Introduction The Lorentz force is fundamental to the motion of charged particles in both electric and magnetic fields. It is given by: \\[ F = q E + q (v \\times B) \\] Where: - \\(F\\) is the total force on the particle, - \\(q\\) is the particle\u2019s electric charge, - \\(E\\) is the electric field vector, - \\(B\\) is the magnetic field vector, - \\(v\\) is the velocity of the particle. This force determines the trajectory and acceleration of particles in various physical systems, especially in modern technology and fundamental physics. Key Systems Where the Lorentz Force Is Crucial 1. Particle Accelerators Application : Accelerate charged particles to high speeds using electric fields and guide them with magnetic fields. Lorentz Role : - Electric fields provide acceleration (linear increase in speed). - Magnetic fields bend the particle\u2019s path, enabling circular or spiral motion. Example : In a cyclotron, particles spiral outward due to the combined effect of magnetic deflection and increasing kinetic energy. 2. Mass Spectrometers Application : Separate ions based on their mass-to-charge ratio. Lorentz Role : - A known \\(B\\) -field bends particle paths. - The radius of curvature depends on mass and velocity: \\[ r = \\frac{m v}{q B} \\] By measuring the deflection, the mass of particles can be inferred. 3. Plasma Confinement in Fusion Reactors Application : Contain hot ionized gas (plasma) for controlled fusion. Lorentz Role : - Charged particles spiral along magnetic field lines. - Magnetic traps (e.g., tokamaks, stellarators) use complex \\(B\\) -fields to keep plasma from touching reactor walls. 4. Cathode Ray Tubes & CRT Monitors Application : Use deflected electron beams to generate images on screens. Lorentz Role : - Magnetic or electric fields steer electron paths to target pixels on a phosphorescent screen. 5. Astrophysical Environments Application : Motion of particles in cosmic magnetic fields. Lorentz Role : - Charged particles (cosmic rays, solar wind) spiral along planetary magnetic fields. - Auroras are caused by electrons being steered by Earth\u2019s \\(B\\) -field into the upper atmosphere. Role of \\(E\\) and \\(B\\) Fields Electric Fields ( \\(E\\) ) Affect particle motion along the field lines. Provide linear acceleration. Control energy gain in accelerators. Used in devices like capacitors, ion thrusters, and electric field traps. Magnetic Fields ( \\(B\\) ) Affect motion perpendicular to both velocity and field via: \\[ F_B = q (v \\times B) \\] Cause circular or helical motion. Useful for guiding and trapping particles without energy change. Essential in plasma containment, mass analysis, and beam focusing. 2. Simulating Particle Motion Under Lorentz Force Goal Simulate and visualize how a charged particle moves when subject to different combinations of electric and magnetic fields, based on the Lorentz force law: \\[ F = q E + q (v \\times B) \\] This will demonstrate: - Circular motion (uniform magnetic field). - Helical motion (magnetic field + initial velocity component along field). - Drift motion (crossed \\(E\\) and \\(B\\) fields). Simulation Overview We solve the particle\u2019s equations of motion numerically using the Runge-Kutta method or Euler\u2019s method. We simulate: - Position: \\(r(t)\\) , - Velocity: \\(v(t)\\) . Governing Equations The equations of motion are: \\[ \\frac{dr}{dt} = v, \\quad \\frac{dv}{dt} = \\frac{q}{m} \\left( E + v \\times B \\right) \\] 3. \u2013 Parameter Exploration of Lorentz Force Effects Objective Explore how changing physical parameters affects a particle\u2019s trajectory under the Lorentz force: \\[ F = q E + q (v \\times B) \\] This helps understand: - How field strengths bend or accelerate the motion. - How initial velocity determines orbit radius or drift. - How charge and mass influence acceleration and curvature. Theoretical Considerations Stronger \\(B\\) : Leads to tighter circular or helical motion. Stronger \\(E\\) : Causes faster drift or linear acceleration. Larger charge \\(q\\) : Results in more force, leading to tighter curvature or faster acceleration. Larger mass \\(m\\) : Slower response to fields due to greater inertia. 4. Visualization of Particle Motion and Key Physical Effects Objective Use 2D and 3D plots to visualize the motion of a charged particle under the Lorentz force. Highlight important physical features such as: - Larmor radius (the radius of circular motion in a magnetic field). - Drift velocity (net particle motion in crossed \\(E\\) and \\(B\\) fields). Key Concepts Larmor Radius ( \\(r_L\\) ) Occurs in uniform magnetic fields when \\(E = 0\\) . Given by: \\[ r_L = \\frac{m v_\\perp}{q B} \\] where \\(v_\\perp\\) is the component of velocity perpendicular to the magnetic field. E \u00d7 B Drift When \\(E \\perp B\\) , the particle undergoes a net drift. Drift velocity: \\[ v_{\\text{drift}} = \\frac{E \\times B}{B^2} \\] Python Code: 2D and 3D Visualization with Highlights import numpy as np import matplotlib.pyplot as plt # Parameters q = 1.0 # Charge m = 1.0 # Mass B = np.array([0.0, 0.0, 1.0]) # Magnetic field E = np.array([1.0, 0.0, 0.0]) # Electric field (change for different cases) v0 = np.array([0.0, 1.0, 0.5]) # Initial velocity r0 = np.array([0.0, 0.0, 0.0]) # Initial position dt = 0.01 steps = 3000 # Initialize r = r0.copy() v = v0.copy() positions = [r.copy()] for _ in range(steps): F = q * (E + np.cross(v, B)) a = F / m v += a * dt r += v * dt positions.append(r.copy()) positions = np.array(positions) # Calculate theoretical Larmor radius (if E = 0) v_perp = np.linalg.norm(v0[:2]) # perpendicular to Bz B_mag = np.linalg.norm(B) r_L = m * v_perp / (q * B_mag) if B_mag != 0 else np.nan # Calculate drift velocity if B_mag != 0 and np.linalg.norm(E) > 0: v_drift = np.cross(E, B) / B_mag**2 else: v_drift = np.array([0.0, 0.0, 0.0]) # Plot 2D projection (x vs y) plt.figure(figsize=(7, 6)) plt.plot(positions[:, 0], positions[:, 1], label='Trajectory (x-y)') plt.title('2D Trajectory Projection (x-y plane)') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.grid(True) plt.legend() # Annotate Larmor radius if not np.isnan(r_L): plt.text(0.05, 0.95, f'Larmor radius \u2248 {r_L:.2f}', transform=plt.gca().transAxes, fontsize=12) # Annotate drift velocity if np.linalg.norm(v_drift) > 0: plt.text(0.05, 0.90, f'Drift velocity \u2248 {v_drift[0]:.2f}, {v_drift[1]:.2f}', transform=plt.gca().transAxes, fontsize=12) plt.show() # 3D plot from mpl_toolkits.mplot3d import Axes3D fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot3D(positions[:, 0], positions[:, 1], positions[:, 2], label='3D Trajectory') ax.set_title(\"3D Trajectory of Charged Particle\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") ax.set_zlabel(\"z\") ax.legend() plt.show() Explanation: This Python script simulates and visualizes the motion of a charged particle under the Lorentz force in both 2D and 3D, highlighting key physical effects such as the Larmor radius and E \u00d7 B drift velocity. Parameters \\(q = 1.0\\) : Charge of the particle (arbitrary units). \\(m = 1.0\\) : Mass of the particle (arbitrary units). \\(B = [0, 0, 1.0]\\) : Magnetic field vector (along z-axis, strength 1.0). \\(E = [1.0, 0, 0]\\) : Electric field vector (along x-axis, strength 1.0). \\(v_0 = [0.0, 1.0, 0.5]\\) : Initial velocity (m/s, components in y and z). \\(r_0 = [0.0, 0.0, 0.0]\\) : Initial position (m, at origin). \\(dt = 0.01\\) : Time step for simulation. \\(\\text{steps} = 3000\\) : Number of time steps. Plot 2D Plot : Displays the particle\u2019s trajectory projected onto the x-y plane. Shows circular or curved motion due to the magnetic field. Annotates the Larmor radius ( \\(r_L\\) ) if \\(B \\neq 0\\) . Annotates the drift velocity components if \\(E \\neq 0\\) . Uses equal axes to preserve the shape of the trajectory. Includes a grid and legend for clarity. 3D Plot : Shows the full 3D trajectory ( \\(x\\) , \\(y\\) , \\(z\\) ). Highlights helical motion (due to \\(v_{0z} \\neq 0\\) ) combined with drift. Labels axes in meters and includes a legend. Python Simulation (3D Motion) import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.0 # Charge (C) m = 1.0 # Mass (kg) dt = 0.01 # Time step steps = 5000 # Number of steps # Initial Conditions r = np.array([0.0, 0.0, 0.0]) # Initial position v = np.array([1.0, 1.0, 2.0]) # Initial velocity # Field Configuration E = np.array([0.0, 0.0, 0.0]) # Electric field B = np.array([0.0, 0.0, 1.0]) # Magnetic field # You can try: # E = [1, 0, 0], B = [0, 0, 1] \u2192 Crossed fields # E = [0, 0, 0], B = [0, 0, 1] \u2192 Pure magnetic # E = [0, 0, 1], B = [0, 0, 1] \u2192 Combined fields # Storage positions = [r.copy()] # Euler Integration for _ in range(steps): F = q * (E + np.cross(v, B)) a = F / m v = v + a * dt r = r + v * dt positions.append(r.copy()) positions = np.array(positions) # Plotting fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot3D(positions[:, 0], positions[:, 1], positions[:, 2], label='Trajectory') ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('z') ax.set_title('Charged Particle Trajectory under Lorentz Force') ax.legend() plt.show() Explanation: This Python script simulates and visualizes the 3D motion of a charged particle under the Lorentz force, demonstrating its trajectory influenced by electric and magnetic fields. Parameters \\(q = 1.0\\) : Charge of the particle (arbitrary units). \\(m = 1.0\\) : Mass of the particle (arbitrary units). \\(dt = 0.01\\) : Time step for simulation. \\(\\text{steps} = 5000\\) : Number of time steps. \\(r_0 = [0.0, 0.0, 0.0]\\) : Initial position (m, at origin). \\(v_0 = [1.0, 1.0, 2.0]\\) : Initial velocity (m/s, components in x, y, z). \\(E = [0.0, 0.0, 0.0]\\) : Electric field vector (no electric field in this setup). \\(B = [0.0, 0.0, 1.0]\\) : Magnetic field vector (along z-axis, strength 1.0). Simulation Method The script uses Euler\u2019s method to numerically solve the equations of motion under the Lorentz force: \\[ F = q E + q (v \\times B) \\] \\[ \\frac{dr}{dt} = v, \\quad \\frac{dv}{dt} = \\frac{F}{m} = \\frac{q}{m} \\left( E + v \\times B \\right) \\] Force Calculation : Computes \\(F = q (E + v \\times B)\\) at each step. Here, \\(E = 0\\) , so \\(F = q (v \\times B)\\) . Acceleration : \\(a = F / m\\) . Update : Updates velocity ( \\(v \\gets v + a \\cdot dt\\) ) and position ( \\(r \\gets r + v \\cdot dt\\) ). Tracks positions over 5000 steps to form the trajectory. Physical Calculations Larmor Radius ( \\(r_L\\) ) : Since \\(E = 0\\) , the particle undergoes circular or helical motion in a uniform magnetic field. The radius of the circular component (in the x-y plane, perpendicular to \\(B\\) ) is: $$ r_L = \\frac{m v_\\perp}{q B} $$ where \\(v_\\perp = \\sqrt{v_{0x}^2 + v_{0y}^2} = \\sqrt{1.0^2 + 1.0^2} = \\sqrt{2} \\approx 1.414\\) , \\(q = 1.0\\) , \\(m = 1.0\\) , and \\(B = 1.0\\) . Thus, \\(r_L \\approx 1.414\\) . Helical Motion : The initial velocity component along \\(B\\) (z-axis), \\(v_{0z} = 2.0\\) , causes linear motion along z, combining with the x-y circular motion to form a helix. E \u00d7 B Drift : Since \\(E = 0\\) , there is no drift velocity ( \\(v_{\\text{drift}} = \\frac{E \\times B}{B^2} = 0\\) ). Plot 3D Plot : Displays the full 3D trajectory ( \\(x\\) , \\(y\\) , \\(z\\) ) of the particle. Shows a helical path due to the magnetic field ( \\(B\\) along z) and non-zero \\(v_{0z}\\) . The x-y plane exhibits circular motion with radius approximately equal to the Larmor radius. Labels axes in meters (x, y, z) and includes a title and legend. The plot spans a sufficient duration (5000 steps) to capture multiple helical loops.","title":"1. Exploration of Applications of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-exploration-of-applications-of-the-lorentz-force","text":"","title":"1. Exploration of Applications of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#introduction","text":"The Lorentz force is fundamental to the motion of charged particles in both electric and magnetic fields. It is given by: \\[ F = q E + q (v \\times B) \\] Where: - \\(F\\) is the total force on the particle, - \\(q\\) is the particle\u2019s electric charge, - \\(E\\) is the electric field vector, - \\(B\\) is the magnetic field vector, - \\(v\\) is the velocity of the particle. This force determines the trajectory and acceleration of particles in various physical systems, especially in modern technology and fundamental physics.","title":"Introduction"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#key-systems-where-the-lorentz-force-is-crucial","text":"","title":"Key Systems Where the Lorentz Force Is Crucial"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-particle-accelerators","text":"Application : Accelerate charged particles to high speeds using electric fields and guide them with magnetic fields. Lorentz Role : - Electric fields provide acceleration (linear increase in speed). - Magnetic fields bend the particle\u2019s path, enabling circular or spiral motion. Example : In a cyclotron, particles spiral outward due to the combined effect of magnetic deflection and increasing kinetic energy.","title":"1. Particle Accelerators"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-mass-spectrometers","text":"Application : Separate ions based on their mass-to-charge ratio. Lorentz Role : - A known \\(B\\) -field bends particle paths. - The radius of curvature depends on mass and velocity: \\[ r = \\frac{m v}{q B} \\] By measuring the deflection, the mass of particles can be inferred.","title":"2. Mass Spectrometers"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-plasma-confinement-in-fusion-reactors","text":"Application : Contain hot ionized gas (plasma) for controlled fusion. Lorentz Role : - Charged particles spiral along magnetic field lines. - Magnetic traps (e.g., tokamaks, stellarators) use complex \\(B\\) -fields to keep plasma from touching reactor walls.","title":"3. Plasma Confinement in Fusion Reactors"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-cathode-ray-tubes-crt-monitors","text":"Application : Use deflected electron beams to generate images on screens. Lorentz Role : - Magnetic or electric fields steer electron paths to target pixels on a phosphorescent screen.","title":"4. Cathode Ray Tubes &amp; CRT Monitors"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#5-astrophysical-environments","text":"Application : Motion of particles in cosmic magnetic fields. Lorentz Role : - Charged particles (cosmic rays, solar wind) spiral along planetary magnetic fields. - Auroras are caused by electrons being steered by Earth\u2019s \\(B\\) -field into the upper atmosphere.","title":"5. Astrophysical Environments"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#role-of-e-and-b-fields","text":"","title":"Role of \\(E\\) and \\(B\\) Fields"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#electric-fields-e","text":"Affect particle motion along the field lines. Provide linear acceleration. Control energy gain in accelerators. Used in devices like capacitors, ion thrusters, and electric field traps.","title":"Electric Fields (\\(E\\))"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#magnetic-fields-b","text":"Affect motion perpendicular to both velocity and field via: \\[ F_B = q (v \\times B) \\] Cause circular or helical motion. Useful for guiding and trapping particles without energy change. Essential in plasma containment, mass analysis, and beam focusing.","title":"Magnetic Fields (\\(B\\))"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-simulating-particle-motion-under-lorentz-force","text":"","title":"2. Simulating Particle Motion Under Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#goal","text":"Simulate and visualize how a charged particle moves when subject to different combinations of electric and magnetic fields, based on the Lorentz force law: \\[ F = q E + q (v \\times B) \\] This will demonstrate: - Circular motion (uniform magnetic field). - Helical motion (magnetic field + initial velocity component along field). - Drift motion (crossed \\(E\\) and \\(B\\) fields).","title":"Goal"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulation-overview","text":"We solve the particle\u2019s equations of motion numerically using the Runge-Kutta method or Euler\u2019s method. We simulate: - Position: \\(r(t)\\) , - Velocity: \\(v(t)\\) .","title":"Simulation Overview"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#governing-equations","text":"The equations of motion are: \\[ \\frac{dr}{dt} = v, \\quad \\frac{dv}{dt} = \\frac{q}{m} \\left( E + v \\times B \\right) \\]","title":"Governing Equations"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-parameter-exploration-of-lorentz-force-effects","text":"","title":"3. \u2013 Parameter Exploration of Lorentz Force Effects"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#objective","text":"Explore how changing physical parameters affects a particle\u2019s trajectory under the Lorentz force: \\[ F = q E + q (v \\times B) \\] This helps understand: - How field strengths bend or accelerate the motion. - How initial velocity determines orbit radius or drift. - How charge and mass influence acceleration and curvature.","title":"Objective"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#theoretical-considerations","text":"Stronger \\(B\\) : Leads to tighter circular or helical motion. Stronger \\(E\\) : Causes faster drift or linear acceleration. Larger charge \\(q\\) : Results in more force, leading to tighter curvature or faster acceleration. Larger mass \\(m\\) : Slower response to fields due to greater inertia.","title":"Theoretical Considerations"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-visualization-of-particle-motion-and-key-physical-effects","text":"","title":"4. Visualization of Particle Motion and Key Physical Effects"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#objective_1","text":"Use 2D and 3D plots to visualize the motion of a charged particle under the Lorentz force. Highlight important physical features such as: - Larmor radius (the radius of circular motion in a magnetic field). - Drift velocity (net particle motion in crossed \\(E\\) and \\(B\\) fields).","title":"Objective"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#key-concepts","text":"","title":"Key Concepts"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#larmor-radius-r_l","text":"Occurs in uniform magnetic fields when \\(E = 0\\) . Given by: \\[ r_L = \\frac{m v_\\perp}{q B} \\] where \\(v_\\perp\\) is the component of velocity perpendicular to the magnetic field.","title":"Larmor Radius (\\(r_L\\))"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#e-b-drift","text":"When \\(E \\perp B\\) , the particle undergoes a net drift. Drift velocity: \\[ v_{\\text{drift}} = \\frac{E \\times B}{B^2} \\]","title":"E \u00d7 B Drift"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#python-code-2d-and-3d-visualization-with-highlights","text":"import numpy as np import matplotlib.pyplot as plt # Parameters q = 1.0 # Charge m = 1.0 # Mass B = np.array([0.0, 0.0, 1.0]) # Magnetic field E = np.array([1.0, 0.0, 0.0]) # Electric field (change for different cases) v0 = np.array([0.0, 1.0, 0.5]) # Initial velocity r0 = np.array([0.0, 0.0, 0.0]) # Initial position dt = 0.01 steps = 3000 # Initialize r = r0.copy() v = v0.copy() positions = [r.copy()] for _ in range(steps): F = q * (E + np.cross(v, B)) a = F / m v += a * dt r += v * dt positions.append(r.copy()) positions = np.array(positions) # Calculate theoretical Larmor radius (if E = 0) v_perp = np.linalg.norm(v0[:2]) # perpendicular to Bz B_mag = np.linalg.norm(B) r_L = m * v_perp / (q * B_mag) if B_mag != 0 else np.nan # Calculate drift velocity if B_mag != 0 and np.linalg.norm(E) > 0: v_drift = np.cross(E, B) / B_mag**2 else: v_drift = np.array([0.0, 0.0, 0.0]) # Plot 2D projection (x vs y) plt.figure(figsize=(7, 6)) plt.plot(positions[:, 0], positions[:, 1], label='Trajectory (x-y)') plt.title('2D Trajectory Projection (x-y plane)') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.grid(True) plt.legend() # Annotate Larmor radius if not np.isnan(r_L): plt.text(0.05, 0.95, f'Larmor radius \u2248 {r_L:.2f}', transform=plt.gca().transAxes, fontsize=12) # Annotate drift velocity if np.linalg.norm(v_drift) > 0: plt.text(0.05, 0.90, f'Drift velocity \u2248 {v_drift[0]:.2f}, {v_drift[1]:.2f}', transform=plt.gca().transAxes, fontsize=12) plt.show() # 3D plot from mpl_toolkits.mplot3d import Axes3D fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot3D(positions[:, 0], positions[:, 1], positions[:, 2], label='3D Trajectory') ax.set_title(\"3D Trajectory of Charged Particle\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") ax.set_zlabel(\"z\") ax.legend() plt.show()","title":"Python Code: 2D and 3D Visualization with Highlights"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#explanation","text":"This Python script simulates and visualizes the motion of a charged particle under the Lorentz force in both 2D and 3D, highlighting key physical effects such as the Larmor radius and E \u00d7 B drift velocity.","title":"Explanation:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#parameters","text":"\\(q = 1.0\\) : Charge of the particle (arbitrary units). \\(m = 1.0\\) : Mass of the particle (arbitrary units). \\(B = [0, 0, 1.0]\\) : Magnetic field vector (along z-axis, strength 1.0). \\(E = [1.0, 0, 0]\\) : Electric field vector (along x-axis, strength 1.0). \\(v_0 = [0.0, 1.0, 0.5]\\) : Initial velocity (m/s, components in y and z). \\(r_0 = [0.0, 0.0, 0.0]\\) : Initial position (m, at origin). \\(dt = 0.01\\) : Time step for simulation. \\(\\text{steps} = 3000\\) : Number of time steps.","title":"Parameters"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#plot","text":"2D Plot : Displays the particle\u2019s trajectory projected onto the x-y plane. Shows circular or curved motion due to the magnetic field. Annotates the Larmor radius ( \\(r_L\\) ) if \\(B \\neq 0\\) . Annotates the drift velocity components if \\(E \\neq 0\\) . Uses equal axes to preserve the shape of the trajectory. Includes a grid and legend for clarity. 3D Plot : Shows the full 3D trajectory ( \\(x\\) , \\(y\\) , \\(z\\) ). Highlights helical motion (due to \\(v_{0z} \\neq 0\\) ) combined with drift. Labels axes in meters and includes a legend.","title":"Plot"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#python-simulation-3d-motion","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.0 # Charge (C) m = 1.0 # Mass (kg) dt = 0.01 # Time step steps = 5000 # Number of steps # Initial Conditions r = np.array([0.0, 0.0, 0.0]) # Initial position v = np.array([1.0, 1.0, 2.0]) # Initial velocity # Field Configuration E = np.array([0.0, 0.0, 0.0]) # Electric field B = np.array([0.0, 0.0, 1.0]) # Magnetic field # You can try: # E = [1, 0, 0], B = [0, 0, 1] \u2192 Crossed fields # E = [0, 0, 0], B = [0, 0, 1] \u2192 Pure magnetic # E = [0, 0, 1], B = [0, 0, 1] \u2192 Combined fields # Storage positions = [r.copy()] # Euler Integration for _ in range(steps): F = q * (E + np.cross(v, B)) a = F / m v = v + a * dt r = r + v * dt positions.append(r.copy()) positions = np.array(positions) # Plotting fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot3D(positions[:, 0], positions[:, 1], positions[:, 2], label='Trajectory') ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('z') ax.set_title('Charged Particle Trajectory under Lorentz Force') ax.legend() plt.show()","title":"Python Simulation (3D Motion)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#explanation_1","text":"This Python script simulates and visualizes the 3D motion of a charged particle under the Lorentz force, demonstrating its trajectory influenced by electric and magnetic fields.","title":"Explanation:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#parameters_1","text":"\\(q = 1.0\\) : Charge of the particle (arbitrary units). \\(m = 1.0\\) : Mass of the particle (arbitrary units). \\(dt = 0.01\\) : Time step for simulation. \\(\\text{steps} = 5000\\) : Number of time steps. \\(r_0 = [0.0, 0.0, 0.0]\\) : Initial position (m, at origin). \\(v_0 = [1.0, 1.0, 2.0]\\) : Initial velocity (m/s, components in x, y, z). \\(E = [0.0, 0.0, 0.0]\\) : Electric field vector (no electric field in this setup). \\(B = [0.0, 0.0, 1.0]\\) : Magnetic field vector (along z-axis, strength 1.0).","title":"Parameters"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulation-method","text":"The script uses Euler\u2019s method to numerically solve the equations of motion under the Lorentz force: \\[ F = q E + q (v \\times B) \\] \\[ \\frac{dr}{dt} = v, \\quad \\frac{dv}{dt} = \\frac{F}{m} = \\frac{q}{m} \\left( E + v \\times B \\right) \\] Force Calculation : Computes \\(F = q (E + v \\times B)\\) at each step. Here, \\(E = 0\\) , so \\(F = q (v \\times B)\\) . Acceleration : \\(a = F / m\\) . Update : Updates velocity ( \\(v \\gets v + a \\cdot dt\\) ) and position ( \\(r \\gets r + v \\cdot dt\\) ). Tracks positions over 5000 steps to form the trajectory.","title":"Simulation Method"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#physical-calculations","text":"Larmor Radius ( \\(r_L\\) ) : Since \\(E = 0\\) , the particle undergoes circular or helical motion in a uniform magnetic field. The radius of the circular component (in the x-y plane, perpendicular to \\(B\\) ) is: $$ r_L = \\frac{m v_\\perp}{q B} $$ where \\(v_\\perp = \\sqrt{v_{0x}^2 + v_{0y}^2} = \\sqrt{1.0^2 + 1.0^2} = \\sqrt{2} \\approx 1.414\\) , \\(q = 1.0\\) , \\(m = 1.0\\) , and \\(B = 1.0\\) . Thus, \\(r_L \\approx 1.414\\) . Helical Motion : The initial velocity component along \\(B\\) (z-axis), \\(v_{0z} = 2.0\\) , causes linear motion along z, combining with the x-y circular motion to form a helix. E \u00d7 B Drift : Since \\(E = 0\\) , there is no drift velocity ( \\(v_{\\text{drift}} = \\frac{E \\times B}{B^2} = 0\\) ).","title":"Physical Calculations"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#plot_1","text":"3D Plot : Displays the full 3D trajectory ( \\(x\\) , \\(y\\) , \\(z\\) ) of the particle. Shows a helical path due to the magnetic field ( \\(B\\) along z) and non-zero \\(v_{0z}\\) . The x-y plane exhibits circular motion with radius approximately equal to the Larmor radius. Labels axes in meters (x, y, z) and includes a title and legend. The plot spans a sufficient duration (5000 steps) to capture multiple helical loops.","title":"Plot"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"1. Simulating Sampling Distributions Objective Simulate large population datasets from different probability distributions to study how their sample means behave a foundational step in exploring the Central Limit Theorem (CLT). Distributions Selected Uniform distribution : All values equally likely. Exponential distribution : Highly skewed, often used in time-between-events modeling. Binomial distribution : Discrete, based on probability of success/failure. Description of Populations Distribution Population Size Mean (Expected) Notes Uniform(0,1) 1,000,000 \\(\\approx 0.5\\) Symmetric, bounded Exponential 1,000,000 \\(\\approx 1.0\\) Skewed right, continuous Binomial 1,000,000 \\(\\approx 5.0\\) Discrete, symmetric when \\(p=0.5\\) 2. Parameter Exploration Objective Explore how: The shape of the population distribution (e.g., symmetric vs. skewed), The population variance, The sample size \\(n\\) , affect how quickly the sampling distribution of the mean converges to a normal distribution. Core Concept: CLT and Convergence The more skewed or non-normal a population is, the larger the sample size \\(n\\) needed for the sample mean to appear normally distributed. The larger the population variance, the wider the sampling distribution of the sample mean. Regardless of the original shape, sample means tend to a normal distribution as \\(n \\to \\infty\\) . Quantitative Relationships The standard deviation of the sampling distribution of the mean is: \\[ \\sigma_{\\bar{x}} = \\frac{\\sigma}{\\sqrt{n}} \\] Where: - \\(\\sigma\\) = standard deviation of the population, - \\(n\\) = sample size. 3. Practical Applications of the Central Limit Theorem Objective Explain why the Central Limit Theorem matters in real-world scenarios and how it provides the mathematical foundation for making predictions, building models, and making decisions based on sampled data. Why CLT Is So Important The CLT tells us that: - The distribution of the sample mean approximates a normal distribution as the sample size increases, regardless of the population\u2019s original shape. - This principle is essential because in most practical cases, we don\u2019t have access to the whole population, and we rely on samples. 1. Estimating Population Parameters In scientific studies, economics, and medicine, we rarely get to study an entire population. Instead, we take samples (e.g., survey 1,000 people about income). Use the sample mean to estimate the true population mean. Thanks to CLT: We know how the sample mean behaves. We can compute confidence intervals for the population mean. We can quantify the uncertainty of our estimate. Example : Estimating average blood pressure in a population using a sample of 100 patients. CLT ensures the distribution of sample means is normal, allowing us to construct reliable confidence intervals for the true mean. 2. Quality Control in Manufacturing In production, companies regularly inspect samples of their products to check for defects or inconsistencies. CLT allows manufacturers to: Set up control charts (e.g., X\u0304-charts). Detect when the average measurement of a product (e.g., weight, thickness) drifts from the target. Determine if deviations are random or indicate a systematic problem. Example : A factory samples 10 bolts from every batch. If the average diameter falls outside the control limits (based on CLT), the process is stopped and investigated. 3. Financial Modeling and Risk Management In finance, risk and return estimates are often based on historical data samples. CLT enables: Predicting average returns from sampled price data. Constructing confidence intervals for expected investment returns. Building Monte Carlo simulations based on assumed or sampled data. Example : A portfolio manager uses past 30-day returns (samples) to predict future average return, and uses the CLT to compute the probability of large losses or gains. 4. Python Simulations Python Code: Generate Populations: import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Set seed for reproducibility np.random.seed(42) # Population size N = 1000000 # 1 million values # 1. Uniform Distribution [0, 1] uniform_pop = np.random.uniform(0, 1, N) # 2. Exponential Distribution (\u03bb=1 \u2192 scale=1) exp_pop = np.random.exponential(scale=1.0, size=N) # 3. Binomial Distribution (n=10, p=0.5) binom_pop = np.random.binomial(n=10, p=0.5, size=N) # Plot the populations fig, axs = plt.subplots(1, 3, figsize=(18, 4)) sns.histplot(uniform_pop, kde=True, ax=axs[0], color='skyblue') axs[0].set_title(\"Uniform Distribution [0, 1]\") sns.histplot(exp_pop, kde=True, ax=axs[1], color='orange') axs[1].set_title(\"Exponential Distribution (\u03bb=1)\") sns.histplot(binom_pop, kde=True, ax=axs[2], color='green') axs[2].set_title(\"Binomial Distribution (n=10, p=0.5)\") plt.tight_layout() plt.show() Explanation: Population Distribution Simulation This Python script generates and visualizes histograms of three population distributions with 1,000,000 samples each, using NumPy and Seaborn, to study their shapes. Parameters Uniform Distribution [0, 1] : Random values between 0 and 1, symmetric and bounded. Exponential Distribution (\u03bb=1) : Positive values with right skew, scale parameter 1.0. Binomial Distribution (n=10, p=0.5) : Discrete values from 0 to 10, symmetric due to \\(p=0.5\\) . Simulation Method Uses np.random.uniform, np.random.exponential, and np.random.binomial to generate populations. Plots histograms with kernel density estimation (KDE) for each distribution. Plot Displays three subplots: Uniform (skyblue), Exponential (orange), and Binomial (green). Titles indicate the distribution parameters, with equal y-axis scales for comparison. Python Code: CLT Sampling Simulation import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Use the populations from Task 1 (assume already defined) distributions = { \"Uniform(0,1)\": np.random.uniform(0, 1, 1000000), \"Exponential(\u03bb=1)\": np.random.exponential(1.0, 1000000), \"Binomial(n=10, p=0.5)\": np.random.binomial(10, 0.5, 1000000) } sample_sizes = [5, 10, 30, 50] n_repeats = 1000 # Plotting for dist_name, population in distributions.items(): fig, axs = plt.subplots(1, len(sample_sizes), figsize=(20, 4), sharey=True) fig.suptitle(f'Sampling Distributions of the Mean - {dist_name}', fontsize=16) for i, n in enumerate(sample_sizes): sample_means = [] for _ in range(n_repeats): sample = np.random.choice(population, size=n, replace=False) sample_means.append(np.mean(sample)) sns.histplot(sample_means, kde=True, ax=axs[i], color='mediumslateblue') axs[i].set_title(f'n = {n}') axs[i].set_xlabel(\"Sample Mean\") axs[i].set_ylabel(\"Frequency\") plt.tight_layout(rect=[0, 0.03, 1, 0.95]) plt.show() Explanation: Sampling Distributions of the Mean Simulation This Python script simulates the sampling distributions of the mean for three population distributions (Uniform, Exponential, Binomial) at different sample sizes, illustrating the Central Limit Theorem (CLT). Parameters Distributions : Uniform(0,1), Exponential( \\(\\lambda=1\\) ), Binomial( \\(n=10\\) , \\(p=0.5\\) ), each with 1,000,000 values. Sample Sizes ( \\(n\\) ) : 5, 10, 30, 50. Repeats : 1000 samples per size to compute sample means. Simulation Method For each distribution and sample size \\(n\\) , draws 1000 samples (without replacement). Computes the mean of each sample and plots the distribution of sample means. Plot Displays four subplots per distribution, showing histograms of sample means for \\(n=5\\) , 10, 30, 50. Overlays a kernel density estimate (KDE) curve. Uniform: Means center around 0.5, becoming more normal as \\(n\\) increases. Exponential: Means center around 1.0, initially skewed but normalizing by \\(n=50\\) . Binomial: Means center around 5.0, nearly normal even at \\(n=5\\) due to symmetry. Python Simulation: Explore Shape and Variance Effects import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Distributions with different shapes and variances populations = { \"Uniform(0, 1)\": np.random.uniform(0, 1, 1000000), # low variance, symmetric \"Exponential(scale=2)\": np.random.exponential(2, 1000000), # high variance, skewed \"Binomial(n=20, p=0.2)\": np.random.binomial(20, 0.2, 1000000) # discrete + skewed } sample_sizes = [5, 10, 30, 100] n_repeats = 1000 # Visualize how convergence depends on shape and variance for name, pop in populations.items(): pop_var = np.var(pop) print(f\"Population: {name}, Variance: {pop_var:.4f}\") fig, axs = plt.subplots(1, len(sample_sizes), figsize=(20, 4), sharey=True) fig.suptitle(f\"Convergence to Normality: {name} (Var={pop_var:.2f})\", fontsize=16) for i, n in enumerate(sample_sizes): means = [np.mean(np.random.choice(pop, size=n, replace=False)) for _ in range(n_repeats)] sns.histplot(means, kde=True, ax=axs[i], color='tomato') axs[i].set_title(f'n = {n}') axs[i].set_xlabel('Sample Mean') axs[i].set_ylabel('Frequency') plt.tight_layout(rect=[0, 0.03, 1, 0.95]) plt.show() Explanation: Convergence to Normality Simulation This Python script simulates the sampling distributions of the mean for three populations with different shapes and variances, demonstrating the Central Limit Theorem (CLT) convergence to normality. Parameters Populations : Uniform(0,1): Low variance (0.08), symmetric. Exponential(scale=2): High variance (4.01), skewed. Binomial(n=20, p=0.2): Variance (3.20), discrete, skewed. Sample Sizes ( \\(n\\) ) : 5, 10, 30, 100. Repeats : 1000 samples per size. Simulation Method For each population and \\(n\\) , computes 1000 sample means (without replacement). Plots histograms of sample means with a kernel density estimate (KDE). Plot Displays four subplots per population, showing sample mean distributions for \\(n=5\\) , 10, 30, 100. Uniform: Quickly normal (even at \\(n=5\\) ) due to symmetry, low variance. Exponential: Initially skewed, approaches normality by \\(n=100\\) , slower due to high variance. Binomial: Slightly skewed at \\(n=5\\) , nearly normal by \\(n=30\\) .","title":"1. Simulating Sampling Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1-simulating-sampling-distributions","text":"","title":"1. Simulating Sampling Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#objective","text":"Simulate large population datasets from different probability distributions to study how their sample means behave a foundational step in exploring the Central Limit Theorem (CLT).","title":"Objective"},{"location":"1%20Physics/6%20Statistics/Problem_1/#distributions-selected","text":"Uniform distribution : All values equally likely. Exponential distribution : Highly skewed, often used in time-between-events modeling. Binomial distribution : Discrete, based on probability of success/failure.","title":"Distributions Selected"},{"location":"1%20Physics/6%20Statistics/Problem_1/#description-of-populations","text":"Distribution Population Size Mean (Expected) Notes Uniform(0,1) 1,000,000 \\(\\approx 0.5\\) Symmetric, bounded Exponential 1,000,000 \\(\\approx 1.0\\) Skewed right, continuous Binomial 1,000,000 \\(\\approx 5.0\\) Discrete, symmetric when \\(p=0.5\\)","title":"Description of Populations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-parameter-exploration","text":"","title":"2. Parameter Exploration"},{"location":"1%20Physics/6%20Statistics/Problem_1/#objective_1","text":"Explore how: The shape of the population distribution (e.g., symmetric vs. skewed), The population variance, The sample size \\(n\\) , affect how quickly the sampling distribution of the mean converges to a normal distribution.","title":"Objective"},{"location":"1%20Physics/6%20Statistics/Problem_1/#core-concept-clt-and-convergence","text":"The more skewed or non-normal a population is, the larger the sample size \\(n\\) needed for the sample mean to appear normally distributed. The larger the population variance, the wider the sampling distribution of the sample mean. Regardless of the original shape, sample means tend to a normal distribution as \\(n \\to \\infty\\) .","title":"Core Concept: CLT and Convergence"},{"location":"1%20Physics/6%20Statistics/Problem_1/#quantitative-relationships","text":"The standard deviation of the sampling distribution of the mean is: \\[ \\sigma_{\\bar{x}} = \\frac{\\sigma}{\\sqrt{n}} \\] Where: - \\(\\sigma\\) = standard deviation of the population, - \\(n\\) = sample size.","title":"Quantitative Relationships"},{"location":"1%20Physics/6%20Statistics/Problem_1/#3-practical-applications-of-the-central-limit-theorem","text":"","title":"3. Practical Applications of the Central Limit Theorem"},{"location":"1%20Physics/6%20Statistics/Problem_1/#objective_2","text":"Explain why the Central Limit Theorem matters in real-world scenarios and how it provides the mathematical foundation for making predictions, building models, and making decisions based on sampled data.","title":"Objective"},{"location":"1%20Physics/6%20Statistics/Problem_1/#why-clt-is-so-important","text":"The CLT tells us that: - The distribution of the sample mean approximates a normal distribution as the sample size increases, regardless of the population\u2019s original shape. - This principle is essential because in most practical cases, we don\u2019t have access to the whole population, and we rely on samples.","title":"Why CLT Is So Important"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1-estimating-population-parameters","text":"In scientific studies, economics, and medicine, we rarely get to study an entire population. Instead, we take samples (e.g., survey 1,000 people about income). Use the sample mean to estimate the true population mean. Thanks to CLT: We know how the sample mean behaves. We can compute confidence intervals for the population mean. We can quantify the uncertainty of our estimate. Example : Estimating average blood pressure in a population using a sample of 100 patients. CLT ensures the distribution of sample means is normal, allowing us to construct reliable confidence intervals for the true mean.","title":"1. Estimating Population Parameters"},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-quality-control-in-manufacturing","text":"In production, companies regularly inspect samples of their products to check for defects or inconsistencies. CLT allows manufacturers to: Set up control charts (e.g., X\u0304-charts). Detect when the average measurement of a product (e.g., weight, thickness) drifts from the target. Determine if deviations are random or indicate a systematic problem. Example : A factory samples 10 bolts from every batch. If the average diameter falls outside the control limits (based on CLT), the process is stopped and investigated.","title":"2. Quality Control in Manufacturing"},{"location":"1%20Physics/6%20Statistics/Problem_1/#3-financial-modeling-and-risk-management","text":"In finance, risk and return estimates are often based on historical data samples. CLT enables: Predicting average returns from sampled price data. Constructing confidence intervals for expected investment returns. Building Monte Carlo simulations based on assumed or sampled data. Example : A portfolio manager uses past 30-day returns (samples) to predict future average return, and uses the CLT to compute the probability of large losses or gains.","title":"3. Financial Modeling and Risk Management"},{"location":"1%20Physics/6%20Statistics/Problem_1/#4-python-simulations","text":"","title":"4. Python Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#python-code-generate-populations","text":"import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Set seed for reproducibility np.random.seed(42) # Population size N = 1000000 # 1 million values # 1. Uniform Distribution [0, 1] uniform_pop = np.random.uniform(0, 1, N) # 2. Exponential Distribution (\u03bb=1 \u2192 scale=1) exp_pop = np.random.exponential(scale=1.0, size=N) # 3. Binomial Distribution (n=10, p=0.5) binom_pop = np.random.binomial(n=10, p=0.5, size=N) # Plot the populations fig, axs = plt.subplots(1, 3, figsize=(18, 4)) sns.histplot(uniform_pop, kde=True, ax=axs[0], color='skyblue') axs[0].set_title(\"Uniform Distribution [0, 1]\") sns.histplot(exp_pop, kde=True, ax=axs[1], color='orange') axs[1].set_title(\"Exponential Distribution (\u03bb=1)\") sns.histplot(binom_pop, kde=True, ax=axs[2], color='green') axs[2].set_title(\"Binomial Distribution (n=10, p=0.5)\") plt.tight_layout() plt.show()","title":"Python Code: Generate Populations:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#explanation-population-distribution-simulation","text":"This Python script generates and visualizes histograms of three population distributions with 1,000,000 samples each, using NumPy and Seaborn, to study their shapes.","title":"Explanation: Population Distribution Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#parameters","text":"Uniform Distribution [0, 1] : Random values between 0 and 1, symmetric and bounded. Exponential Distribution (\u03bb=1) : Positive values with right skew, scale parameter 1.0. Binomial Distribution (n=10, p=0.5) : Discrete values from 0 to 10, symmetric due to \\(p=0.5\\) .","title":"Parameters"},{"location":"1%20Physics/6%20Statistics/Problem_1/#simulation-method","text":"Uses np.random.uniform, np.random.exponential, and np.random.binomial to generate populations. Plots histograms with kernel density estimation (KDE) for each distribution.","title":"Simulation Method"},{"location":"1%20Physics/6%20Statistics/Problem_1/#plot","text":"Displays three subplots: Uniform (skyblue), Exponential (orange), and Binomial (green). Titles indicate the distribution parameters, with equal y-axis scales for comparison.","title":"Plot"},{"location":"1%20Physics/6%20Statistics/Problem_1/#python-code-clt-sampling-simulation","text":"import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Use the populations from Task 1 (assume already defined) distributions = { \"Uniform(0,1)\": np.random.uniform(0, 1, 1000000), \"Exponential(\u03bb=1)\": np.random.exponential(1.0, 1000000), \"Binomial(n=10, p=0.5)\": np.random.binomial(10, 0.5, 1000000) } sample_sizes = [5, 10, 30, 50] n_repeats = 1000 # Plotting for dist_name, population in distributions.items(): fig, axs = plt.subplots(1, len(sample_sizes), figsize=(20, 4), sharey=True) fig.suptitle(f'Sampling Distributions of the Mean - {dist_name}', fontsize=16) for i, n in enumerate(sample_sizes): sample_means = [] for _ in range(n_repeats): sample = np.random.choice(population, size=n, replace=False) sample_means.append(np.mean(sample)) sns.histplot(sample_means, kde=True, ax=axs[i], color='mediumslateblue') axs[i].set_title(f'n = {n}') axs[i].set_xlabel(\"Sample Mean\") axs[i].set_ylabel(\"Frequency\") plt.tight_layout(rect=[0, 0.03, 1, 0.95]) plt.show()","title":"Python Code: CLT Sampling Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#explanation-sampling-distributions-of-the-mean-simulation","text":"This Python script simulates the sampling distributions of the mean for three population distributions (Uniform, Exponential, Binomial) at different sample sizes, illustrating the Central Limit Theorem (CLT).","title":"Explanation: Sampling Distributions of the Mean Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#parameters_1","text":"Distributions : Uniform(0,1), Exponential( \\(\\lambda=1\\) ), Binomial( \\(n=10\\) , \\(p=0.5\\) ), each with 1,000,000 values. Sample Sizes ( \\(n\\) ) : 5, 10, 30, 50. Repeats : 1000 samples per size to compute sample means.","title":"Parameters"},{"location":"1%20Physics/6%20Statistics/Problem_1/#simulation-method_1","text":"For each distribution and sample size \\(n\\) , draws 1000 samples (without replacement). Computes the mean of each sample and plots the distribution of sample means.","title":"Simulation Method"},{"location":"1%20Physics/6%20Statistics/Problem_1/#plot_1","text":"Displays four subplots per distribution, showing histograms of sample means for \\(n=5\\) , 10, 30, 50. Overlays a kernel density estimate (KDE) curve. Uniform: Means center around 0.5, becoming more normal as \\(n\\) increases. Exponential: Means center around 1.0, initially skewed but normalizing by \\(n=50\\) . Binomial: Means center around 5.0, nearly normal even at \\(n=5\\) due to symmetry.","title":"Plot"},{"location":"1%20Physics/6%20Statistics/Problem_1/#python-simulation-explore-shape-and-variance-effects","text":"import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Distributions with different shapes and variances populations = { \"Uniform(0, 1)\": np.random.uniform(0, 1, 1000000), # low variance, symmetric \"Exponential(scale=2)\": np.random.exponential(2, 1000000), # high variance, skewed \"Binomial(n=20, p=0.2)\": np.random.binomial(20, 0.2, 1000000) # discrete + skewed } sample_sizes = [5, 10, 30, 100] n_repeats = 1000 # Visualize how convergence depends on shape and variance for name, pop in populations.items(): pop_var = np.var(pop) print(f\"Population: {name}, Variance: {pop_var:.4f}\") fig, axs = plt.subplots(1, len(sample_sizes), figsize=(20, 4), sharey=True) fig.suptitle(f\"Convergence to Normality: {name} (Var={pop_var:.2f})\", fontsize=16) for i, n in enumerate(sample_sizes): means = [np.mean(np.random.choice(pop, size=n, replace=False)) for _ in range(n_repeats)] sns.histplot(means, kde=True, ax=axs[i], color='tomato') axs[i].set_title(f'n = {n}') axs[i].set_xlabel('Sample Mean') axs[i].set_ylabel('Frequency') plt.tight_layout(rect=[0, 0.03, 1, 0.95]) plt.show()","title":"Python Simulation: Explore Shape and Variance Effects"},{"location":"1%20Physics/6%20Statistics/Problem_1/#explanation-convergence-to-normality-simulation","text":"This Python script simulates the sampling distributions of the mean for three populations with different shapes and variances, demonstrating the Central Limit Theorem (CLT) convergence to normality.","title":"Explanation: Convergence to Normality Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#parameters_2","text":"Populations : Uniform(0,1): Low variance (0.08), symmetric. Exponential(scale=2): High variance (4.01), skewed. Binomial(n=20, p=0.2): Variance (3.20), discrete, skewed. Sample Sizes ( \\(n\\) ) : 5, 10, 30, 100. Repeats : 1000 samples per size.","title":"Parameters"},{"location":"1%20Physics/6%20Statistics/Problem_1/#simulation-method_2","text":"For each population and \\(n\\) , computes 1000 sample means (without replacement). Plots histograms of sample means with a kernel density estimate (KDE).","title":"Simulation Method"},{"location":"1%20Physics/6%20Statistics/Problem_1/#plot_2","text":"Displays four subplots per population, showing sample mean distributions for \\(n=5\\) , 10, 30, 100. Uniform: Quickly normal (even at \\(n=5\\) ) due to symmetry, low variance. Exponential: Initially skewed, approaches normality by \\(n=100\\) , slower due to high variance. Binomial: Slightly skewed at \\(n=5\\) , nearly normal by \\(n=30\\) .","title":"Plot"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Part 1: Estimating \u03c0 Using a Circle 1. Theoretical Foundation: Estimating \u03c0 Using Random Points in a Circle The Idea Monte Carlo methods use random sampling to estimate values based on probability. To estimate \\(\\pi\\) , we can simulate a simple geometric setup: - A unit square with sides of length 1. - A quarter circle (or full circle) inscribed inside that square. - By randomly generating points in the square, we can compute the ratio of points that fall inside the circle. - This ratio helps us estimate \\(\\pi\\) using geometry. Step-by-Step Geometric Insight Consider: - A unit circle centered at the origin \\((0, 0)\\) , so the radius \\(r = 1\\) . - A square bounding this circle, ranging from \\((-1, -1)\\) to \\((1, 1)\\) . - Area of the circle: \\(\\pi r^2 = \\pi \\cdot 1^2 = \\pi\\) . - Area of the square: \\((2 \\cdot r)^2 = 4\\) . The theoretical ratio of the areas is: \\[ \\frac{\\text{Area of Circle}}{\\text{Area of Square}} = \\frac{\\pi}{4} \\] If we randomly generate points in the square, the fraction that fall inside the circle should approach this ratio: \\[ \\frac{\\text{Points in Circle}}{\\text{Total Points}} \\approx \\frac{\\pi}{4} \\] Estimating \u03c0 Solving for \\(\\pi\\) : \\[ \\pi \\approx 4 \\cdot \\left( \\frac{\\text{Points inside the circle}}{\\text{Total points}} \\right) \\] This estimate becomes more accurate as the number of points increases. Part 2: Estimating \u03c0 Using Buffon\u2019s Needle 1. Theoretical Foundation: Buffon\u2019s Needle Problem What Is Buffon\u2019s Needle? Buffon\u2019s Needle is a classic probability problem first posed by Georges-Louis Leclerc, Comte de Buffon in the 18th century. It shows how we can estimate the value of \\(\\pi\\) using a purely geometric probability experiment. The Setup Imagine a floor with parallel lines spaced \\(d\\) units apart. Now, suppose we randomly drop a needle of length \\(L\\) onto the floor. Some needles will cross one of the lines, and some won\u2019t. Key Assumptions The needle length \\(L\\) is less than or equal to the distance between lines \\(d\\) . Each drop is completely random in both: The center position of the needle. The angle the needle forms with respect to the lines. Theoretical Probability of a Crossing The probability that the needle crosses a line is: \\[ P = \\frac{2L}{\\pi d} \\] Where: - \\(L\\) : Needle length, - \\(d\\) : Distance between lines, - \\(\\pi\\) : The constant we aim to estimate. Use Simulation to Estimate \u03c0 If we perform the experiment \\(N\\) times and observe \\(C\\) crossings, then the probability is approximated as: \\[ P \\approx \\frac{C}{N} \\] Substitute into the formula for \\(P\\) and solve for \\(\\pi\\) : \\[ \\frac{C}{N} \\approx \\frac{2L}{\\pi d} \\quad \\Rightarrow \\quad \\pi \\approx \\frac{2L \\cdot N}{d \\cdot C} \\] Final Estimation Formula \\[ \\pi \\approx \\frac{2 \\cdot L \\cdot N}{d \\cdot C} \\] Where: - \\(L\\) : Needle length, - \\(d\\) : Distance between lines, - \\(N\\) : Number of throws (total drops), - \\(C\\) : Number of crossings. Simulations (Part 1) 1. Monte Carlo Simulation to Estimate \u03c0 import numpy as np import matplotlib.pyplot as plt # Number of random points N = 10000 # Generate random (x, y) points in the square [-1, 1] \u00d7 [-1, 1] x = np.random.uniform(-1, 1, N) y = np.random.uniform(-1, 1, N) # Calculate distance from origin (0, 0) dist = np.sqrt(x**2 + y**2) # Count how many points fall inside the unit circle (r <= 1) inside_circle = dist <= 1 n_inside = np.sum(inside_circle) # Estimate \u03c0 pi_estimate = 4 * n_inside / N # Print result print(f\"Estimated \u03c0 with {N} points: {pi_estimate:.6f}\") # --- Optional: Plot points --- plt.figure(figsize=(6,6)) plt.scatter(x[inside_circle], y[inside_circle], color='green', s=1, label='Inside Circle') plt.scatter(x[~inside_circle], y[~inside_circle], color='red', s=1, label='Outside Circle') circle = plt.Circle((0, 0), 1, color='black', fill=False) plt.gca().add_patch(circle) plt.gca().set_aspect('equal') plt.title(f\"Monte Carlo Estimation of \u03c0\\nEstimated \u03c0 \u2248 {pi_estimate:.6f}\") plt.legend() plt.xlabel(\"x\") plt.ylabel(\"y\") plt.grid(True) plt.show() How It Works Points are randomly scattered in a square. We use the circle equation \\( \\(x^2 + y^2 \\leq 1\\) \\) to determine if they land inside the unit circle. The ratio of inside points to total points approximates \\(\\pi/4\\) , which we scale by 4 to estimate \\(\\pi\\) . Observations With small \\(N\\) , results vary (more noise). With large \\(N\\) , estimate converges to true \\(\\pi \\approx 3.1416\\) . Visually, we can see the points inside the circle forming a filled disk. 2. Visualization of Monte Carlo Points import numpy as np import matplotlib.pyplot as plt # Number of points N = 5000 # Generate random (x, y) in square [-1, 1] x [-1, 1] x = np.random.uniform(-1, 1, N) y = np.random.uniform(-1, 1, N) # Determine if inside the unit circle r_squared = x**2 + y**2 inside = r_squared <= 1 # Plot setup plt.figure(figsize=(6, 6)) plt.scatter(x[inside], y[inside], color='limegreen', s=2, label='Inside Circle') plt.scatter(x[~inside], y[~inside], color='tomato', s=2, label='Outside Circle') # Add the actual circle boundary circle = plt.Circle((0, 0), 1, color='black', fill=False, linestyle='--', linewidth=1.5) plt.gca().add_patch(circle) # Aesthetics plt.title(\"Monte Carlo Simulation: Points in Unit Circle\", fontsize=14, weight='bold') plt.xlabel(\"x\") plt.ylabel(\"y\") plt.axis('equal') plt.xlim(-1, 1) plt.ylim(-1, 1) plt.legend() plt.grid(True) plt.show() 3. Analysis of Convergence in Monte Carlo Estimation of \ud835\udf0b import numpy as np import matplotlib.pyplot as plt # Target: real value of \u03c0 true_pi = np.pi # Simulate increasing numbers of points sample_sizes = np.logspace(2, 6, num=20, dtype=int) # from 100 to 1,000,000 pi_estimates = [] for N in sample_sizes: x = np.random.uniform(-1, 1, N) y = np.random.uniform(-1, 1, N) inside = (x**2 + y**2) <= 1 pi_est = 4 * np.sum(inside) / N pi_estimates.append(pi_est) # Plot convergence plt.figure(figsize=(10, 5)) plt.plot(sample_sizes, pi_estimates, marker='o', linestyle='-', label='Estimated \u03c0') plt.axhline(true_pi, color='red', linestyle='--', label='Actual \u03c0') plt.xscale('log') plt.xlabel(\"Number of Points (log scale)\") plt.ylabel(\"Estimated \u03c0\") plt.title(\"Convergence of Monte Carlo \u03c0 Estimate\") plt.grid(True, which='both', linestyle='--', alpha=0.6) plt.legend() plt.tight_layout() plt.show() Observations Sample Size (N) Behavior Small \\(N\\) (e.g. 100) Estimate fluctuates significantly Moderate \\(N\\) (e.g. 1,000\u201310,000) Estimate stabilizes but with visible noise Large \\(N\\) (\u2265 100,000) Estimate converges closer to \\(\\pi \\approx 3.1416\\) Discussion: Convergence Rate Monte Carlo methods converge slowly: \\[ \\text{Error} \\propto \\frac{1}{\\sqrt{N}} \\] This means to reduce error by 10\u00d7, you need 100\u00d7 more points. Variance of estimate decreases with larger sample sizes, but at diminishing returns. Convergence is stochastic\u2014each run gives slightly different results. Computational Considerations Factor Impact \\(N\\) (sample size) Larger \\(N\\) improves accuracy Runtime Increases linearly with \\(N\\) Memory Can be a limit with large arrays Random seed Affects reproducibility For accurate results in practice: use \\(N \\geq 10^5\\) , and consider repeating runs and averaging. Simulations (Part 2) 1. Simulation of Needle Drops import numpy as np # Parameters L = 1.0 # needle length d = 2.0 # distance between lines (must be >= L) N = 10000 # number of needle drops # Simulation: generate N random drops x_centers = np.random.uniform(0, d / 2, N) # distance from needle center to nearest line theta = np.random.uniform(0, np.pi / 2, N) # angle between needle and lines # A crossing occurs if the vertical component exceeds x_center crossings = x_centers <= (L / 2) * np.sin(theta) C = np.sum(crossings) # Estimate \u03c0 if C > 0: pi_estimate = (2 * L * N) / (d * C) print(f\"Estimated \u03c0 (Buffon's Needle, N={N}): {pi_estimate:.6f}\") else: print(\"No crossings detected \u2014 increase N or adjust parameters.\") How It Works \\(x_{\\text{center}}\\) : Random vertical distance from the needle\u2019s center to the closest line. \\(\\theta\\) : Random angle between the needle and the lines (uniformly distributed from 0 to \\(\\pi/2\\) ). A crossing happens when the projection of half the needle\u2019s length is long enough to touch a line, i.e.: \\[ \\frac{L}{2} \\cdot \\sin(\\theta) \\geq x_{\\text{center}} \\] Result We\u2019ll get a printout like: Estimated \u03c0 (Buffon's Needle, N=10000): 3.168568 Which will improve with higher \\(N\\) due to the law of large numbers. 2. Visualization of Buffon\u2019s Needle Simulation import numpy as np import matplotlib.pyplot as plt # Parameters L = 1.0 # needle length d = 2.0 # distance between parallel lines N = 200 # number of needles to plot (for clarity) # Generate random center positions and angles x_centers = np.random.uniform(0, d, N) y_centers = np.random.uniform(0, 10, N) # extend vertically to see multiple lines theta = np.random.uniform(0, np.pi, N) # angle in radians # Compute needle endpoints x1 = x_centers - (L / 2) * np.cos(theta) x2 = x_centers + (L / 2) * np.cos(theta) y1 = y_centers - (L / 2) * np.sin(theta) y2 = y_centers + (L / 2) * np.sin(theta) # Check which needles cross a line crossings = ((np.floor(x1 / d) != np.floor(x2 / d))) # Plot plt.figure(figsize=(8, 10)) # Draw horizontal parallel lines num_lines = int(np.ceil(max(y_centers) + L)) for k in range(0, num_lines): plt.axhline(k * d, color='black', linewidth=0.5, alpha=0.5) # Plot needles for i in range(N): color = 'crimson' if crossings[i] else 'gray' plt.plot([x1[i], x2[i]], [y1[i], y2[i]], color=color, linewidth=1.5) # Aesthetics plt.title(\"Buffon\u2019s Needle Simulation: Needle Crossings\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.axis(\"equal\") plt.xlim(0, d) plt.ylim(0, max(y_centers) + L) plt.grid(False) plt.show() Plot Description Black horizontal lines = floor lines spaced by \\(d\\) . Each line segment = a needle dropped at a random angle and position. Red needles = crossed a line. Gray needles = did not cross a line. This visual lets viewers see the randomness and how the crossing rate relates to estimating \\(\\pi\\) . 3. Track Convergence of Buffon\u2019s Needle import numpy as np import matplotlib.pyplot as plt # Parameters L = 1.0 d = 2.0 true_pi = np.pi # Logarithmically increasing sample sizes sample_sizes = np.logspace(2, 5, num=15, dtype=int) # from 100 to 100,000 pi_estimates_buffon = [] # Simulate and estimate \u03c0 for each sample size for N in sample_sizes: x_centers = np.random.uniform(0, d / 2, N) theta = np.random.uniform(0, np.pi / 2, N) crossings = x_centers <= (L / 2) * np.sin(theta) C = np.sum(crossings) if C > 0: pi_est = (2 * L * N) / (d * C) else: pi_est = np.nan # Avoid division by zero pi_estimates_buffon.append(pi_est) # Plot convergence plt.figure(figsize=(10, 5)) plt.plot(sample_sizes, pi_estimates_buffon, marker='o', label=\"Buffon's Needle\") plt.axhline(true_pi, color='red', linestyle='--', label='Actual \u03c0') plt.xscale('log') plt.xlabel(\"Number of Needle Drops (log scale)\") plt.ylabel(\"Estimated \u03c0\") plt.title(\"Convergence of Buffon\u2019s Needle Estimate\") plt.legend() plt.grid(True, which='both', linestyle='--', alpha=0.5) plt.tight_layout() plt.show() Interpretation of Results Convergence Behavior Sample Size Behavior Small \\(N\\) (<1,000) High variability, poor estimate Moderate \\(N\\) Rough approximation Large \\(N\\) (\u226510,000) Gradual convergence toward \\(\\pi\\) The estimation converges slowly due to random angle dependence. Like the circle method, accuracy improves as \\(N \\to \\infty\\) Comparison: Buffon\u2019s Needle vs. Circle-Based Method Feature Circle-Based Method Buffon\u2019s Needle Convergence rate \\(\\propto \\frac{1}{\\sqrt{N}}\\) \\(\\propto \\frac{1}{\\sqrt{N}}\\) Variance Lower Higher (due to sine in denominator) Visual intuition Clear geometry (circle area) Historical, less intuitive Implementation Very simple Slightly more complex Practical accuracy More stable More noisy without very large \\(N\\)","title":"Part 1: Estimating \u03c0 Using a Circle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-1-estimating-using-a-circle","text":"","title":"Part 1: Estimating \u03c0 Using a Circle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-theoretical-foundation-estimating-using-random-points-in-a-circle","text":"","title":"1. Theoretical Foundation: Estimating \u03c0 Using Random Points in a Circle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#the-idea","text":"Monte Carlo methods use random sampling to estimate values based on probability. To estimate \\(\\pi\\) , we can simulate a simple geometric setup: - A unit square with sides of length 1. - A quarter circle (or full circle) inscribed inside that square. - By randomly generating points in the square, we can compute the ratio of points that fall inside the circle. - This ratio helps us estimate \\(\\pi\\) using geometry.","title":"The Idea"},{"location":"1%20Physics/6%20Statistics/Problem_2/#step-by-step-geometric-insight","text":"Consider: - A unit circle centered at the origin \\((0, 0)\\) , so the radius \\(r = 1\\) . - A square bounding this circle, ranging from \\((-1, -1)\\) to \\((1, 1)\\) . - Area of the circle: \\(\\pi r^2 = \\pi \\cdot 1^2 = \\pi\\) . - Area of the square: \\((2 \\cdot r)^2 = 4\\) . The theoretical ratio of the areas is: \\[ \\frac{\\text{Area of Circle}}{\\text{Area of Square}} = \\frac{\\pi}{4} \\] If we randomly generate points in the square, the fraction that fall inside the circle should approach this ratio: \\[ \\frac{\\text{Points in Circle}}{\\text{Total Points}} \\approx \\frac{\\pi}{4} \\]","title":"Step-by-Step Geometric Insight"},{"location":"1%20Physics/6%20Statistics/Problem_2/#estimating","text":"Solving for \\(\\pi\\) : \\[ \\pi \\approx 4 \\cdot \\left( \\frac{\\text{Points inside the circle}}{\\text{Total points}} \\right) \\] This estimate becomes more accurate as the number of points increases.","title":"Estimating \u03c0"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-2-estimating-using-buffons-needle","text":"","title":"Part 2: Estimating \u03c0 Using Buffon\u2019s Needle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-theoretical-foundation-buffons-needle-problem","text":"","title":"1. Theoretical Foundation: Buffon\u2019s Needle Problem"},{"location":"1%20Physics/6%20Statistics/Problem_2/#what-is-buffons-needle","text":"Buffon\u2019s Needle is a classic probability problem first posed by Georges-Louis Leclerc, Comte de Buffon in the 18th century. It shows how we can estimate the value of \\(\\pi\\) using a purely geometric probability experiment.","title":"What Is Buffon\u2019s Needle?"},{"location":"1%20Physics/6%20Statistics/Problem_2/#the-setup","text":"Imagine a floor with parallel lines spaced \\(d\\) units apart. Now, suppose we randomly drop a needle of length \\(L\\) onto the floor. Some needles will cross one of the lines, and some won\u2019t.","title":"The Setup"},{"location":"1%20Physics/6%20Statistics/Problem_2/#key-assumptions","text":"The needle length \\(L\\) is less than or equal to the distance between lines \\(d\\) . Each drop is completely random in both: The center position of the needle. The angle the needle forms with respect to the lines.","title":"Key Assumptions"},{"location":"1%20Physics/6%20Statistics/Problem_2/#theoretical-probability-of-a-crossing","text":"The probability that the needle crosses a line is: \\[ P = \\frac{2L}{\\pi d} \\] Where: - \\(L\\) : Needle length, - \\(d\\) : Distance between lines, - \\(\\pi\\) : The constant we aim to estimate.","title":"Theoretical Probability of a Crossing"},{"location":"1%20Physics/6%20Statistics/Problem_2/#use-simulation-to-estimate","text":"If we perform the experiment \\(N\\) times and observe \\(C\\) crossings, then the probability is approximated as: \\[ P \\approx \\frac{C}{N} \\] Substitute into the formula for \\(P\\) and solve for \\(\\pi\\) : \\[ \\frac{C}{N} \\approx \\frac{2L}{\\pi d} \\quad \\Rightarrow \\quad \\pi \\approx \\frac{2L \\cdot N}{d \\cdot C} \\]","title":"Use Simulation to Estimate \u03c0"},{"location":"1%20Physics/6%20Statistics/Problem_2/#final-estimation-formula","text":"\\[ \\pi \\approx \\frac{2 \\cdot L \\cdot N}{d \\cdot C} \\] Where: - \\(L\\) : Needle length, - \\(d\\) : Distance between lines, - \\(N\\) : Number of throws (total drops), - \\(C\\) : Number of crossings.","title":"Final Estimation Formula"},{"location":"1%20Physics/6%20Statistics/Problem_2/#_1","text":"","title":""},{"location":"1%20Physics/6%20Statistics/Problem_2/#simulations-part-1","text":"","title":"Simulations (Part 1)"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-monte-carlo-simulation-to-estimate","text":"import numpy as np import matplotlib.pyplot as plt # Number of random points N = 10000 # Generate random (x, y) points in the square [-1, 1] \u00d7 [-1, 1] x = np.random.uniform(-1, 1, N) y = np.random.uniform(-1, 1, N) # Calculate distance from origin (0, 0) dist = np.sqrt(x**2 + y**2) # Count how many points fall inside the unit circle (r <= 1) inside_circle = dist <= 1 n_inside = np.sum(inside_circle) # Estimate \u03c0 pi_estimate = 4 * n_inside / N # Print result print(f\"Estimated \u03c0 with {N} points: {pi_estimate:.6f}\") # --- Optional: Plot points --- plt.figure(figsize=(6,6)) plt.scatter(x[inside_circle], y[inside_circle], color='green', s=1, label='Inside Circle') plt.scatter(x[~inside_circle], y[~inside_circle], color='red', s=1, label='Outside Circle') circle = plt.Circle((0, 0), 1, color='black', fill=False) plt.gca().add_patch(circle) plt.gca().set_aspect('equal') plt.title(f\"Monte Carlo Estimation of \u03c0\\nEstimated \u03c0 \u2248 {pi_estimate:.6f}\") plt.legend() plt.xlabel(\"x\") plt.ylabel(\"y\") plt.grid(True) plt.show()","title":"1. Monte Carlo Simulation to Estimate \u03c0"},{"location":"1%20Physics/6%20Statistics/Problem_2/#how-it-works","text":"Points are randomly scattered in a square. We use the circle equation \\( \\(x^2 + y^2 \\leq 1\\) \\) to determine if they land inside the unit circle. The ratio of inside points to total points approximates \\(\\pi/4\\) , which we scale by 4 to estimate \\(\\pi\\) .","title":"How It Works"},{"location":"1%20Physics/6%20Statistics/Problem_2/#observations","text":"With small \\(N\\) , results vary (more noise). With large \\(N\\) , estimate converges to true \\(\\pi \\approx 3.1416\\) . Visually, we can see the points inside the circle forming a filled disk.","title":"Observations"},{"location":"1%20Physics/6%20Statistics/Problem_2/#_2","text":"","title":""},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-visualization-of-monte-carlo-points","text":"import numpy as np import matplotlib.pyplot as plt # Number of points N = 5000 # Generate random (x, y) in square [-1, 1] x [-1, 1] x = np.random.uniform(-1, 1, N) y = np.random.uniform(-1, 1, N) # Determine if inside the unit circle r_squared = x**2 + y**2 inside = r_squared <= 1 # Plot setup plt.figure(figsize=(6, 6)) plt.scatter(x[inside], y[inside], color='limegreen', s=2, label='Inside Circle') plt.scatter(x[~inside], y[~inside], color='tomato', s=2, label='Outside Circle') # Add the actual circle boundary circle = plt.Circle((0, 0), 1, color='black', fill=False, linestyle='--', linewidth=1.5) plt.gca().add_patch(circle) # Aesthetics plt.title(\"Monte Carlo Simulation: Points in Unit Circle\", fontsize=14, weight='bold') plt.xlabel(\"x\") plt.ylabel(\"y\") plt.axis('equal') plt.xlim(-1, 1) plt.ylim(-1, 1) plt.legend() plt.grid(True) plt.show()","title":"2. Visualization of Monte Carlo Points"},{"location":"1%20Physics/6%20Statistics/Problem_2/#_3","text":"","title":""},{"location":"1%20Physics/6%20Statistics/Problem_2/#3-analysis-of-convergence-in-monte-carlo-estimation-of","text":"import numpy as np import matplotlib.pyplot as plt # Target: real value of \u03c0 true_pi = np.pi # Simulate increasing numbers of points sample_sizes = np.logspace(2, 6, num=20, dtype=int) # from 100 to 1,000,000 pi_estimates = [] for N in sample_sizes: x = np.random.uniform(-1, 1, N) y = np.random.uniform(-1, 1, N) inside = (x**2 + y**2) <= 1 pi_est = 4 * np.sum(inside) / N pi_estimates.append(pi_est) # Plot convergence plt.figure(figsize=(10, 5)) plt.plot(sample_sizes, pi_estimates, marker='o', linestyle='-', label='Estimated \u03c0') plt.axhline(true_pi, color='red', linestyle='--', label='Actual \u03c0') plt.xscale('log') plt.xlabel(\"Number of Points (log scale)\") plt.ylabel(\"Estimated \u03c0\") plt.title(\"Convergence of Monte Carlo \u03c0 Estimate\") plt.grid(True, which='both', linestyle='--', alpha=0.6) plt.legend() plt.tight_layout() plt.show()","title":"3. Analysis of Convergence in Monte Carlo Estimation of \ud835\udf0b"},{"location":"1%20Physics/6%20Statistics/Problem_2/#observations_1","text":"Sample Size (N) Behavior Small \\(N\\) (e.g. 100) Estimate fluctuates significantly Moderate \\(N\\) (e.g. 1,000\u201310,000) Estimate stabilizes but with visible noise Large \\(N\\) (\u2265 100,000) Estimate converges closer to \\(\\pi \\approx 3.1416\\)","title":"Observations"},{"location":"1%20Physics/6%20Statistics/Problem_2/#discussion-convergence-rate","text":"Monte Carlo methods converge slowly: \\[ \\text{Error} \\propto \\frac{1}{\\sqrt{N}} \\] This means to reduce error by 10\u00d7, you need 100\u00d7 more points. Variance of estimate decreases with larger sample sizes, but at diminishing returns. Convergence is stochastic\u2014each run gives slightly different results.","title":"Discussion: Convergence Rate"},{"location":"1%20Physics/6%20Statistics/Problem_2/#computational-considerations","text":"Factor Impact \\(N\\) (sample size) Larger \\(N\\) improves accuracy Runtime Increases linearly with \\(N\\) Memory Can be a limit with large arrays Random seed Affects reproducibility For accurate results in practice: use \\(N \\geq 10^5\\) , and consider repeating runs and averaging.","title":"Computational Considerations"},{"location":"1%20Physics/6%20Statistics/Problem_2/#_4","text":"","title":""},{"location":"1%20Physics/6%20Statistics/Problem_2/#simulations-part-2","text":"","title":"Simulations (Part 2)"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-simulation-of-needle-drops","text":"import numpy as np # Parameters L = 1.0 # needle length d = 2.0 # distance between lines (must be >= L) N = 10000 # number of needle drops # Simulation: generate N random drops x_centers = np.random.uniform(0, d / 2, N) # distance from needle center to nearest line theta = np.random.uniform(0, np.pi / 2, N) # angle between needle and lines # A crossing occurs if the vertical component exceeds x_center crossings = x_centers <= (L / 2) * np.sin(theta) C = np.sum(crossings) # Estimate \u03c0 if C > 0: pi_estimate = (2 * L * N) / (d * C) print(f\"Estimated \u03c0 (Buffon's Needle, N={N}): {pi_estimate:.6f}\") else: print(\"No crossings detected \u2014 increase N or adjust parameters.\")","title":"1. Simulation of Needle Drops"},{"location":"1%20Physics/6%20Statistics/Problem_2/#how-it-works_1","text":"\\(x_{\\text{center}}\\) : Random vertical distance from the needle\u2019s center to the closest line. \\(\\theta\\) : Random angle between the needle and the lines (uniformly distributed from 0 to \\(\\pi/2\\) ). A crossing happens when the projection of half the needle\u2019s length is long enough to touch a line, i.e.: \\[ \\frac{L}{2} \\cdot \\sin(\\theta) \\geq x_{\\text{center}} \\]","title":"How It Works"},{"location":"1%20Physics/6%20Statistics/Problem_2/#result","text":"We\u2019ll get a printout like: Estimated \u03c0 (Buffon's Needle, N=10000): 3.168568 Which will improve with higher \\(N\\) due to the law of large numbers.","title":"Result"},{"location":"1%20Physics/6%20Statistics/Problem_2/#_5","text":"","title":""},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-visualization-of-buffons-needle-simulation","text":"import numpy as np import matplotlib.pyplot as plt # Parameters L = 1.0 # needle length d = 2.0 # distance between parallel lines N = 200 # number of needles to plot (for clarity) # Generate random center positions and angles x_centers = np.random.uniform(0, d, N) y_centers = np.random.uniform(0, 10, N) # extend vertically to see multiple lines theta = np.random.uniform(0, np.pi, N) # angle in radians # Compute needle endpoints x1 = x_centers - (L / 2) * np.cos(theta) x2 = x_centers + (L / 2) * np.cos(theta) y1 = y_centers - (L / 2) * np.sin(theta) y2 = y_centers + (L / 2) * np.sin(theta) # Check which needles cross a line crossings = ((np.floor(x1 / d) != np.floor(x2 / d))) # Plot plt.figure(figsize=(8, 10)) # Draw horizontal parallel lines num_lines = int(np.ceil(max(y_centers) + L)) for k in range(0, num_lines): plt.axhline(k * d, color='black', linewidth=0.5, alpha=0.5) # Plot needles for i in range(N): color = 'crimson' if crossings[i] else 'gray' plt.plot([x1[i], x2[i]], [y1[i], y2[i]], color=color, linewidth=1.5) # Aesthetics plt.title(\"Buffon\u2019s Needle Simulation: Needle Crossings\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.axis(\"equal\") plt.xlim(0, d) plt.ylim(0, max(y_centers) + L) plt.grid(False) plt.show()","title":"2. Visualization of Buffon\u2019s Needle Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#plot-description","text":"Black horizontal lines = floor lines spaced by \\(d\\) . Each line segment = a needle dropped at a random angle and position. Red needles = crossed a line. Gray needles = did not cross a line. This visual lets viewers see the randomness and how the crossing rate relates to estimating \\(\\pi\\) .","title":"Plot Description"},{"location":"1%20Physics/6%20Statistics/Problem_2/#_6","text":"","title":""},{"location":"1%20Physics/6%20Statistics/Problem_2/#3-track-convergence-of-buffons-needle","text":"import numpy as np import matplotlib.pyplot as plt # Parameters L = 1.0 d = 2.0 true_pi = np.pi # Logarithmically increasing sample sizes sample_sizes = np.logspace(2, 5, num=15, dtype=int) # from 100 to 100,000 pi_estimates_buffon = [] # Simulate and estimate \u03c0 for each sample size for N in sample_sizes: x_centers = np.random.uniform(0, d / 2, N) theta = np.random.uniform(0, np.pi / 2, N) crossings = x_centers <= (L / 2) * np.sin(theta) C = np.sum(crossings) if C > 0: pi_est = (2 * L * N) / (d * C) else: pi_est = np.nan # Avoid division by zero pi_estimates_buffon.append(pi_est) # Plot convergence plt.figure(figsize=(10, 5)) plt.plot(sample_sizes, pi_estimates_buffon, marker='o', label=\"Buffon's Needle\") plt.axhline(true_pi, color='red', linestyle='--', label='Actual \u03c0') plt.xscale('log') plt.xlabel(\"Number of Needle Drops (log scale)\") plt.ylabel(\"Estimated \u03c0\") plt.title(\"Convergence of Buffon\u2019s Needle Estimate\") plt.legend() plt.grid(True, which='both', linestyle='--', alpha=0.5) plt.tight_layout() plt.show()","title":"3. Track Convergence of Buffon\u2019s Needle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#interpretation-of-results","text":"","title":"Interpretation of Results"},{"location":"1%20Physics/6%20Statistics/Problem_2/#convergence-behavior","text":"Sample Size Behavior Small \\(N\\) (<1,000) High variability, poor estimate Moderate \\(N\\) Rough approximation Large \\(N\\) (\u226510,000) Gradual convergence toward \\(\\pi\\) The estimation converges slowly due to random angle dependence. Like the circle method, accuracy improves as \\(N \\to \\infty\\)","title":"Convergence Behavior"},{"location":"1%20Physics/6%20Statistics/Problem_2/#_7","text":"","title":""},{"location":"1%20Physics/6%20Statistics/Problem_2/#comparison-buffons-needle-vs-circle-based-method","text":"Feature Circle-Based Method Buffon\u2019s Needle Convergence rate \\(\\propto \\frac{1}{\\sqrt{N}}\\) \\(\\propto \\frac{1}{\\sqrt{N}}\\) Variance Lower Higher (due to sine in denominator) Visual intuition Clear geometry (circle area) Historical, less intuitive Implementation Very simple Slightly more complex Practical accuracy More stable More noisy without very large \\(N\\)","title":"Comparison: Buffon\u2019s Needle vs. Circle-Based Method"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}