{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"1. Theoretical Foundation: Equations of Motion Projectile motion can be understood by decomposing it into horizontal and vertical components. Assuming no air resistance and that the projectile is launched from ground level, the motion is governed by the following kinematic equations: Horizontal Motion Velocity: \\[ v_x = v_0 \\cdot \\cos(\\theta) \\] Displacement: \\[ x(t) = v_0 \\cdot \\cos(\\theta) \\cdot t \\] Vertical Motion Velocity: \\[ v_y = v_0 \\cdot \\sin(\\theta) - g \\cdot t \\] Displacement: \\[ y(t) = v_0 \\cdot \\sin(\\theta) \\cdot t - \\frac{1}{2} g \\cdot t^2 \\] Here: \\(v_0\\) is the initial launch speed. \\(\\theta\\) is the angle of projection. \\(g\\) is the acceleration due to gravity (approximately 9.8 m/s\u00b2). \\(t\\) is the time elapsed. The time of flight \\(T\\) can be found by setting \\(y(T) = 0\\) : \\[ 0 = v_0 \\cdot \\sin(\\theta) \\cdot T - \\frac{1}{2} g \\cdot T^2 \\] Solving for \\(T\\) : \\[ T = \\frac{2 v_0 \\cdot \\sin(\\theta)}{g} \\] The range \\(R\\) , which is the horizontal distance traveled, is then: \\[ R = x(T) = v_0 \\cdot \\cos(\\theta) \\cdot T = \\frac{v_0^2 \\cdot \\sin(2\\theta)}{g} \\] This equation shows that the range depends on both the initial speed and the angle of projection. 2. Analysis of the Range The horizontal range \\(R\\) of a projectile is influenced by several factors, including the angle of projection \\(\\theta\\) , the initial velocity \\(v_0\\) , and the acceleration due to gravity \\(g\\) . Let's analyze how each of these parameters affects the range. 1. Dependence on the Angle of Projection The range equation for a projectile launched from ground level is: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This equation indicates that the range depends on \\(\\sin(2\\theta)\\) : Maximum Range: The function \\(\\sin(2\\theta)\\) reaches its maximum value of 1 when \\(2\\theta = 90^\\circ\\) , or \\(\\theta = 45^\\circ\\) . Therefore, the projectile achieves its maximum range when launched at a 45-degree angle. Symmetric Angles: Angles equidistant from 45 degrees (e.g., 30\u00b0 and 60\u00b0) yield the same range because \\(\\sin(60^\\circ) = \\sin(120^\\circ)\\) . However, the trajectories differ; a lower angle results in a flatter trajectory with shorter flight time, while a higher angle produces a steeper trajectory with longer flight time. 2. Influence of Initial Velocity The initial velocity \\(v_0\\) has a quadratic effect on the range: Direct Relationship: Since \\(R \\propto v_0^2\\) , doubling the initial velocity quadruples the range. This quadratic relationship underscores the significant impact of initial speed on how far the projectile travels. 3. Effect of Gravitational Acceleration Gravity \\(g\\) inversely affects the range: Inverse Relationship: An increase in gravitational acceleration results in a decrease in range. For instance, on the Moon, where gravity is weaker than on Earth, a projectile would travel farther than it would with the same initial conditions on Earth. 3. Practical Applications Projectile motion models, while foundational in physics, often assume ideal conditions such as uniform terrain and negligible air resistance. However, real-world scenarios frequently involve complexities like uneven terrain and aerodynamic forces. Adapting the basic projectile motion model to account for these factors enhances its applicability across various fields. 1. Basic Projectile Motion (Neglecting Air Resistance) Time of Flight (T): \\[ T = \\frac{2 v_0 \\sin(\\theta)}{g} \\] Maximum Height (H): \\[ H = \\frac{(v_0 \\sin(\\theta))^2}{2g} \\] Horizontal Range (R): \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] The range is maximized when \\(\\theta = 45^\\circ\\) . Where: - \\(v_0\\) = initial velocity - \\(\\theta\\) = launch angle - \\(g\\) = acceleration due to gravity 2. Uneven Terrain When launching from a height \\(y_0\\) , the range equation adjusts to: \\[ R = \\frac{v_0 \\cos(\\theta)}{g} \\left( v_0 \\sin(\\theta) + \\sqrt{(v_0 \\sin(\\theta))^2 + 2 g y_0} \\right) \\] 3. Air Resistance Accounting for air resistance complicates the equations, often requiring numerical methods for precise solutions. However, for small projectiles at high speeds, the range \\(R\\) can be approximated by: \\[ R \\approx \\frac{v_0 v_t}{g} \\] Where \\(v_t\\) is the terminal velocity. 4. Implementation import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # Acceleration due to gravity (m/s\u00b2) # Function to calculate the range of a projectile def calculate_range(v0, theta): theta_rad = np.radians(theta) range = (v0**2) * np.sin(2 * theta_rad) / g return range # Function to plot range vs. launch angle for different initial velocities def plot_range_vs_angle(initial_velocities, angles): plt.figure(figsize=(10, 6)) for v in initial_velocities: ranges = [calculate_range(v, angle) for angle in angles] plt.plot(angles, ranges, label=f'v0 = {v} m/s') plt.title('Projectile Range vs. Launch Angle') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (meters)') plt.legend() plt.grid(True) plt.show() # Function to simulate and plot projectile motion def plot_trajectory(v0, theta): theta_rad = np.radians(theta) t_flight = 2 * v0 * np.sin(theta_rad) / g t = np.linspace(0, t_flight, num=500) x = v0 * np.cos(theta_rad) * t y = v0 * np.sin(theta_rad) * t - 0.5 * g * t**2 plt.plot(x, y, label=f'v0 = {v0} m/s, \u03b8 = {theta}\u00b0') # Main execution if __name__ == \"__main__\": # Parameters initial_velocities = [20, 30, 40] # Different initial velocities in m/s angles = np.linspace(0, 90, num=91) # Angles from 0 to 90 degrees # Plot range vs. launch angle for different initial velocities plot_range_vs_angle(initial_velocities, angles) # Plot trajectories for different initial conditions plt.figure(figsize=(10, 6)) for v0 in initial_velocities: for theta in [30, 45, 60]: # Example angles plot_trajectory(v0, theta) plt.title('Projectile Motion Trajectories') plt.xlabel('Horizontal Distance (meters)') plt.ylabel('Vertical Distance (meters)') plt.legend() plt.grid(True) plt.show() Explanation: Constants and Functions Gravitational Acceleration : The constant \\(g\\) represents gravitational acceleration, typically defined as \\(9.8 \\, \\text{m/s}^2\\) . calculate_range : Computes the horizontal range \\(R\\) for a given initial velocity \\(v_0\\) and launch angle \\(\\theta\\) . The standard formula is: $$ R = \\frac{v_0^2 \\sin(2\\theta)}{g} $$ plot_range_vs_angle : Generates a plot of range \\(R\\) versus launch angle \\(\\theta\\) for a list of initial velocities \\(v_0\\) . This visualizes how \\(R\\) peaks at \\(\\theta = 45^\\circ\\) and varies with \\(v_0\\) . plot_trajectory : Simulates and plots the projectile\u2019s trajectory ( \\(x-y\\) path) for given initial conditions. The parametric equations are: $$ x(t) = v_0 \\cos(\\theta) \\cdot t $$ $$ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 $$ Main Execution The simulation follows these steps: Input Definition : A list of initial velocities \\(v_0\\) is defined (e.g., [ \\(10, 20, 30\\) ] m/s). A range of launch angles \\(\\theta\\) is specified (e.g., \\(0^\\circ\\) to \\(90^\\circ\\) in increments). Range Visualization : The plot_range_vs_angle function is called to plot \\(R\\) versus \\(\\theta\\) for each \\(v_0\\) . This shows the maximum range at \\(\\theta = 45^\\circ\\) and the quadratic effect of \\(v_0\\) . Trajectory Visualization : The plot_trajectory function plots trajectories for combinations of the specified \\(v_0\\) values and example angles: \\(30^\\circ\\) , \\(45^\\circ\\) , and \\(60^\\circ\\) . This illustrates differences in height, range, and flight time.","title":"1. Theoretical Foundation: Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation-equations-of-motion","text":"Projectile motion can be understood by decomposing it into horizontal and vertical components. Assuming no air resistance and that the projectile is launched from ground level, the motion is governed by the following kinematic equations:","title":"1. Theoretical Foundation: Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-motion","text":"Velocity: \\[ v_x = v_0 \\cdot \\cos(\\theta) \\] Displacement: \\[ x(t) = v_0 \\cdot \\cos(\\theta) \\cdot t \\]","title":"Horizontal Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#vertical-motion","text":"Velocity: \\[ v_y = v_0 \\cdot \\sin(\\theta) - g \\cdot t \\] Displacement: \\[ y(t) = v_0 \\cdot \\sin(\\theta) \\cdot t - \\frac{1}{2} g \\cdot t^2 \\] Here: \\(v_0\\) is the initial launch speed. \\(\\theta\\) is the angle of projection. \\(g\\) is the acceleration due to gravity (approximately 9.8 m/s\u00b2). \\(t\\) is the time elapsed. The time of flight \\(T\\) can be found by setting \\(y(T) = 0\\) : \\[ 0 = v_0 \\cdot \\sin(\\theta) \\cdot T - \\frac{1}{2} g \\cdot T^2 \\] Solving for \\(T\\) : \\[ T = \\frac{2 v_0 \\cdot \\sin(\\theta)}{g} \\] The range \\(R\\) , which is the horizontal distance traveled, is then: \\[ R = x(T) = v_0 \\cdot \\cos(\\theta) \\cdot T = \\frac{v_0^2 \\cdot \\sin(2\\theta)}{g} \\] This equation shows that the range depends on both the initial speed and the angle of projection.","title":"Vertical Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"The horizontal range \\(R\\) of a projectile is influenced by several factors, including the angle of projection \\(\\theta\\) , the initial velocity \\(v_0\\) , and the acceleration due to gravity \\(g\\) . Let's analyze how each of these parameters affects the range.","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-dependence-on-the-angle-of-projection","text":"The range equation for a projectile launched from ground level is: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This equation indicates that the range depends on \\(\\sin(2\\theta)\\) : Maximum Range: The function \\(\\sin(2\\theta)\\) reaches its maximum value of 1 when \\(2\\theta = 90^\\circ\\) , or \\(\\theta = 45^\\circ\\) . Therefore, the projectile achieves its maximum range when launched at a 45-degree angle. Symmetric Angles: Angles equidistant from 45 degrees (e.g., 30\u00b0 and 60\u00b0) yield the same range because \\(\\sin(60^\\circ) = \\sin(120^\\circ)\\) . However, the trajectories differ; a lower angle results in a flatter trajectory with shorter flight time, while a higher angle produces a steeper trajectory with longer flight time.","title":"1. Dependence on the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-influence-of-initial-velocity","text":"The initial velocity \\(v_0\\) has a quadratic effect on the range: Direct Relationship: Since \\(R \\propto v_0^2\\) , doubling the initial velocity quadruples the range. This quadratic relationship underscores the significant impact of initial speed on how far the projectile travels.","title":"2. Influence of Initial Velocity"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-effect-of-gravitational-acceleration","text":"Gravity \\(g\\) inversely affects the range: Inverse Relationship: An increase in gravitational acceleration results in a decrease in range. For instance, on the Moon, where gravity is weaker than on Earth, a projectile would travel farther than it would with the same initial conditions on Earth.","title":"3. Effect of Gravitational Acceleration"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Projectile motion models, while foundational in physics, often assume ideal conditions such as uniform terrain and negligible air resistance. However, real-world scenarios frequently involve complexities like uneven terrain and aerodynamic forces. Adapting the basic projectile motion model to account for these factors enhances its applicability across various fields.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-basic-projectile-motion-neglecting-air-resistance","text":"Time of Flight (T): \\[ T = \\frac{2 v_0 \\sin(\\theta)}{g} \\] Maximum Height (H): \\[ H = \\frac{(v_0 \\sin(\\theta))^2}{2g} \\] Horizontal Range (R): \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] The range is maximized when \\(\\theta = 45^\\circ\\) . Where: - \\(v_0\\) = initial velocity - \\(\\theta\\) = launch angle - \\(g\\) = acceleration due to gravity","title":"1. Basic Projectile Motion (Neglecting Air Resistance)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-uneven-terrain","text":"When launching from a height \\(y_0\\) , the range equation adjusts to: \\[ R = \\frac{v_0 \\cos(\\theta)}{g} \\left( v_0 \\sin(\\theta) + \\sqrt{(v_0 \\sin(\\theta))^2 + 2 g y_0} \\right) \\]","title":"2. Uneven Terrain"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-air-resistance","text":"Accounting for air resistance complicates the equations, often requiring numerical methods for precise solutions. However, for small projectiles at high speeds, the range \\(R\\) can be approximated by: \\[ R \\approx \\frac{v_0 v_t}{g} \\] Where \\(v_t\\) is the terminal velocity.","title":"3. Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # Acceleration due to gravity (m/s\u00b2) # Function to calculate the range of a projectile def calculate_range(v0, theta): theta_rad = np.radians(theta) range = (v0**2) * np.sin(2 * theta_rad) / g return range # Function to plot range vs. launch angle for different initial velocities def plot_range_vs_angle(initial_velocities, angles): plt.figure(figsize=(10, 6)) for v in initial_velocities: ranges = [calculate_range(v, angle) for angle in angles] plt.plot(angles, ranges, label=f'v0 = {v} m/s') plt.title('Projectile Range vs. Launch Angle') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (meters)') plt.legend() plt.grid(True) plt.show() # Function to simulate and plot projectile motion def plot_trajectory(v0, theta): theta_rad = np.radians(theta) t_flight = 2 * v0 * np.sin(theta_rad) / g t = np.linspace(0, t_flight, num=500) x = v0 * np.cos(theta_rad) * t y = v0 * np.sin(theta_rad) * t - 0.5 * g * t**2 plt.plot(x, y, label=f'v0 = {v0} m/s, \u03b8 = {theta}\u00b0') # Main execution if __name__ == \"__main__\": # Parameters initial_velocities = [20, 30, 40] # Different initial velocities in m/s angles = np.linspace(0, 90, num=91) # Angles from 0 to 90 degrees # Plot range vs. launch angle for different initial velocities plot_range_vs_angle(initial_velocities, angles) # Plot trajectories for different initial conditions plt.figure(figsize=(10, 6)) for v0 in initial_velocities: for theta in [30, 45, 60]: # Example angles plot_trajectory(v0, theta) plt.title('Projectile Motion Trajectories') plt.xlabel('Horizontal Distance (meters)') plt.ylabel('Vertical Distance (meters)') plt.legend() plt.grid(True) plt.show()","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#explanation","text":"","title":"Explanation:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#constants-and-functions","text":"Gravitational Acceleration : The constant \\(g\\) represents gravitational acceleration, typically defined as \\(9.8 \\, \\text{m/s}^2\\) . calculate_range : Computes the horizontal range \\(R\\) for a given initial velocity \\(v_0\\) and launch angle \\(\\theta\\) . The standard formula is: $$ R = \\frac{v_0^2 \\sin(2\\theta)}{g} $$ plot_range_vs_angle : Generates a plot of range \\(R\\) versus launch angle \\(\\theta\\) for a list of initial velocities \\(v_0\\) . This visualizes how \\(R\\) peaks at \\(\\theta = 45^\\circ\\) and varies with \\(v_0\\) . plot_trajectory : Simulates and plots the projectile\u2019s trajectory ( \\(x-y\\) path) for given initial conditions. The parametric equations are: $$ x(t) = v_0 \\cos(\\theta) \\cdot t $$ $$ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 $$","title":"Constants and Functions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#main-execution","text":"The simulation follows these steps: Input Definition : A list of initial velocities \\(v_0\\) is defined (e.g., [ \\(10, 20, 30\\) ] m/s). A range of launch angles \\(\\theta\\) is specified (e.g., \\(0^\\circ\\) to \\(90^\\circ\\) in increments). Range Visualization : The plot_range_vs_angle function is called to plot \\(R\\) versus \\(\\theta\\) for each \\(v_0\\) . This shows the maximum range at \\(\\theta = 45^\\circ\\) and the quadratic effect of \\(v_0\\) . Trajectory Visualization : The plot_trajectory function plots trajectories for combinations of the specified \\(v_0\\) values and example angles: \\(30^\\circ\\) , \\(45^\\circ\\) , and \\(60^\\circ\\) . This illustrates differences in height, range, and flight time.","title":"Main Execution"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Forced Damped Pendulum Analysis 1. Theoretical Foundation 1: Starting Differential Equation The motion of a forced damped pendulum is governed by the nonlinear second-order differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A \\cos(\\omega t) \\] Where: - \\(\\theta(t)\\) is the angular displacement. - \\(b\\) is the damping coefficient. - \\(g\\) is gravitational acceleration. - \\(L\\) is the length of the pendulum. - \\(A\\) is the amplitude of the external periodic force. - \\(\\omega\\) is the angular frequency of the driving force. 2: Small-Angle Approximation For small angles ( \\(\\theta \\ll 1\\) ), we can use the approximation: \\[ \\sin\\theta \\approx \\theta \\] Substitute into the original equation: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\] This is now a linear second-order nonhomogeneous ODE\u2014a classic form of the driven damped harmonic oscillator. 3: General Solution (Small-Angle Linear Case) The general solution is: \\[ \\theta(t) = \\theta_{\\text{hom}}(t) + \\theta_{\\text{part}}(t) \\] Homogeneous (Natural) Solution Solve: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = 0 \\] This describes the natural damped oscillations. The solution form depends on damping: Underdamped : \\(b^2 < 4 \\frac{g}{L}\\) \\[ \\theta_{\\text{hom}}(t) = e^{-\\frac{b}{2} t} \\left( C_1 \\cos(\\omega_0 t) + C_2 \\sin(\\omega_0 t) \\right) \\] where: \\[ \\omega_0 = \\sqrt{\\frac{g}{L} - \\left(\\frac{b}{2}\\right)^2} \\] Particular (Forced) Solution Try: \\[ \\theta_{\\text{part}}(t) = B \\cos(\\omega t - \\delta) \\] After substitution and solving, you find: \\[ B = \\frac{A}{\\sqrt{\\left(\\frac{g}{L} - \\omega^2\\right)^2 + b^2 \\omega^2}} \\] \\[ \\tan(\\delta) = \\frac{b \\omega}{\\frac{g}{L} - \\omega^2} \\] 4: Resonance Condition Resonance occurs when the driving frequency \\(\\omega\\) approaches the natural frequency of the system: \\[ \\omega_{\\text{res}} \\approx \\sqrt{\\frac{g}{L} - \\frac{b^2}{2}} \\] At or near this frequency, the amplitude \\(B\\) of the steady-state oscillation becomes maximum. For very small damping ( \\(b \\to 0\\) ), the amplitude can become very large. 5: Energy Implications of Resonance When resonance occurs, the driving force efficiently transfers energy to the system. If not limited by damping, this would cause the system's energy to grow unbounded. Damping is essential to balance energy input and loss, resulting in steady-state oscillations instead of infinite growth. 2. Analysis of Dynamics 1. Governing Equation The motion is described by the nonlinear, second-order, driven differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A \\cos(\\omega t) \\] This equation models a forced damped pendulum. We now investigate the effects of its key parameters. 2. Influence of Key Parameters Damping Coefficient \\(b\\) Low damping : Allows larger oscillations; more prone to resonance and chaotic behavior. High damping : Motion dies out or settles into low-amplitude oscillations. Moderate damping : Can lead to steady periodic behavior or quasi-periodic motion, depending on other parameters. Driving Amplitude \\(A\\) Low amplitude : Typically leads to regular, periodic motion. Moderate amplitude : May induce quasi-periodic behavior. High amplitude : Often results in chaotic motion, especially when combined with low damping. Driving Frequency \\(\\omega\\) Near natural frequency : Resonance effects dominate (amplitude peaks). Off-resonance : Motion is often simpler or less energetic. Critical frequencies : Certain values cause the system to become chaotic or display strange attractors. 3. Types of Motion Observed Motion Type Behavior Conditions Periodic Repeats after a fixed time Low \\(A\\) , moderate \\(b\\) , off-resonance Quasi-periodic Almost regular, with shifting phase Slight mismatch between natural and driving frequency Chaotic Unpredictable, sensitive to initial conditions High \\(A\\) , low \\(b\\) , near resonance 4. Detecting Chaos: Physical Interpretations Sensitive Dependence on Initial Conditions : Two almost identical starting points lead to vastly different trajectories. Poincar\u00e9 Section : A stroboscopic map showing whether the system lands on: A single point (periodic). A closed curve (quasi-periodic). Scattered points (chaos). Phase Portrait : A plot of \\(\\theta\\) vs \\(\\dot{\\theta}\\) : Regular motion creates closed loops. Chaos produces tangled trajectories. Bifurcation Diagram : As a parameter (e.g., \\(A\\) or \\(\\omega\\) ) varies, the system transitions from one steady state to multiple, eventually leading to chaos. 5. Interpretation in Real Systems Engineering : Systems must avoid chaotic regimes to prevent mechanical failure (e.g., bridges, engines). Climate Models : Quasi-periodic and chaotic behavior are common due to complex forcing patterns. Biological Rhythms : Can switch between periodic and chaotic under stress or disease. 3. Practical Applications The dynamics of a forced damped pendulum serve as a foundational analogy for many physical and engineered systems where oscillations, damping, and external forces are present. Below are key examples: 1. Energy Harvesting Devices Example : Piezoelectric energy harvesters in shoes, roads, or structural components. Why it's similar : These devices involve damped mechanical systems driven by external periodic forces (e.g., walking). Model connection : - Energy input (walking) corresponds to the driving force: $$ A \\cos(\\omega t) $$ - Damping represents energy losses, and the harvested power corresponds to the amplitude of oscillations. 2. Suspension Bridges & Building Oscillations Example : The infamous Tacoma Narrows Bridge collapse. Why it's similar : Wind acts as a periodic driving force; internal friction and air resistance provide damping. Model connection : The system can be modeled as: $$ \\theta'' + b \\theta' + \\frac{g}{L} \\theta = A \\cos(\\omega t) $$ If the driving frequency matches a structural mode (resonance), large-amplitude oscillations can occur\u2014even leading to failure. 3. Oscillating Electrical Circuits (Driven RLC Circuits) Example : AC circuits with a resistor ( \\(R\\) ), inductor ( \\(L\\) ), and capacitor ( \\(C\\) ) driven by an alternating voltage. Why it's similar : Mathematically analogous to the forced damped pendulum. Electrical analogy : The governing equation is: $$ L \\frac{d^2q}{dt^2} + R \\frac{dq}{dt} + \\frac{1}{C} q = V_0 \\cos(\\omega t) $$ This maps directly to the mechanical form: $$ m \\theta'' + b \\theta' + k \\theta = A \\cos(\\omega t) $$ 4.Implementation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Step 1: Simulation function def forced_damped_pendulum(t, y, b, A, omega): theta, omega_dot = y dtheta_dt = omega_dot domega_dt = -b * omega_dot - (9.81 / 1.0) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] def simulate_pendulum(theta0, omega0, b, A, omega_drive, t_max=100, dt=0.01): t_span = (0, t_max) t_eval = np.arange(0, t_max, dt) y0 = [theta0, omega0] sol = solve_ivp(forced_damped_pendulum, t_span, y0, args=(b, A, omega_drive), t_eval=t_eval, method='RK45') return sol.t, sol.y[0], sol.y[1] # Step 2: Plotting function def plot_all(t, theta, omega_dot, drive_freq): theta = (theta + np.pi) % (2 * np.pi) - np.pi # Normalize # Time series plt.figure(figsize=(10, 4)) plt.plot(t, theta, label='\u03b8(t)') plt.plot(t, omega_dot, label='\u03c9(t)', alpha=0.6) plt.title('Time Series') plt.xlabel('Time (s)') plt.ylabel('Value') plt.legend() plt.grid(True) plt.show() # Phase portrait plt.figure(figsize=(6, 6)) plt.plot(theta, omega_dot, '.', markersize=0.5) plt.title('Phase Portrait') plt.xlabel('\u03b8 (rad)') plt.ylabel('\u03c9 (rad/s)') plt.grid(True) plt.show() # Poincar\u00e9 section T = 2 * np.pi / drive_freq poincare_times = np.arange(0, t[-1], T) poincare_indices = [np.argmin(np.abs(t - pt)) for pt in poincare_times] plt.figure(figsize=(6, 6)) plt.plot(theta[poincare_indices], omega_dot[poincare_indices], 'ro', markersize=3) plt.title('Poincar\u00e9 Section') plt.xlabel('\u03b8 (rad)') plt.ylabel('\u03c9 (rad/s)') plt.grid(True) plt.show() # Step 3: Run the simulation and plot t, theta, omega_dot = simulate_pendulum( theta0=0.2, omega0=0.0, b=0.3, A=1.2, omega_drive=2.0 ) plot_all(t, theta, omega_dot, drive_freq=2.0) Explanation 1. Time Series Plot ( \\(\\theta(t)\\) and \\(\\omega(t)\\) ) This plot shows the angular position \\(\\theta(t)\\) and angular velocity \\(\\omega(t)\\) over time. The oscillations are regular and consistent, suggesting periodic behavior. The system has reached a steady state, where energy input from the driving force is balanced by damping. 2. Phase Portrait ( \\(\\theta\\) vs. \\(\\omega\\) ) This shows how the system evolves in state space. The near-perfect elliptical shape indicates regular, bounded, and stable motion. There is no sign of chaos; instead, the system follows a predictable trajectory. 3. Poincar\u00e9 Section This stroboscopically samples the system once per driving cycle. The clustering of points in a tight region indicates periodic or quasi-periodic behavior. If the system were chaotic, the points would be scattered without forming a structure.","title":"Forced Damped Pendulum Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#forced-damped-pendulum-analysis","text":"","title":"Forced Damped Pendulum Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-starting-differential-equation","text":"The motion of a forced damped pendulum is governed by the nonlinear second-order differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A \\cos(\\omega t) \\] Where: - \\(\\theta(t)\\) is the angular displacement. - \\(b\\) is the damping coefficient. - \\(g\\) is gravitational acceleration. - \\(L\\) is the length of the pendulum. - \\(A\\) is the amplitude of the external periodic force. - \\(\\omega\\) is the angular frequency of the driving force.","title":"1: Starting Differential Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-small-angle-approximation","text":"For small angles ( \\(\\theta \\ll 1\\) ), we can use the approximation: \\[ \\sin\\theta \\approx \\theta \\] Substitute into the original equation: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\] This is now a linear second-order nonhomogeneous ODE\u2014a classic form of the driven damped harmonic oscillator.","title":"2: Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-general-solution-small-angle-linear-case","text":"The general solution is: \\[ \\theta(t) = \\theta_{\\text{hom}}(t) + \\theta_{\\text{part}}(t) \\]","title":"3: General Solution (Small-Angle Linear Case)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#homogeneous-natural-solution","text":"Solve: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = 0 \\] This describes the natural damped oscillations. The solution form depends on damping: Underdamped : \\(b^2 < 4 \\frac{g}{L}\\) \\[ \\theta_{\\text{hom}}(t) = e^{-\\frac{b}{2} t} \\left( C_1 \\cos(\\omega_0 t) + C_2 \\sin(\\omega_0 t) \\right) \\] where: \\[ \\omega_0 = \\sqrt{\\frac{g}{L} - \\left(\\frac{b}{2}\\right)^2} \\]","title":"Homogeneous (Natural) Solution"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#particular-forced-solution","text":"Try: \\[ \\theta_{\\text{part}}(t) = B \\cos(\\omega t - \\delta) \\] After substitution and solving, you find: \\[ B = \\frac{A}{\\sqrt{\\left(\\frac{g}{L} - \\omega^2\\right)^2 + b^2 \\omega^2}} \\] \\[ \\tan(\\delta) = \\frac{b \\omega}{\\frac{g}{L} - \\omega^2} \\]","title":"Particular (Forced) Solution"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-resonance-condition","text":"Resonance occurs when the driving frequency \\(\\omega\\) approaches the natural frequency of the system: \\[ \\omega_{\\text{res}} \\approx \\sqrt{\\frac{g}{L} - \\frac{b^2}{2}} \\] At or near this frequency, the amplitude \\(B\\) of the steady-state oscillation becomes maximum. For very small damping ( \\(b \\to 0\\) ), the amplitude can become very large.","title":"4: Resonance Condition"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-energy-implications-of-resonance","text":"When resonance occurs, the driving force efficiently transfers energy to the system. If not limited by damping, this would cause the system's energy to grow unbounded. Damping is essential to balance energy input and loss, resulting in steady-state oscillations instead of infinite growth.","title":"5: Energy Implications of Resonance"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-governing-equation","text":"The motion is described by the nonlinear, second-order, driven differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A \\cos(\\omega t) \\] This equation models a forced damped pendulum. We now investigate the effects of its key parameters.","title":"1. Governing Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-influence-of-key-parameters","text":"","title":"2. Influence of Key Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#damping-coefficient-b","text":"Low damping : Allows larger oscillations; more prone to resonance and chaotic behavior. High damping : Motion dies out or settles into low-amplitude oscillations. Moderate damping : Can lead to steady periodic behavior or quasi-periodic motion, depending on other parameters.","title":"Damping Coefficient \\(b\\)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#driving-amplitude-a","text":"Low amplitude : Typically leads to regular, periodic motion. Moderate amplitude : May induce quasi-periodic behavior. High amplitude : Often results in chaotic motion, especially when combined with low damping.","title":"Driving Amplitude \\(A\\)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#driving-frequency-omega","text":"Near natural frequency : Resonance effects dominate (amplitude peaks). Off-resonance : Motion is often simpler or less energetic. Critical frequencies : Certain values cause the system to become chaotic or display strange attractors.","title":"Driving Frequency \\(\\omega\\)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-types-of-motion-observed","text":"Motion Type Behavior Conditions Periodic Repeats after a fixed time Low \\(A\\) , moderate \\(b\\) , off-resonance Quasi-periodic Almost regular, with shifting phase Slight mismatch between natural and driving frequency Chaotic Unpredictable, sensitive to initial conditions High \\(A\\) , low \\(b\\) , near resonance","title":"3. Types of Motion Observed"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-detecting-chaos-physical-interpretations","text":"Sensitive Dependence on Initial Conditions : Two almost identical starting points lead to vastly different trajectories. Poincar\u00e9 Section : A stroboscopic map showing whether the system lands on: A single point (periodic). A closed curve (quasi-periodic). Scattered points (chaos). Phase Portrait : A plot of \\(\\theta\\) vs \\(\\dot{\\theta}\\) : Regular motion creates closed loops. Chaos produces tangled trajectories. Bifurcation Diagram : As a parameter (e.g., \\(A\\) or \\(\\omega\\) ) varies, the system transitions from one steady state to multiple, eventually leading to chaos.","title":"4. Detecting Chaos: Physical Interpretations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-interpretation-in-real-systems","text":"Engineering : Systems must avoid chaotic regimes to prevent mechanical failure (e.g., bridges, engines). Climate Models : Quasi-periodic and chaotic behavior are common due to complex forcing patterns. Biological Rhythms : Can switch between periodic and chaotic under stress or disease.","title":"5. Interpretation in Real Systems"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"The dynamics of a forced damped pendulum serve as a foundational analogy for many physical and engineered systems where oscillations, damping, and external forces are present. Below are key examples:","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-energy-harvesting-devices","text":"Example : Piezoelectric energy harvesters in shoes, roads, or structural components. Why it's similar : These devices involve damped mechanical systems driven by external periodic forces (e.g., walking). Model connection : - Energy input (walking) corresponds to the driving force: $$ A \\cos(\\omega t) $$ - Damping represents energy losses, and the harvested power corresponds to the amplitude of oscillations.","title":"1. Energy Harvesting Devices"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-suspension-bridges-building-oscillations","text":"Example : The infamous Tacoma Narrows Bridge collapse. Why it's similar : Wind acts as a periodic driving force; internal friction and air resistance provide damping. Model connection : The system can be modeled as: $$ \\theta'' + b \\theta' + \\frac{g}{L} \\theta = A \\cos(\\omega t) $$ If the driving frequency matches a structural mode (resonance), large-amplitude oscillations can occur\u2014even leading to failure.","title":"2. Suspension Bridges &amp; Building Oscillations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-oscillating-electrical-circuits-driven-rlc-circuits","text":"Example : AC circuits with a resistor ( \\(R\\) ), inductor ( \\(L\\) ), and capacitor ( \\(C\\) ) driven by an alternating voltage. Why it's similar : Mathematically analogous to the forced damped pendulum. Electrical analogy : The governing equation is: $$ L \\frac{d^2q}{dt^2} + R \\frac{dq}{dt} + \\frac{1}{C} q = V_0 \\cos(\\omega t) $$ This maps directly to the mechanical form: $$ m \\theta'' + b \\theta' + k \\theta = A \\cos(\\omega t) $$","title":"3. Oscillating Electrical Circuits (Driven RLC Circuits)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4implementation","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Step 1: Simulation function def forced_damped_pendulum(t, y, b, A, omega): theta, omega_dot = y dtheta_dt = omega_dot domega_dt = -b * omega_dot - (9.81 / 1.0) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] def simulate_pendulum(theta0, omega0, b, A, omega_drive, t_max=100, dt=0.01): t_span = (0, t_max) t_eval = np.arange(0, t_max, dt) y0 = [theta0, omega0] sol = solve_ivp(forced_damped_pendulum, t_span, y0, args=(b, A, omega_drive), t_eval=t_eval, method='RK45') return sol.t, sol.y[0], sol.y[1] # Step 2: Plotting function def plot_all(t, theta, omega_dot, drive_freq): theta = (theta + np.pi) % (2 * np.pi) - np.pi # Normalize # Time series plt.figure(figsize=(10, 4)) plt.plot(t, theta, label='\u03b8(t)') plt.plot(t, omega_dot, label='\u03c9(t)', alpha=0.6) plt.title('Time Series') plt.xlabel('Time (s)') plt.ylabel('Value') plt.legend() plt.grid(True) plt.show() # Phase portrait plt.figure(figsize=(6, 6)) plt.plot(theta, omega_dot, '.', markersize=0.5) plt.title('Phase Portrait') plt.xlabel('\u03b8 (rad)') plt.ylabel('\u03c9 (rad/s)') plt.grid(True) plt.show() # Poincar\u00e9 section T = 2 * np.pi / drive_freq poincare_times = np.arange(0, t[-1], T) poincare_indices = [np.argmin(np.abs(t - pt)) for pt in poincare_times] plt.figure(figsize=(6, 6)) plt.plot(theta[poincare_indices], omega_dot[poincare_indices], 'ro', markersize=3) plt.title('Poincar\u00e9 Section') plt.xlabel('\u03b8 (rad)') plt.ylabel('\u03c9 (rad/s)') plt.grid(True) plt.show() # Step 3: Run the simulation and plot t, theta, omega_dot = simulate_pendulum( theta0=0.2, omega0=0.0, b=0.3, A=1.2, omega_drive=2.0 ) plot_all(t, theta, omega_dot, drive_freq=2.0)","title":"4.Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#explanation","text":"","title":"Explanation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-time-series-plot-thetat-and-omegat","text":"This plot shows the angular position \\(\\theta(t)\\) and angular velocity \\(\\omega(t)\\) over time. The oscillations are regular and consistent, suggesting periodic behavior. The system has reached a steady state, where energy input from the driving force is balanced by damping.","title":"1. Time Series Plot (\\(\\theta(t)\\) and \\(\\omega(t)\\))"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-phase-portrait-theta-vs-omega","text":"This shows how the system evolves in state space. The near-perfect elliptical shape indicates regular, bounded, and stable motion. There is no sign of chaos; instead, the system follows a predictable trajectory.","title":"2. Phase Portrait (\\(\\theta\\) vs. \\(\\omega\\))"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-poincare-section","text":"This stroboscopically samples the system once per driving cycle. The clustering of points in a tight region indicates periodic or quasi-periodic behavior. If the system were chaotic, the points would be scattered without forming a structure.","title":"3. Poincar\u00e9 Section"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"1. Derivation of Kepler\u2019s Third Law for Circular Orbits We begin with two key physical laws: 1. Newton's Law of Universal Gravitation \\[ F_{\\text{gravity}} = \\frac{G M m}{r^2} \\] Where: - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of the central body (e.g., planet or star), - \\(m\\) is the mass of the orbiting body, - \\(r\\) is the orbital radius. 2. Centripetal Force for Circular Motion \\[ F_{\\text{centripetal}} = \\frac{m v^2}{r} \\] For a circular orbit, the gravitational force provides the necessary centripetal force, so: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Cancel \\(m\\) (assuming \\(m \\neq 0\\) ) and rearrange: \\[ v^2 = \\frac{G M}{r} \\] Relating Orbital Velocity to Orbital Period Now, relate orbital velocity \\(v\\) to the orbital period \\(T\\) : \\[ v = \\frac{2 \\pi r}{T} \\] Square both sides: \\[ v^2 = \\left( \\frac{2 \\pi r}{T} \\right)^2 = \\frac{4 \\pi^2 r^2}{T^2} \\] Substitute into the previous equation: \\[ \\frac{4 \\pi^2 r^2}{T^2} = \\frac{G M}{r} \\] Multiply both sides by \\(T^2\\) and rearrange: \\[ 4 \\pi^2 r^3 = G M T^2 \\] Finally, solve for \\(T^2\\) : \\[ T^2 = \\frac{4 \\pi^2}{G M} r^3 \\] Final Form (Kepler\u2019s Third Law for Circular Orbits) \\[ T^2 \\propto r^3 \\] This shows that the square of the orbital period is proportional to the cube of the orbital radius, which is exactly Kepler\u2019s Third Law\u2014now derived from Newtonian mechanics. 2. Implications of Kepler\u2019s Third Law in Astronomy The relationship: \\[ T^2 = \\frac{4 \\pi^2}{G M} r^3 \\] connects the orbital period \\(T\\) and the radius \\(r\\) of a body orbiting a much larger mass \\(M\\) . This has profound applications in astronomy: 1. Calculating the Mass of Celestial Bodies Rearranging the formula: \\[ M = \\frac{4 \\pi^2 r^3}{G T^2} \\] This allows astronomers to determine the mass of stars or planets by observing: - The orbital period \\(T\\) of a satellite or planet, - The orbital radius \\(r\\) . Example : Measuring a moon\u2019s orbit around a planet reveals the planet\u2019s mass. 2. Determining Orbital Distances If the mass \\(M\\) of the central object is known, and the period \\(T\\) is measured: \\[ r^3 = \\frac{G M T^2}{4 \\pi^2} \\] This is used to: - Determine planetary distances from stars, - Locate satellites\u2019 positions in Earth\u2019s orbit, - Plan space missions (e.g., calculating transfer orbits). 3. Understanding Planetary Systems Comparing planets within a solar system shows that those farther out orbit more slowly. Confirming Kepler\u2019s law across many systems supports the universal nature of gravity. 4. Applications in Space Missions and Satellites Engineers use this law to place satellites into stable orbits at precise altitudes (e.g., GPS satellites). It\u2019s crucial in designing interplanetary missions, where timing and distance must be exact. 3. Examples and Applications of Kepler\u2019s Third Law Example 1: The Moon\u2019s Orbit Around Earth Observed Orbital Period : \\(T_{\\text{Moon}} \\approx 27.3\\) days = \\(2.36 \\times 10^6\\) seconds Orbital Radius : \\(r \\approx 3.84 \\times 10^8\\) meters Using Kepler\u2019s Third Law: \\[ M_{\\text{Earth}} = \\frac{4 \\pi^2 r^3}{G T^2} \\] Plug in values: - \\(r = 3.84 \\times 10^8 \\, \\text{m}\\) - \\(T = 2.36 \\times 10^6 \\, \\text{s}\\) - \\(G = 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) (gravitational constant) This yields: $$ M_{\\text{Earth}} \\approx 5.97 \\times 10^{24} \\, \\text{kg} $$ This matches the known mass of Earth, confirming the accuracy of the law. Example 2: Planets Orbiting the Sun Planet Orbital Radius (AU) Orbital Period (years) \\(T^2\\) \\(r^3\\) Earth 1.00 1.00 1.00 1.00 Mars 1.52 1.88 3.53 3.51 Jupiter 5.20 11.86 140.7 140.6 Result : \\(T^2 \\approx r^3\\) for all planets, validating Kepler\u2019s Third Law across the Solar System. Application in Space Missions NASA and ESA use these calculations to: - Place satellites in orbit. - Time planetary flybys (e.g., Voyager, Juno). - Determine exoplanet distances and host star masses using orbital data. 4. Python Implementation: Simulating Circular Orbits This simulation will: - Simulate circular orbits for different radii. - Compute orbital periods numerically. - Compare with Kepler\u2019s Third Law: $$ T^2 \\propto r^3 $$ import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # mass of central body (Earth) in kg # Radii for orbits (in meters) radii = np.linspace(7e6, 4.2e7, 100) # from low Earth orbit to geostationary # Calculate periods for each radius using Kepler's Third Law # T = 2\u03c0 * sqrt(r^3 / GM) periods = 2 * np.pi * np.sqrt(radii**3 / (G * M)) # Plotting T^2 vs r^3 to verify linearity T_squared = periods**2 r_cubed = radii**3 plt.figure(figsize=(8, 6)) plt.plot(r_cubed, T_squared, label=r\"$T^2$ vs $r^3$\") plt.xlabel(\"Orbital Radius Cubed ($r^3$) [m\u00b3]\") plt.ylabel(\"Orbital Period Squared ($T^2$) [s\u00b2]\") plt.title(\"Verification of Kepler's Third Law for Circular Orbits\") plt.grid(True) plt.legend() plt.show() 5.Static Visualization of Circular Orbit + Period This simulation will: - Shows a full circular orbit for one satellite around Earth. - Displays Earth as a blue dot and the satellite path in red. - Includes the orbital period in the title for clarity. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # mass of Earth (kg) r = 2.0e7 # orbital radius (m) # Orbital period using Kepler's Third Law T = 2 * np.pi * np.sqrt(r**3 / (G * M)) # seconds # Time array for one full orbit t = np.linspace(0, T, 1000) # Calculate position coordinates x = r * np.cos(2 * np.pi * t / T) y = r * np.sin(2 * np.pi * t / T) # Plotting the orbit plt.figure(figsize=(7, 7)) plt.plot(x, y, label=\"Satellite Orbit\", color='red') plt.scatter(0, 0, color='blue', s=300, label=\"Earth\") plt.title(f\"Circular Orbit (r = {r/1e6:.1f} Mm)\\nOrbital Period = {T/3600:.2f} hours\") plt.xlabel(\"x-position (m)\") plt.ylabel(\"y-position (m)\") plt.axis('equal') plt.grid(True) plt.legend() plt.show() 6. Multiple Orbits + Kepler Verification This simulation will: - Plots multiple orbits at different radii on the same graph for comparison. - Also plots \\(T^2\\) vs \\(r^3\\) for those orbits to confirm Kepler\u2019s Law. - Combines visual clarity and physics verification in one figure. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant M = 5.972e24 # mass of Earth earth_radius = 6.371e6 # Define multiple orbital radii (in meters) radii = np.array([1e7, 1.5e7, 2e7, 2.5e7, 3e7]) # from LEO to geostationary-ish # Prepare figure for orbit plots plt.figure(figsize=(10, 5)) # ---------- Subplot 1: Orbits ---------- plt.subplot(1, 2, 1) theta = np.linspace(0, 2 * np.pi, 500) for r in radii: x = r * np.cos(theta) y = r * np.sin(theta) plt.plot(x, y, label=f\"r = {r/1e6:.1f} Mm\") # Plot Earth earth = plt.Circle((0, 0), earth_radius, color='blue', label=\"Earth\") plt.gca().add_patch(earth) plt.axis('equal') plt.title(\"Circular Orbits of Satellites\") plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.grid(True) plt.legend() # ---------- Subplot 2: Kepler T\u00b2 vs r\u00b3 ---------- T = 2 * np.pi * np.sqrt(radii**3 / (G * M)) T_squared = T**2 r_cubed = radii**3 plt.subplot(1, 2, 2) plt.plot(r_cubed, T_squared, 'o-', color='green') plt.title(\"Verification of Kepler's Third Law\") plt.xlabel(\"Orbital Radius\u00b3 (r\u00b3) [m\u00b3]\") plt.ylabel(\"Orbital Period\u00b2 (T\u00b2) [s\u00b2]\") plt.grid(True) plt.tight_layout() plt.show()","title":"1. Derivation of Kepler\u2019s Third Law for Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-derivation-of-keplers-third-law-for-circular-orbits","text":"We begin with two key physical laws:","title":"1. Derivation of Kepler\u2019s Third Law for Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-newtons-law-of-universal-gravitation","text":"\\[ F_{\\text{gravity}} = \\frac{G M m}{r^2} \\] Where: - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of the central body (e.g., planet or star), - \\(m\\) is the mass of the orbiting body, - \\(r\\) is the orbital radius.","title":"1. Newton's Law of Universal Gravitation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-centripetal-force-for-circular-motion","text":"\\[ F_{\\text{centripetal}} = \\frac{m v^2}{r} \\] For a circular orbit, the gravitational force provides the necessary centripetal force, so: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Cancel \\(m\\) (assuming \\(m \\neq 0\\) ) and rearrange: \\[ v^2 = \\frac{G M}{r} \\]","title":"2. Centripetal Force for Circular Motion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#relating-orbital-velocity-to-orbital-period","text":"Now, relate orbital velocity \\(v\\) to the orbital period \\(T\\) : \\[ v = \\frac{2 \\pi r}{T} \\] Square both sides: \\[ v^2 = \\left( \\frac{2 \\pi r}{T} \\right)^2 = \\frac{4 \\pi^2 r^2}{T^2} \\] Substitute into the previous equation: \\[ \\frac{4 \\pi^2 r^2}{T^2} = \\frac{G M}{r} \\] Multiply both sides by \\(T^2\\) and rearrange: \\[ 4 \\pi^2 r^3 = G M T^2 \\] Finally, solve for \\(T^2\\) : \\[ T^2 = \\frac{4 \\pi^2}{G M} r^3 \\]","title":"Relating Orbital Velocity to Orbital Period"},{"location":"1%20Physics/2%20Gravity/Problem_1/#final-form-keplers-third-law-for-circular-orbits","text":"\\[ T^2 \\propto r^3 \\] This shows that the square of the orbital period is proportional to the cube of the orbital radius, which is exactly Kepler\u2019s Third Law\u2014now derived from Newtonian mechanics.","title":"Final Form (Kepler\u2019s Third Law for Circular Orbits)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-implications-of-keplers-third-law-in-astronomy","text":"The relationship: \\[ T^2 = \\frac{4 \\pi^2}{G M} r^3 \\] connects the orbital period \\(T\\) and the radius \\(r\\) of a body orbiting a much larger mass \\(M\\) . This has profound applications in astronomy:","title":"2. Implications of Kepler\u2019s Third Law in Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-calculating-the-mass-of-celestial-bodies","text":"Rearranging the formula: \\[ M = \\frac{4 \\pi^2 r^3}{G T^2} \\] This allows astronomers to determine the mass of stars or planets by observing: - The orbital period \\(T\\) of a satellite or planet, - The orbital radius \\(r\\) . Example : Measuring a moon\u2019s orbit around a planet reveals the planet\u2019s mass.","title":"1. Calculating the Mass of Celestial Bodies"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-determining-orbital-distances","text":"If the mass \\(M\\) of the central object is known, and the period \\(T\\) is measured: \\[ r^3 = \\frac{G M T^2}{4 \\pi^2} \\] This is used to: - Determine planetary distances from stars, - Locate satellites\u2019 positions in Earth\u2019s orbit, - Plan space missions (e.g., calculating transfer orbits).","title":"2. Determining Orbital Distances"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-understanding-planetary-systems","text":"Comparing planets within a solar system shows that those farther out orbit more slowly. Confirming Kepler\u2019s law across many systems supports the universal nature of gravity.","title":"3. Understanding Planetary Systems"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-applications-in-space-missions-and-satellites","text":"Engineers use this law to place satellites into stable orbits at precise altitudes (e.g., GPS satellites). It\u2019s crucial in designing interplanetary missions, where timing and distance must be exact.","title":"4. Applications in Space Missions and Satellites"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-examples-and-applications-of-keplers-third-law","text":"","title":"3. Examples and Applications of Kepler\u2019s Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-1-the-moons-orbit-around-earth","text":"Observed Orbital Period : \\(T_{\\text{Moon}} \\approx 27.3\\) days = \\(2.36 \\times 10^6\\) seconds Orbital Radius : \\(r \\approx 3.84 \\times 10^8\\) meters Using Kepler\u2019s Third Law: \\[ M_{\\text{Earth}} = \\frac{4 \\pi^2 r^3}{G T^2} \\] Plug in values: - \\(r = 3.84 \\times 10^8 \\, \\text{m}\\) - \\(T = 2.36 \\times 10^6 \\, \\text{s}\\) - \\(G = 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2}\\) (gravitational constant) This yields: $$ M_{\\text{Earth}} \\approx 5.97 \\times 10^{24} \\, \\text{kg} $$ This matches the known mass of Earth, confirming the accuracy of the law.","title":"Example 1: The Moon\u2019s Orbit Around Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-2-planets-orbiting-the-sun","text":"Planet Orbital Radius (AU) Orbital Period (years) \\(T^2\\) \\(r^3\\) Earth 1.00 1.00 1.00 1.00 Mars 1.52 1.88 3.53 3.51 Jupiter 5.20 11.86 140.7 140.6 Result : \\(T^2 \\approx r^3\\) for all planets, validating Kepler\u2019s Third Law across the Solar System.","title":"Example 2: Planets Orbiting the Sun"},{"location":"1%20Physics/2%20Gravity/Problem_1/#application-in-space-missions","text":"NASA and ESA use these calculations to: - Place satellites in orbit. - Time planetary flybys (e.g., Voyager, Juno). - Determine exoplanet distances and host star masses using orbital data.","title":"Application in Space Missions"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-python-implementation-simulating-circular-orbits","text":"This simulation will: - Simulate circular orbits for different radii. - Compute orbital periods numerically. - Compare with Kepler\u2019s Third Law: $$ T^2 \\propto r^3 $$ import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # mass of central body (Earth) in kg # Radii for orbits (in meters) radii = np.linspace(7e6, 4.2e7, 100) # from low Earth orbit to geostationary # Calculate periods for each radius using Kepler's Third Law # T = 2\u03c0 * sqrt(r^3 / GM) periods = 2 * np.pi * np.sqrt(radii**3 / (G * M)) # Plotting T^2 vs r^3 to verify linearity T_squared = periods**2 r_cubed = radii**3 plt.figure(figsize=(8, 6)) plt.plot(r_cubed, T_squared, label=r\"$T^2$ vs $r^3$\") plt.xlabel(\"Orbital Radius Cubed ($r^3$) [m\u00b3]\") plt.ylabel(\"Orbital Period Squared ($T^2$) [s\u00b2]\") plt.title(\"Verification of Kepler's Third Law for Circular Orbits\") plt.grid(True) plt.legend() plt.show()","title":"4. Python Implementation: Simulating Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5static-visualization-of-circular-orbit-period","text":"This simulation will: - Shows a full circular orbit for one satellite around Earth. - Displays Earth as a blue dot and the satellite path in red. - Includes the orbital period in the title for clarity. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # mass of Earth (kg) r = 2.0e7 # orbital radius (m) # Orbital period using Kepler's Third Law T = 2 * np.pi * np.sqrt(r**3 / (G * M)) # seconds # Time array for one full orbit t = np.linspace(0, T, 1000) # Calculate position coordinates x = r * np.cos(2 * np.pi * t / T) y = r * np.sin(2 * np.pi * t / T) # Plotting the orbit plt.figure(figsize=(7, 7)) plt.plot(x, y, label=\"Satellite Orbit\", color='red') plt.scatter(0, 0, color='blue', s=300, label=\"Earth\") plt.title(f\"Circular Orbit (r = {r/1e6:.1f} Mm)\\nOrbital Period = {T/3600:.2f} hours\") plt.xlabel(\"x-position (m)\") plt.ylabel(\"y-position (m)\") plt.axis('equal') plt.grid(True) plt.legend() plt.show()","title":"5.Static Visualization of Circular Orbit + Period"},{"location":"1%20Physics/2%20Gravity/Problem_1/#6-multiple-orbits-kepler-verification","text":"This simulation will: - Plots multiple orbits at different radii on the same graph for comparison. - Also plots \\(T^2\\) vs \\(r^3\\) for those orbits to confirm Kepler\u2019s Law. - Combines visual clarity and physics verification in one figure. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant M = 5.972e24 # mass of Earth earth_radius = 6.371e6 # Define multiple orbital radii (in meters) radii = np.array([1e7, 1.5e7, 2e7, 2.5e7, 3e7]) # from LEO to geostationary-ish # Prepare figure for orbit plots plt.figure(figsize=(10, 5)) # ---------- Subplot 1: Orbits ---------- plt.subplot(1, 2, 1) theta = np.linspace(0, 2 * np.pi, 500) for r in radii: x = r * np.cos(theta) y = r * np.sin(theta) plt.plot(x, y, label=f\"r = {r/1e6:.1f} Mm\") # Plot Earth earth = plt.Circle((0, 0), earth_radius, color='blue', label=\"Earth\") plt.gca().add_patch(earth) plt.axis('equal') plt.title(\"Circular Orbits of Satellites\") plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.grid(True) plt.legend() # ---------- Subplot 2: Kepler T\u00b2 vs r\u00b3 ---------- T = 2 * np.pi * np.sqrt(radii**3 / (G * M)) T_squared = T**2 r_cubed = radii**3 plt.subplot(1, 2, 2) plt.plot(r_cubed, T_squared, 'o-', color='green') plt.title(\"Verification of Kepler's Third Law\") plt.xlabel(\"Orbital Radius\u00b3 (r\u00b3) [m\u00b3]\") plt.ylabel(\"Orbital Period\u00b2 (T\u00b2) [s\u00b2]\") plt.grid(True) plt.tight_layout() plt.show()","title":"6. Multiple Orbits + Kepler Verification"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Escape Velocities and Cosmic Velocities 1. Introduction Escape velocity is the minimum velocity required for an object to escape the gravitational influence of a celestial body, without further propulsion. Beyond escape velocity, the object will not return to the body, assuming no other forces act on it (such as air resistance). There are also several types of cosmic velocities that define specific escape or orbiting conditions in a star system. First Cosmic Velocity ( \\(v_1\\) ) : The velocity required for an object to orbit the celestial body in a circular orbit. Second Cosmic Velocity ( \\(v_2\\) ) : The escape velocity, or the velocity required for an object to break free of a celestial body\u2019s gravitational pull. Third Cosmic Velocity ( \\(v_3\\) ) : The velocity required for an object to escape the gravitational influence of the entire star system. 2. Mathematical Derivations of Cosmic Velocities The formulas for these velocities are derived from Newtonian mechanics, specifically gravitational forces. First Cosmic Velocity ( \\(v_1\\) ) The first cosmic velocity is the velocity required for a body to enter a stable circular orbit around a celestial body. For a circular orbit, the centripetal force is provided by gravity: \\[F_{\\text{gravity}} = F_{\\text{centripetal}}\\] \\[\\frac{G M m}{r^2} = \\frac{m v_1^2}{r}\\] Where: \\(G\\) is the gravitational constant \\(M\\) is the mass of the celestial body (e.g., Earth) \\(m\\) is the mass of the object in orbit \\(r\\) is the radius of orbit \\(v_1\\) is the first cosmic velocity Canceling \\(m\\) from both sides: \\[v_1 = \\sqrt{\\frac{G M}{r}}\\] Second Cosmic Velocity ( \\(v_2\\) ) The second cosmic velocity is the escape velocity\u2014the minimum velocity required for an object to escape the gravitational pull of the celestial body. The energy required to escape is the sum of kinetic and potential energy. The total energy of the object at escape is zero (it reaches an infinite distance with zero velocity). The gravitational potential energy is: \\[U = -\\frac{G M m}{r}\\] The total mechanical energy at the escape point is zero: \\[\\frac{1}{2} m v_2^2 - \\frac{G M m}{r} = 0\\] Solving for \\(v_2\\) : \\[v_2 = \\sqrt{\\frac{2 G M}{r}}\\] Third Cosmic Velocity ( \\(v_3\\) ) The third cosmic velocity is the velocity required to escape the gravitational influence of an entire star system, such as the Sun\u2019s gravitational field. It can be derived from the escape velocity from the star system, considering the distance from the star\u2019s center (usually the distance from the Sun's center to Earth): \\[v_3 = \\sqrt{\\frac{2 G M_{\\text{star}}}{r_{\\text{star}}}}\\] Where: \\(M_{\\text{star}}\\) is the mass of the star (e.g., Sun) \\(r_{\\text{star}}\\) is the distance from the star\u2019s center (for instance, the distance from the Earth to the Sun) 3. Calculations for Different Celestial Bodies Let\u2019s calculate these velocities for Earth, Mars, and Jupiter. The formula for escape velocity and orbital velocity depends on the mass and radius of the celestial body. We will calculate the first and second cosmic velocities, using the following known values: Earth: Mass ( \\(M_{\\text{Earth}}\\) ): \\(5.972 \\times 10^{24} \\, \\text{kg}\\) Radius ( \\(R_{\\text{Earth}}\\) ): \\(6.371 \\times 10^{6} \\, \\text{m}\\) Mars: Mass ( \\(M_{\\text{Mars}}\\) ): \\(0.64171 \\times 10^{24} \\, \\text{kg}\\) Radius ( \\(R_{\\text{Mars}}\\) ): \\(3.396 \\times 10^{6} \\, \\text{m}\\) Jupiter: Mass ( \\(M_{\\text{Jupiter}}\\) ): \\(1.898 \\times 10^{27} \\, \\text{kg}\\) Radius ( \\(R_{\\text{Jupiter}}\\) ): \\(6.991 \\times 10^{7} \\, \\text{m}\\) Using these values, we will compute the first and second cosmic velocities. Advanced Concepts in Escape and Cosmic Velocities 1. Gravitational Potential Energy in a Non-Spherical Potential For non-spherical celestial bodies (e.g., rotating bodies like planets), the gravitational potential energy changes slightly due to the distribution of mass, particularly for objects that are not perfectly spherical. In such cases, the gravitational potential energy \\(U\\) at a distance \\(r\\) from the center of mass can be written as: \\[U = - \\frac{GMm}{r} \\left(1 + \\frac{1}{2} \\frac{r^2}{R_{\\text{eq}}^2} \\right)\\] Where: \\(R_{\\text{eq}}\\) is the equatorial radius of the planet. The term \\(\\frac{r^2}{R_{\\text{eq}}^2}\\) introduces a correction for the planet\u2019s oblateness (flattening at the poles). This formula helps in considering real celestial bodies where \\(r\\) is near the planet\u2019s equator or poles. 2. Relativistic Correction to Escape Velocity When objects move at speeds close to the speed of light, relativistic effects come into play. The relativistic escape velocity \\(v_{\\text{rel}}\\) is given by: \\[v_{\\text{rel}} = \\sqrt{\\frac{2GM}{r} \\left(1 + \\frac{v_{\\text{orbital}}^2}{c^2} \\right)}\\] Where: \\(v_{\\text{orbital}}\\) is the orbital velocity of the object in question. \\(c\\) is the speed of light. At low velocities (non-relativistic), this reduces to the classical escape velocity formula, but for high velocities, the correction term accounts for relativistic effects. 3. Generalized Third Cosmic Velocity The generalized third cosmic velocity \\(v_3\\) accounts for a system where the object must escape not just the gravitational influence of a single star but also overcome the combined gravitational potential of the entire galaxy. For a multi-body system, the escape velocity from a galactic center at a distance \\(r_{\\text{galaxy}}\\) is: \\[v_3 = \\sqrt{\\frac{2 G M_{\\text{galaxy}}}{r_{\\text{galaxy}}} \\left(1 + \\frac{v_{\\text{orbital}}^2}{c^2} \\right)}\\] Where: \\(M_{\\text{galaxy}}\\) is the mass of the galaxy. \\(r_{\\text{galaxy}}\\) is the distance from the galactic center. This formula considers the combined gravitational potential from the star system and the galactic center. 4. The Escape Velocity for a Rotating Body (Centrifugal Force Considerations) For rotating bodies such as Earth, centrifugal forces also play a role in determining the velocity required to escape. The escape velocity \\(v_{\\text{esc}}\\) at the surface of a rotating body, taking into account centrifugal forces at latitude \\(\\phi\\) , is given by: \\[v_{\\text{esc}} = \\sqrt{\\frac{2GM}{r} + \\omega^2 r^2 - 2\\omega r^2 \\sin \\phi \\cos \\phi}\\] Where: \\(\\omega\\) is the angular velocity of the celestial body. \\(r\\) is the radius at a specific latitude. \\(\\phi\\) is the latitude of the object from the axis of rotation (e.g., Earth's surface). This formula takes into account the reduced effective escape velocity due to the centrifugal force at the equator. 5. Gravitational Binding Energy of a Planet For a planet, the gravitational binding energy \\(E_b\\) , or the energy required to disperse a planet's mass to infinity, can be calculated by: \\[E_b = -\\frac{3}{5} \\frac{GM^2}{R}\\] Where: \\(M\\) is the mass of the planet. \\(R\\) is the radius of the planet. This formula provides an understanding of the energy scale needed to disrupt a planet\u2019s gravitational binding. 6. Cosmic Velocities of Earth, Mars, and Jupiter import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_earth = 5.972e24 # Mass of Earth (kg) R_earth = 6.371e6 # Radius of Earth (m) M_mars = 6.39e23 # Mass of Mars (kg) R_mars = 3.390e6 # Radius of Mars (m) M_jupiter = 1.898e27 # Mass of Jupiter (kg) R_jupiter = 6.9911e7 # Radius of Jupiter (m) M_sun = 1.989e30 # Mass of Sun (kg) R_earthSun = 1.496e11 # Distance from earth to sun (m) earth_orbital_velocity = 29780 # earth orbital velocity m/s # Function to calculate first cosmic velocity def first_cosmic_velocity(mass, radius): return np.sqrt(G * mass / radius) # Function to calculate second cosmic velocity (escape velocity) def escape_velocity(mass, radius): return np.sqrt(2 * G * mass / radius) # Calculate velocities v1_earth = first_cosmic_velocity(M_earth, R_earth) v2_earth = escape_velocity(M_earth, R_earth) v1_mars = first_cosmic_velocity(M_mars, R_mars) v2_mars = escape_velocity(M_mars, R_mars) v1_jupiter = first_cosmic_velocity(M_jupiter, R_jupiter) v2_jupiter = escape_velocity(M_jupiter, R_jupiter) v_sunEscape = escape_velocity(M_sun, R_earthSun) v3_earth = np.sqrt(v_sunEscape**2 + earth_orbital_velocity**2) - earth_orbital_velocity # Print results print(f\"Earth: v1 = {v1_earth/1000:.2f} km/s, v2 = {v2_earth/1000:.2f} km/s\") print(f\"Mars: v1 = {v1_mars/1000:.2f} km/s, v2 = {v2_mars/1000:.2f} km/s\") print(f\"Jupiter: v1 = {v1_jupiter/1000:.2f} km/s, v2 = {v2_jupiter/1000:.2f} km/s\") print(f\"Earth: v3 = {v3_earth/1000:.2f} km/s\") # Visualization bodies = ['Earth', 'Mars', 'Jupiter'] v1_values = [v1_earth/1000, v1_mars/1000, v1_jupiter/1000] v2_values = [v2_earth/1000, v2_mars/1000, v2_jupiter/1000] plt.figure(figsize=(10, 6)) plt.bar(bodies, v1_values, label='First Cosmic Velocity (km/s)', alpha=0.7) plt.bar(bodies, v2_values, label='Escape Velocity (km/s)', alpha=0.7) plt.ylabel('Velocity (km/s)') plt.title('Cosmic Velocities for Various Celestial Bodies') plt.legend() plt.show() 7. Cosmic Velocities and Escape Velocity Visualizations import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) c = 299792458 # Speed of light (m/s) M_earth = 5.972e24 # Mass of Earth (kg) R_earth = 6.371e6 # Radius of Earth (m) earth_angular_velocity = 7.27e-5 # Earth's angular velocity (rad/s) # Function to calculate first cosmic velocity def first_cosmic_velocity(mass, radius): return np.sqrt(G * mass / radius) # Function to calculate second cosmic velocity (escape velocity) def escape_velocity(mass, radius): return np.sqrt(2 * G * mass / radius) # Function to calculate relativistic escape velocity def relativistic_escape_velocity(mass, radius): return c * np.sqrt(1 - (1 + 2 * G * mass / (radius * c**2))**-2) # Function to calculate escape velocity in a rotating frame def rotating_escape_velocity(mass, radius, angular_velocity): rotational_velocity = angular_velocity * radius return np.sqrt(2 * G * mass / radius - rotational_velocity**2) # Calculate velocities for Earth v1_earth = first_cosmic_velocity(M_earth, R_earth) v2_earth = escape_velocity(M_earth, R_earth) v_esc_rel_earth = relativistic_escape_velocity(M_earth, R_earth) v_esc_rot_earth = rotating_escape_velocity(M_earth, R_earth, earth_angular_velocity) # Create a bar chart for comparison velocities = { 'First Cosmic': v1_earth / 1000, 'Classical Escape': v2_earth / 1000, 'Relativistic Escape': v_esc_rel_earth / 1000, 'Rotating Escape': v_esc_rot_earth / 1000, } plt.figure(figsize=(10, 6)) plt.bar(velocities.keys(), velocities.values()) plt.ylabel('Velocity (km/s)') plt.title('Cosmic Velocities for Earth') plt.show() # Example: Escape Velocity vs. Radius radii = np.linspace(R_earth, 10 * R_earth, 100) classical_escape = escape_velocity(M_earth, radii) / 1000 relativistic_escape = relativistic_escape_velocity(M_earth, radii) / 1000 plt.figure(figsize=(10, 6)) plt.plot(radii / R_earth, classical_escape, label='Classical Escape') plt.plot(radii / R_earth, relativistic_escape, label='Relativistic Escape') plt.xlabel('Radius (multiples of Earth radius)') plt.ylabel('Escape Velocity (km/s)') plt.title('Escape Velocity vs. Radius') plt.legend() plt.show() # Example: Escape Velocity vs. Angular Velocity angular_velocities = np.linspace(0, 2 * earth_angular_velocity, 100) rotating_escape = rotating_escape_velocity(M_earth, R_earth, angular_velocities) / 1000 plt.figure(figsize=(10, 6)) plt.plot(angular_velocities / earth_angular_velocity, rotating_escape, label='Rotating Escape') plt.xlabel('Angular Velocity (multiples of Earth angular velocity)') plt.ylabel('Escape Velocity (km/s)') plt.title('Escape Velocity vs. Angular Velocity') plt.legend() plt.show()","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-introduction","text":"Escape velocity is the minimum velocity required for an object to escape the gravitational influence of a celestial body, without further propulsion. Beyond escape velocity, the object will not return to the body, assuming no other forces act on it (such as air resistance). There are also several types of cosmic velocities that define specific escape or orbiting conditions in a star system. First Cosmic Velocity ( \\(v_1\\) ) : The velocity required for an object to orbit the celestial body in a circular orbit. Second Cosmic Velocity ( \\(v_2\\) ) : The escape velocity, or the velocity required for an object to break free of a celestial body\u2019s gravitational pull. Third Cosmic Velocity ( \\(v_3\\) ) : The velocity required for an object to escape the gravitational influence of the entire star system.","title":"1. Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-mathematical-derivations-of-cosmic-velocities","text":"The formulas for these velocities are derived from Newtonian mechanics, specifically gravitational forces.","title":"2. Mathematical Derivations of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-v_1","text":"The first cosmic velocity is the velocity required for a body to enter a stable circular orbit around a celestial body. For a circular orbit, the centripetal force is provided by gravity: \\[F_{\\text{gravity}} = F_{\\text{centripetal}}\\] \\[\\frac{G M m}{r^2} = \\frac{m v_1^2}{r}\\] Where: \\(G\\) is the gravitational constant \\(M\\) is the mass of the celestial body (e.g., Earth) \\(m\\) is the mass of the object in orbit \\(r\\) is the radius of orbit \\(v_1\\) is the first cosmic velocity Canceling \\(m\\) from both sides: \\[v_1 = \\sqrt{\\frac{G M}{r}}\\]","title":"First Cosmic Velocity (\\(v_1\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-v_2","text":"The second cosmic velocity is the escape velocity\u2014the minimum velocity required for an object to escape the gravitational pull of the celestial body. The energy required to escape is the sum of kinetic and potential energy. The total energy of the object at escape is zero (it reaches an infinite distance with zero velocity). The gravitational potential energy is: \\[U = -\\frac{G M m}{r}\\] The total mechanical energy at the escape point is zero: \\[\\frac{1}{2} m v_2^2 - \\frac{G M m}{r} = 0\\] Solving for \\(v_2\\) : \\[v_2 = \\sqrt{\\frac{2 G M}{r}}\\]","title":"Second Cosmic Velocity (\\(v_2\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-v_3","text":"The third cosmic velocity is the velocity required to escape the gravitational influence of an entire star system, such as the Sun\u2019s gravitational field. It can be derived from the escape velocity from the star system, considering the distance from the star\u2019s center (usually the distance from the Sun's center to Earth): \\[v_3 = \\sqrt{\\frac{2 G M_{\\text{star}}}{r_{\\text{star}}}}\\] Where: \\(M_{\\text{star}}\\) is the mass of the star (e.g., Sun) \\(r_{\\text{star}}\\) is the distance from the star\u2019s center (for instance, the distance from the Earth to the Sun)","title":"Third Cosmic Velocity (\\(v_3\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-calculations-for-different-celestial-bodies","text":"Let\u2019s calculate these velocities for Earth, Mars, and Jupiter. The formula for escape velocity and orbital velocity depends on the mass and radius of the celestial body. We will calculate the first and second cosmic velocities, using the following known values: Earth: Mass ( \\(M_{\\text{Earth}}\\) ): \\(5.972 \\times 10^{24} \\, \\text{kg}\\) Radius ( \\(R_{\\text{Earth}}\\) ): \\(6.371 \\times 10^{6} \\, \\text{m}\\) Mars: Mass ( \\(M_{\\text{Mars}}\\) ): \\(0.64171 \\times 10^{24} \\, \\text{kg}\\) Radius ( \\(R_{\\text{Mars}}\\) ): \\(3.396 \\times 10^{6} \\, \\text{m}\\) Jupiter: Mass ( \\(M_{\\text{Jupiter}}\\) ): \\(1.898 \\times 10^{27} \\, \\text{kg}\\) Radius ( \\(R_{\\text{Jupiter}}\\) ): \\(6.991 \\times 10^{7} \\, \\text{m}\\) Using these values, we will compute the first and second cosmic velocities.","title":"3. Calculations for Different Celestial Bodies"},{"location":"1%20Physics/2%20Gravity/Problem_2/#advanced-concepts-in-escape-and-cosmic-velocities","text":"","title":"Advanced Concepts in Escape and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-gravitational-potential-energy-in-a-non-spherical-potential","text":"For non-spherical celestial bodies (e.g., rotating bodies like planets), the gravitational potential energy changes slightly due to the distribution of mass, particularly for objects that are not perfectly spherical. In such cases, the gravitational potential energy \\(U\\) at a distance \\(r\\) from the center of mass can be written as: \\[U = - \\frac{GMm}{r} \\left(1 + \\frac{1}{2} \\frac{r^2}{R_{\\text{eq}}^2} \\right)\\] Where: \\(R_{\\text{eq}}\\) is the equatorial radius of the planet. The term \\(\\frac{r^2}{R_{\\text{eq}}^2}\\) introduces a correction for the planet\u2019s oblateness (flattening at the poles). This formula helps in considering real celestial bodies where \\(r\\) is near the planet\u2019s equator or poles.","title":"1. Gravitational Potential Energy in a Non-Spherical Potential"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-relativistic-correction-to-escape-velocity","text":"When objects move at speeds close to the speed of light, relativistic effects come into play. The relativistic escape velocity \\(v_{\\text{rel}}\\) is given by: \\[v_{\\text{rel}} = \\sqrt{\\frac{2GM}{r} \\left(1 + \\frac{v_{\\text{orbital}}^2}{c^2} \\right)}\\] Where: \\(v_{\\text{orbital}}\\) is the orbital velocity of the object in question. \\(c\\) is the speed of light. At low velocities (non-relativistic), this reduces to the classical escape velocity formula, but for high velocities, the correction term accounts for relativistic effects.","title":"2. Relativistic Correction to Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-generalized-third-cosmic-velocity","text":"The generalized third cosmic velocity \\(v_3\\) accounts for a system where the object must escape not just the gravitational influence of a single star but also overcome the combined gravitational potential of the entire galaxy. For a multi-body system, the escape velocity from a galactic center at a distance \\(r_{\\text{galaxy}}\\) is: \\[v_3 = \\sqrt{\\frac{2 G M_{\\text{galaxy}}}{r_{\\text{galaxy}}} \\left(1 + \\frac{v_{\\text{orbital}}^2}{c^2} \\right)}\\] Where: \\(M_{\\text{galaxy}}\\) is the mass of the galaxy. \\(r_{\\text{galaxy}}\\) is the distance from the galactic center. This formula considers the combined gravitational potential from the star system and the galactic center.","title":"3. Generalized Third Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-the-escape-velocity-for-a-rotating-body-centrifugal-force-considerations","text":"For rotating bodies such as Earth, centrifugal forces also play a role in determining the velocity required to escape. The escape velocity \\(v_{\\text{esc}}\\) at the surface of a rotating body, taking into account centrifugal forces at latitude \\(\\phi\\) , is given by: \\[v_{\\text{esc}} = \\sqrt{\\frac{2GM}{r} + \\omega^2 r^2 - 2\\omega r^2 \\sin \\phi \\cos \\phi}\\] Where: \\(\\omega\\) is the angular velocity of the celestial body. \\(r\\) is the radius at a specific latitude. \\(\\phi\\) is the latitude of the object from the axis of rotation (e.g., Earth's surface). This formula takes into account the reduced effective escape velocity due to the centrifugal force at the equator.","title":"4. The Escape Velocity for a Rotating Body (Centrifugal Force Considerations)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#5-gravitational-binding-energy-of-a-planet","text":"For a planet, the gravitational binding energy \\(E_b\\) , or the energy required to disperse a planet's mass to infinity, can be calculated by: \\[E_b = -\\frac{3}{5} \\frac{GM^2}{R}\\] Where: \\(M\\) is the mass of the planet. \\(R\\) is the radius of the planet. This formula provides an understanding of the energy scale needed to disrupt a planet\u2019s gravitational binding.","title":"5. Gravitational Binding Energy of a Planet"},{"location":"1%20Physics/2%20Gravity/Problem_2/#6-cosmic-velocities-of-earth-mars-and-jupiter","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_earth = 5.972e24 # Mass of Earth (kg) R_earth = 6.371e6 # Radius of Earth (m) M_mars = 6.39e23 # Mass of Mars (kg) R_mars = 3.390e6 # Radius of Mars (m) M_jupiter = 1.898e27 # Mass of Jupiter (kg) R_jupiter = 6.9911e7 # Radius of Jupiter (m) M_sun = 1.989e30 # Mass of Sun (kg) R_earthSun = 1.496e11 # Distance from earth to sun (m) earth_orbital_velocity = 29780 # earth orbital velocity m/s # Function to calculate first cosmic velocity def first_cosmic_velocity(mass, radius): return np.sqrt(G * mass / radius) # Function to calculate second cosmic velocity (escape velocity) def escape_velocity(mass, radius): return np.sqrt(2 * G * mass / radius) # Calculate velocities v1_earth = first_cosmic_velocity(M_earth, R_earth) v2_earth = escape_velocity(M_earth, R_earth) v1_mars = first_cosmic_velocity(M_mars, R_mars) v2_mars = escape_velocity(M_mars, R_mars) v1_jupiter = first_cosmic_velocity(M_jupiter, R_jupiter) v2_jupiter = escape_velocity(M_jupiter, R_jupiter) v_sunEscape = escape_velocity(M_sun, R_earthSun) v3_earth = np.sqrt(v_sunEscape**2 + earth_orbital_velocity**2) - earth_orbital_velocity # Print results print(f\"Earth: v1 = {v1_earth/1000:.2f} km/s, v2 = {v2_earth/1000:.2f} km/s\") print(f\"Mars: v1 = {v1_mars/1000:.2f} km/s, v2 = {v2_mars/1000:.2f} km/s\") print(f\"Jupiter: v1 = {v1_jupiter/1000:.2f} km/s, v2 = {v2_jupiter/1000:.2f} km/s\") print(f\"Earth: v3 = {v3_earth/1000:.2f} km/s\") # Visualization bodies = ['Earth', 'Mars', 'Jupiter'] v1_values = [v1_earth/1000, v1_mars/1000, v1_jupiter/1000] v2_values = [v2_earth/1000, v2_mars/1000, v2_jupiter/1000] plt.figure(figsize=(10, 6)) plt.bar(bodies, v1_values, label='First Cosmic Velocity (km/s)', alpha=0.7) plt.bar(bodies, v2_values, label='Escape Velocity (km/s)', alpha=0.7) plt.ylabel('Velocity (km/s)') plt.title('Cosmic Velocities for Various Celestial Bodies') plt.legend() plt.show()","title":"6. Cosmic Velocities of Earth, Mars, and Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#7-cosmic-velocities-and-escape-velocity-visualizations","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) c = 299792458 # Speed of light (m/s) M_earth = 5.972e24 # Mass of Earth (kg) R_earth = 6.371e6 # Radius of Earth (m) earth_angular_velocity = 7.27e-5 # Earth's angular velocity (rad/s) # Function to calculate first cosmic velocity def first_cosmic_velocity(mass, radius): return np.sqrt(G * mass / radius) # Function to calculate second cosmic velocity (escape velocity) def escape_velocity(mass, radius): return np.sqrt(2 * G * mass / radius) # Function to calculate relativistic escape velocity def relativistic_escape_velocity(mass, radius): return c * np.sqrt(1 - (1 + 2 * G * mass / (radius * c**2))**-2) # Function to calculate escape velocity in a rotating frame def rotating_escape_velocity(mass, radius, angular_velocity): rotational_velocity = angular_velocity * radius return np.sqrt(2 * G * mass / radius - rotational_velocity**2) # Calculate velocities for Earth v1_earth = first_cosmic_velocity(M_earth, R_earth) v2_earth = escape_velocity(M_earth, R_earth) v_esc_rel_earth = relativistic_escape_velocity(M_earth, R_earth) v_esc_rot_earth = rotating_escape_velocity(M_earth, R_earth, earth_angular_velocity) # Create a bar chart for comparison velocities = { 'First Cosmic': v1_earth / 1000, 'Classical Escape': v2_earth / 1000, 'Relativistic Escape': v_esc_rel_earth / 1000, 'Rotating Escape': v_esc_rot_earth / 1000, } plt.figure(figsize=(10, 6)) plt.bar(velocities.keys(), velocities.values()) plt.ylabel('Velocity (km/s)') plt.title('Cosmic Velocities for Earth') plt.show() # Example: Escape Velocity vs. Radius radii = np.linspace(R_earth, 10 * R_earth, 100) classical_escape = escape_velocity(M_earth, radii) / 1000 relativistic_escape = relativistic_escape_velocity(M_earth, radii) / 1000 plt.figure(figsize=(10, 6)) plt.plot(radii / R_earth, classical_escape, label='Classical Escape') plt.plot(radii / R_earth, relativistic_escape, label='Relativistic Escape') plt.xlabel('Radius (multiples of Earth radius)') plt.ylabel('Escape Velocity (km/s)') plt.title('Escape Velocity vs. Radius') plt.legend() plt.show() # Example: Escape Velocity vs. Angular Velocity angular_velocities = np.linspace(0, 2 * earth_angular_velocity, 100) rotating_escape = rotating_escape_velocity(M_earth, R_earth, angular_velocities) / 1000 plt.figure(figsize=(10, 6)) plt.plot(angular_velocities / earth_angular_velocity, rotating_escape, label='Rotating Escape') plt.xlabel('Angular Velocity (multiples of Earth angular velocity)') plt.ylabel('Escape Velocity (km/s)') plt.title('Escape Velocity vs. Angular Velocity') plt.legend() plt.show()","title":"7. Cosmic Velocities and Escape Velocity Visualizations"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3: Trajectories of a Freely Released Payload Near Earth 1. Introduction In this problem, we\u2019ll analyze the motion of a payload released near Earth, focusing on the influence of Earth\u2019s gravity on its trajectory. Depending on the velocity and direction of release, the trajectory could be: Elliptical: The object remains in orbit around the Earth. Parabolic: The object escapes Earth\u2019s gravity but at exactly escape velocity. Hyperbolic: The object escapes Earth\u2019s gravity with a velocity greater than the escape velocity. We will model these trajectories using the two-body problem under Newton's law of gravitation and solve them numerically using Python. 2. Gravitational Dynamics and Equations of Motion The gravitational force between Earth and the payload is given by Newton\u2019s Law of Gravitation: \\[F = \\frac{GMm}{r^2}\\] where: \\(F\\) is the gravitational force. \\(G\\) is the gravitational constant. \\(M\\) is the mass of Earth. \\(m\\) is the mass of the payload. \\(r\\) is the distance between the Earth and the payload. This force results in a gravitational acceleration that affects the trajectory of the payload. We can model the motion of the payload with the following equations of motion: \\[\\ddot{r} = -\\frac{GM}{r^2}\\] Where: \\(r\\) is the radial distance. \\(\\ddot{r}\\) is the acceleration. We\u2019ll break down the radial and angular components of motion and solve for the position and velocity of the payload over time using numerical integration. 3. Numerical Simulation We'll use Euler's method or Runge-Kutta method to numerically solve the system of differential equations for the position and velocity of the payload. The system of equations to solve are: \\[\\ddot{x} = -\\frac{GMx}{r^3}, \\quad \\ddot{y} = -\\frac{GMy}{r^3}\\] Where \\(x\\) and \\(y\\) are the position coordinates of the payload in a 2D plane. 4. Initial Conditions and Setup For our simulation, we\u2019ll define the following initial conditions: The initial position of the payload relative to Earth (e.g., at some altitude). The initial velocity of the payload (e.g., tangential or radial). The initial angle of release. We'll visualize the trajectories for different cases of initial velocities and directions (parabolic, elliptical, and hyperbolic). 5. Relativistic Equations of Motion (General Relativity Correction) When velocities approach a significant fraction of the speed of light, we must modify Newtonian gravity using General Relativity corrections. The relativistic equation of motion for an object in Earth's gravitational field is: \\( \\(\\frac{d^2r}{dt^2} = -\\frac{GM}{r^2} \\left( 1 + \\frac{3GM}{c^2 r} \\right)\\) \\) where: \\(c\\) is the speed of light (3.0\u00d710 8 m/s), \\(GM\\) is Earth's gravitational parameter. This additional term accounts for the relativistic time dilation and length contraction near strong gravitational fields. ## 6. Perturbation Due to Earth's Oblateness (J2 Effect) Since Earth is not a perfect sphere, higher-order gravitational terms introduce perturbations in the motion of the payload. The J2 perturbation effect modifies the acceleration as: \\( \\(a_r = -\\frac{GM}{r^2} \\left[ 1 - \\frac{3}{2} J_2 \\left( \\frac{R_E}{r} \\right)^2 (1 - 3 \\cos^2\\theta) \\right]\\) \\) where: \\(J_2 \\approx 1.08263 \\times 10^{-3}\\) is Earth's oblateness coefficient, \\(R_E\\) is the equatorial radius of Earth, \\(\\theta\\) is the latitude. This effect causes a precession of satellite orbits, known as the J2-induced secular drift. ## 7. Three-Body Problem (Influence of Moon or Sun on the Payload) When a payload is released into space, its trajectory is not only influenced by Earth's gravity but also by other celestial bodies like the Moon or the Sun. In the restricted three-body problem, the equations of motion are: \\( \\(\\ddot{x} - 2\\omega \\dot{y} = \\frac{\\partial U}{\\partial x}, \\quad \\ddot{y} + 2\\omega \\dot{x} = \\frac{\\partial U}{\\partial y}, \\quad \\ddot{z} = \\frac{\\partial U}{\\partial z}\\) \\) where: \\(U\\) is the effective potential: \\( \\(U = \\frac{1}{2} \\omega^2 (x^2 + y^2) + \\frac{GM_1}{r_1} + \\frac{GM_2}{r_2}\\) \\) \\(M_1, M_2\\) are the masses of Earth and the Moon (or Sun), \\(r_1, r_2\\) are the distances from the payload to each body. This equation governs Lagrange points, where the gravitational and centrifugal forces balance. ## 8. Atmospheric Drag and Reentry Dynamics For payloads re-entering Earth's atmosphere, we must consider aerodynamic drag. The equation of motion with drag force is: \\( \\(m \\frac{d\\mathbf{v}}{dt} = -\\frac{GMm}{r^2} + \\frac{1}{2} C_D \\rho A v^2\\) \\) where: \\(C_D\\) is the drag coefficient, \\(\\rho\\) is the atmospheric density (which varies with altitude), \\(A\\) is the cross-sectional area. The drag force significantly reduces velocity and causes heat buildup during reentry. ## 9. Lorentz Force for Charged Payloads in Space If the payload is charged, it experiences an additional force due to Earth's magnetic field: \\( \\(\\mathbf{F} = q (\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B})\\) \\) where: \\(q\\) is the charge of the payload, \\(\\mathbf{E}\\) is the electric field, \\(\\mathbf{B}\\) is Earth's magnetic field. This effect is crucial for spacecraft operating near planetary magnetospheres. ## 10. Non-Inertial Frame Corrections (Coriolis & Centrifugal Forces) When the payload is released from a moving spacecraft, we need to correct for non-inertial effects: \\( \\(\\mathbf{F}_{\\text{non-inertial}} = -2m (\\mathbf{\\Omega} \\times \\mathbf{v}) - m \\mathbf{\\Omega} \\times (\\mathbf{\\Omega} \\times \\mathbf{r})\\) \\) where: \\(\\mathbf{\\Omega}\\) is the rotational velocity of the spacecraft. These effects are critical for precise orbital insertions. ## 11. Non-Spherical Harmonics and Higher-Order Perturbations Beyond J2, Earth's gravitational field has higher-order harmonics (J3, J4, etc.) and tesseral harmonics (Cnm, Snm). These account for more subtle variations in Earth's gravity. Generalized Gravitational Potential: \\( \\(U = \\frac{GM}{r} \\left[ 1 - \\sum_{n=2}^{\\infty} \\sum_{m=0}^{n} \\left( \\frac{R_e}{r} \\right)^n P_{nm}(\\sin\\phi) (C_{nm} \\cos(m\\lambda) + S_{nm} \\sin(m\\lambda)) \\right]\\) \\) Where: * \\(P_{nm}\\) are associated Legendre polynomials. * \\(C_{nm}\\) and \\(S_{nm}\\) are spherical harmonic coefficients. * \\(\\lambda\\) is the longitude. 12. Solar Radiation Pressure For long-duration space missions, solar radiation pressure can significantly affect trajectories. Solar Radiation Pressure Force: \\( \\(F_{rad} = \\frac{P_{rad} A_{cr} (1+q)}{c}\\) \\) Where: * \\(P_{rad}\\) is the solar radiation pressure. * \\(A_{cr}\\) is the spacecraft's cross-sectional area. * \\(q\\) is the reflectivity coefficient. * \\(c\\) is the speed of light. 13. Payload Dynamics Near Earth: Trajectories, Velocity, and Altitude Over Time import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_earth = 5.972e24 # Mass of Earth (kg) R_earth = 6.371e6 # Radius of Earth (m) # Equations of motion def payload_trajectory(t, y): x, vx, z, vz = y r = np.sqrt(x**2 + z**2) ax = -G * M_earth * x / r**3 az = -G * M_earth * z / r**3 return [vx, ax, vz, az] # Initial conditions altitude = 400e3 # 400 km altitude r0 = R_earth + altitude v_orbit = np.sqrt(G * M_earth / r0) v_escape = np.sqrt(2 * G * M_earth / r0) # Time span time_span = [0, 10000] time_points = np.linspace(time_span[0], time_span[1], 1000) # Example 1: Circular orbit initial_state_circular = [r0, 0, 0, v_orbit] solution_circular = solve_ivp(payload_trajectory, time_span, initial_state_circular, t_eval=time_points) # Example 2: Elliptical orbit (sub-orbital reentry) initial_state_elliptical = [r0, 0.5 * v_orbit, 0, 0.5 * v_orbit] solution_elliptical = solve_ivp(payload_trajectory, time_span, initial_state_elliptical, t_eval=time_points) # Example 3: Escape trajectory (hyperbolic) initial_state_escape = [r0, 0, 0, 1.2 * v_escape] solution_escape = solve_ivp(payload_trajectory, time_span, initial_state_escape, t_eval=time_points) # Plotting trajectories plt.figure(figsize=(12, 8)) plt.plot(solution_circular.y[0], solution_circular.y[2], label='Circular Orbit') plt.plot(solution_elliptical.y[0], solution_elliptical.y[2], label='Elliptical Reentry') plt.plot(solution_escape.y[0], solution_escape.y[2], label='Escape Trajectory') plt.scatter(0, 0, color='red', label='Earth') plt.xlabel('X (m)') plt.ylabel('Z (m)') plt.title('Payload Trajectories Near Earth') plt.legend() plt.grid(True) plt.show() # Plotting velocity vs. time plt.figure(figsize=(12, 8)) plt.plot(time_points, np.sqrt(solution_circular.y[1]**2 + solution_circular.y[3]**2), label='Circular Orbit Velocity') plt.plot(time_points, np.sqrt(solution_elliptical.y[1]**2 + solution_elliptical.y[3]**2), label='Elliptical Reentry Velocity') plt.plot(time_points, np.sqrt(solution_escape.y[1]**2 + solution_escape.y[3]**2), label='Escape Trajectory Velocity') plt.xlabel('Time (s)') plt.ylabel('Velocity (m/s)') plt.title('Payload Velocity vs. Time') plt.legend() plt.grid(True) plt.show() # Plotting altitude vs. time alt_circular = np.sqrt(solution_circular.y[0]**2 + solution_circular.y[2]**2) - R_earth alt_elliptical = np.sqrt(solution_elliptical.y[0]**2 + solution_elliptical.y[2]**2) - R_earth alt_escape = np.sqrt(solution_escape.y[0]**2 + solution_escape.y[2]**2) - R_earth plt.figure(figsize=(12, 8)) plt.plot(time_points, alt_circular / 1000, label='Circular Orbit Altitude') plt.plot(time_points, alt_elliptical / 1000, label='Elliptical Reentry Altitude') plt.plot(time_points, alt_escape / 1000, label='Escape Trajectory Altitude') plt.xlabel('Time (s)') plt.ylabel('Altitude (km)') plt.title('Payload Altitude vs. Time') plt.legend() plt.grid(True) plt.show()","title":"Problem 3: Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3-trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Problem 3: Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-introduction","text":"In this problem, we\u2019ll analyze the motion of a payload released near Earth, focusing on the influence of Earth\u2019s gravity on its trajectory. Depending on the velocity and direction of release, the trajectory could be: Elliptical: The object remains in orbit around the Earth. Parabolic: The object escapes Earth\u2019s gravity but at exactly escape velocity. Hyperbolic: The object escapes Earth\u2019s gravity with a velocity greater than the escape velocity. We will model these trajectories using the two-body problem under Newton's law of gravitation and solve them numerically using Python.","title":"1. Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-gravitational-dynamics-and-equations-of-motion","text":"The gravitational force between Earth and the payload is given by Newton\u2019s Law of Gravitation: \\[F = \\frac{GMm}{r^2}\\] where: \\(F\\) is the gravitational force. \\(G\\) is the gravitational constant. \\(M\\) is the mass of Earth. \\(m\\) is the mass of the payload. \\(r\\) is the distance between the Earth and the payload. This force results in a gravitational acceleration that affects the trajectory of the payload. We can model the motion of the payload with the following equations of motion: \\[\\ddot{r} = -\\frac{GM}{r^2}\\] Where: \\(r\\) is the radial distance. \\(\\ddot{r}\\) is the acceleration. We\u2019ll break down the radial and angular components of motion and solve for the position and velocity of the payload over time using numerical integration.","title":"2. Gravitational Dynamics and Equations of Motion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-numerical-simulation","text":"We'll use Euler's method or Runge-Kutta method to numerically solve the system of differential equations for the position and velocity of the payload. The system of equations to solve are: \\[\\ddot{x} = -\\frac{GMx}{r^3}, \\quad \\ddot{y} = -\\frac{GMy}{r^3}\\] Where \\(x\\) and \\(y\\) are the position coordinates of the payload in a 2D plane.","title":"3. Numerical Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#4-initial-conditions-and-setup","text":"For our simulation, we\u2019ll define the following initial conditions: The initial position of the payload relative to Earth (e.g., at some altitude). The initial velocity of the payload (e.g., tangential or radial). The initial angle of release. We'll visualize the trajectories for different cases of initial velocities and directions (parabolic, elliptical, and hyperbolic).","title":"4. Initial Conditions and Setup"},{"location":"1%20Physics/2%20Gravity/Problem_3/#5-relativistic-equations-of-motion-general-relativity-correction","text":"When velocities approach a significant fraction of the speed of light, we must modify Newtonian gravity using General Relativity corrections. The relativistic equation of motion for an object in Earth's gravitational field is: \\( \\(\\frac{d^2r}{dt^2} = -\\frac{GM}{r^2} \\left( 1 + \\frac{3GM}{c^2 r} \\right)\\) \\) where: \\(c\\) is the speed of light (3.0\u00d710 8 m/s), \\(GM\\) is Earth's gravitational parameter. This additional term accounts for the relativistic time dilation and length contraction near strong gravitational fields. ## 6. Perturbation Due to Earth's Oblateness (J2 Effect) Since Earth is not a perfect sphere, higher-order gravitational terms introduce perturbations in the motion of the payload. The J2 perturbation effect modifies the acceleration as: \\( \\(a_r = -\\frac{GM}{r^2} \\left[ 1 - \\frac{3}{2} J_2 \\left( \\frac{R_E}{r} \\right)^2 (1 - 3 \\cos^2\\theta) \\right]\\) \\) where: \\(J_2 \\approx 1.08263 \\times 10^{-3}\\) is Earth's oblateness coefficient, \\(R_E\\) is the equatorial radius of Earth, \\(\\theta\\) is the latitude. This effect causes a precession of satellite orbits, known as the J2-induced secular drift. ## 7. Three-Body Problem (Influence of Moon or Sun on the Payload) When a payload is released into space, its trajectory is not only influenced by Earth's gravity but also by other celestial bodies like the Moon or the Sun. In the restricted three-body problem, the equations of motion are: \\( \\(\\ddot{x} - 2\\omega \\dot{y} = \\frac{\\partial U}{\\partial x}, \\quad \\ddot{y} + 2\\omega \\dot{x} = \\frac{\\partial U}{\\partial y}, \\quad \\ddot{z} = \\frac{\\partial U}{\\partial z}\\) \\) where: \\(U\\) is the effective potential: \\( \\(U = \\frac{1}{2} \\omega^2 (x^2 + y^2) + \\frac{GM_1}{r_1} + \\frac{GM_2}{r_2}\\) \\) \\(M_1, M_2\\) are the masses of Earth and the Moon (or Sun), \\(r_1, r_2\\) are the distances from the payload to each body. This equation governs Lagrange points, where the gravitational and centrifugal forces balance. ## 8. Atmospheric Drag and Reentry Dynamics For payloads re-entering Earth's atmosphere, we must consider aerodynamic drag. The equation of motion with drag force is: \\( \\(m \\frac{d\\mathbf{v}}{dt} = -\\frac{GMm}{r^2} + \\frac{1}{2} C_D \\rho A v^2\\) \\) where: \\(C_D\\) is the drag coefficient, \\(\\rho\\) is the atmospheric density (which varies with altitude), \\(A\\) is the cross-sectional area. The drag force significantly reduces velocity and causes heat buildup during reentry. ## 9. Lorentz Force for Charged Payloads in Space If the payload is charged, it experiences an additional force due to Earth's magnetic field: \\( \\(\\mathbf{F} = q (\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B})\\) \\) where: \\(q\\) is the charge of the payload, \\(\\mathbf{E}\\) is the electric field, \\(\\mathbf{B}\\) is Earth's magnetic field. This effect is crucial for spacecraft operating near planetary magnetospheres. ## 10. Non-Inertial Frame Corrections (Coriolis & Centrifugal Forces) When the payload is released from a moving spacecraft, we need to correct for non-inertial effects: \\( \\(\\mathbf{F}_{\\text{non-inertial}} = -2m (\\mathbf{\\Omega} \\times \\mathbf{v}) - m \\mathbf{\\Omega} \\times (\\mathbf{\\Omega} \\times \\mathbf{r})\\) \\) where: \\(\\mathbf{\\Omega}\\) is the rotational velocity of the spacecraft. These effects are critical for precise orbital insertions. ## 11. Non-Spherical Harmonics and Higher-Order Perturbations Beyond J2, Earth's gravitational field has higher-order harmonics (J3, J4, etc.) and tesseral harmonics (Cnm, Snm). These account for more subtle variations in Earth's gravity. Generalized Gravitational Potential: \\( \\(U = \\frac{GM}{r} \\left[ 1 - \\sum_{n=2}^{\\infty} \\sum_{m=0}^{n} \\left( \\frac{R_e}{r} \\right)^n P_{nm}(\\sin\\phi) (C_{nm} \\cos(m\\lambda) + S_{nm} \\sin(m\\lambda)) \\right]\\) \\) Where: * \\(P_{nm}\\) are associated Legendre polynomials. * \\(C_{nm}\\) and \\(S_{nm}\\) are spherical harmonic coefficients. * \\(\\lambda\\) is the longitude.","title":"5. Relativistic Equations of Motion (General Relativity Correction)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#12-solar-radiation-pressure","text":"For long-duration space missions, solar radiation pressure can significantly affect trajectories. Solar Radiation Pressure Force: \\( \\(F_{rad} = \\frac{P_{rad} A_{cr} (1+q)}{c}\\) \\) Where: * \\(P_{rad}\\) is the solar radiation pressure. * \\(A_{cr}\\) is the spacecraft's cross-sectional area. * \\(q\\) is the reflectivity coefficient. * \\(c\\) is the speed of light.","title":"12. Solar Radiation Pressure"},{"location":"1%20Physics/2%20Gravity/Problem_3/#13-payload-dynamics-near-earth-trajectories-velocity-and-altitude-over-time","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_earth = 5.972e24 # Mass of Earth (kg) R_earth = 6.371e6 # Radius of Earth (m) # Equations of motion def payload_trajectory(t, y): x, vx, z, vz = y r = np.sqrt(x**2 + z**2) ax = -G * M_earth * x / r**3 az = -G * M_earth * z / r**3 return [vx, ax, vz, az] # Initial conditions altitude = 400e3 # 400 km altitude r0 = R_earth + altitude v_orbit = np.sqrt(G * M_earth / r0) v_escape = np.sqrt(2 * G * M_earth / r0) # Time span time_span = [0, 10000] time_points = np.linspace(time_span[0], time_span[1], 1000) # Example 1: Circular orbit initial_state_circular = [r0, 0, 0, v_orbit] solution_circular = solve_ivp(payload_trajectory, time_span, initial_state_circular, t_eval=time_points) # Example 2: Elliptical orbit (sub-orbital reentry) initial_state_elliptical = [r0, 0.5 * v_orbit, 0, 0.5 * v_orbit] solution_elliptical = solve_ivp(payload_trajectory, time_span, initial_state_elliptical, t_eval=time_points) # Example 3: Escape trajectory (hyperbolic) initial_state_escape = [r0, 0, 0, 1.2 * v_escape] solution_escape = solve_ivp(payload_trajectory, time_span, initial_state_escape, t_eval=time_points) # Plotting trajectories plt.figure(figsize=(12, 8)) plt.plot(solution_circular.y[0], solution_circular.y[2], label='Circular Orbit') plt.plot(solution_elliptical.y[0], solution_elliptical.y[2], label='Elliptical Reentry') plt.plot(solution_escape.y[0], solution_escape.y[2], label='Escape Trajectory') plt.scatter(0, 0, color='red', label='Earth') plt.xlabel('X (m)') plt.ylabel('Z (m)') plt.title('Payload Trajectories Near Earth') plt.legend() plt.grid(True) plt.show() # Plotting velocity vs. time plt.figure(figsize=(12, 8)) plt.plot(time_points, np.sqrt(solution_circular.y[1]**2 + solution_circular.y[3]**2), label='Circular Orbit Velocity') plt.plot(time_points, np.sqrt(solution_elliptical.y[1]**2 + solution_elliptical.y[3]**2), label='Elliptical Reentry Velocity') plt.plot(time_points, np.sqrt(solution_escape.y[1]**2 + solution_escape.y[3]**2), label='Escape Trajectory Velocity') plt.xlabel('Time (s)') plt.ylabel('Velocity (m/s)') plt.title('Payload Velocity vs. Time') plt.legend() plt.grid(True) plt.show() # Plotting altitude vs. time alt_circular = np.sqrt(solution_circular.y[0]**2 + solution_circular.y[2]**2) - R_earth alt_elliptical = np.sqrt(solution_elliptical.y[0]**2 + solution_elliptical.y[2]**2) - R_earth alt_escape = np.sqrt(solution_escape.y[0]**2 + solution_escape.y[2]**2) - R_earth plt.figure(figsize=(12, 8)) plt.plot(time_points, alt_circular / 1000, label='Circular Orbit Altitude') plt.plot(time_points, alt_elliptical / 1000, label='Elliptical Reentry Altitude') plt.plot(time_points, alt_escape / 1000, label='Escape Trajectory Altitude') plt.xlabel('Time (s)') plt.ylabel('Altitude (km)') plt.title('Payload Altitude vs. Time') plt.legend() plt.grid(True) plt.show()","title":"13. Payload Dynamics Near Earth: Trajectories, Velocity, and Altitude Over Time"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Interference Patterns on a Water Surface A Simulation-Based Exploration Using Regular Polygons 1. Introduction Wave interference is a fundamental concept in physics that describes how two or more waves combine when they overlap in space. On a water surface, this phenomenon is visually intuitive and can be observed when multiple ripples interact, forming patterns of reinforcement (constructive interference) or cancellation (destructive interference). In this study, we simulate the interference patterns created by coherent wave sources placed at the vertices of regular polygons \u2014 such as triangles, squares, and pentagons. The regular placement ensures symmetry and makes it easier to study the resulting wave interactions. 2. Real-World Relevance Noise-canceling headphones : Use destructive interference to cancel ambient sound. Optical instruments : Lasers interfere to form holograms or measure distances with extreme precision. Engineering and architecture : Vibration patterns in structures are often analyzed using interference principles. 3. Wave Physics Background Each point source creates a circular wave that propagates outward. The mathematical expression for a wave from a point source is shown below: \\[ \\eta_i(x, y, t) = \\frac{A}{r_i} \\cdot \\cos\\Bigl(kr_i - \\omega t + \\phi_i\\Bigr) \\] Where: - \\(\\eta_i(x, y, t)\\) : Displacement at point \\((x, y)\\) and time \\(t\\) from source \\(i\\) - \\(A\\) : Amplitude (constant for all sources) - \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) : Distance from the source to the point - \\(k = \\frac{2\\pi}{\\lambda}\\) : Wave number (inverse of wavelength) - \\(\\omega = 2\\pi f\\) : Angular frequency (proportional to frequency) - \\(\\phi_i\\) : Initial phase of the wave from source \\(i\\) Since all waves are coherent, we assume: - Same \\(A\\) , \\(\\lambda\\) , \\(f\\) , and \\(\\phi = 0\\) 4. Superposition Principle The total surface displacement at any point is calculated using the principle of linear superposition. Below is the corresponding formula: \\[ \\eta_{sum}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\] This summation produces the interference pattern: - Bright regions : Constructive interference (waves add up) - Dark regions : Destructive interference (waves cancel) 5. Graphical Representation Below is a Python script that uses Matplotlib to generate and display the interference patterns for a triangular, square, and pentagonal arrangement of point sources. import numpy as np import matplotlib.pyplot as plt # Constants for wave properties A = 1.0 # amplitude wavelength = 2.0 # wavelength frequency = 1.0 # frequency phi = 0.0 # phase offset k = 2 * np.pi / wavelength omega = 2 * np.pi * frequency # Create a grid of x, y points to evaluate wave displacements x = np.linspace(-10, 10, 500) y = np.linspace(-10, 10, 500) X, Y = np.meshgrid(x, y) def polygon_vertices(n_sides, radius=5, center=(0, 0)): \"\"\"Returns the coordinates of the vertices of a regular polygon\"\"\" angles = np.linspace(0, 2*np.pi, n_sides, endpoint=False) cx, cy = center return [(cx + radius*np.cos(a), cy + radius*np.sin(a)) for a in angles] def total_wave(X, Y, t, sources): \"\"\"Calculates the total wave displacement by summing the waves from all sources\"\"\" eta = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) + 1e-6 # to avoid division by zero eta += (A / np.sqrt(r)) * np.cos(k * r - omega * t + phi) return eta # Time snapshot for visualization t = 0 # Create the figure for plotting fig, axs = plt.subplots(1, 3, figsize=(18, 6)) titles = ['Triangle (3 sources)', 'Square (4 sources)', 'Pentagon (5 sources)'] # Generate and plot the interference patterns for each polygon for ax, sides, title in zip(axs, [3, 4, 5], titles): sources = polygon_vertices(sides) # Get the polygon vertices eta_sum = total_wave(X, Y, t, sources) # Compute the total wave displacement im = ax.imshow(eta_sum, extent=(-10, 10, -10, 10), cmap='seismic', origin='lower') # Plot the pattern ax.set_title(title) ax.set_xlabel('x') ax.set_ylabel('y') ax.scatter(*zip(*sources), color='black', marker='x', label='Sources') # Mark the sources ax.legend() # Add color bar for better understanding fig.colorbar(im, ax=axs.ravel().tolist(), shrink=0.7, label='Wave Displacement') # Adjust layout for better spacing plt.tight_layout() plt.show() Analysis of Graphs Triangle (3 Sources) The interference pattern exhibits three-fold symmetry . Bright areas represent constructive interference , while dark areas show destructive interference . Square (4 Sources) The interference pattern forms a four-fold symmetric grid , with regions of amplification and cancellation of waves. Pentagon (5 Sources) The interference pattern becomes more complex with five-fold symmetry , showcasing intricate regions of constructive and destructive interference. 6.Formulas Used in the Code 1. Distance to Source \\[ r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2} \\] Explanation : This is the Euclidean distance from a point \\((x, y)\\) to the wave source at \\((x_i, y_i)\\) . Why it's important : Farther points receive weaker waves and are reached later. Example : From \\((0,0)\\) to \\((3,4)\\) : \\[ r = \\sqrt{3^2 + 4^2} = 5 \\] 2. Wave Number \\[ k = \\frac{2\\pi}{\\lambda} \\] Explanation : Number of wave cycles per unit length. Why it's important : Controls how tightly packed the waves are. Note : \\(\\lambda\\) is the wavelength \u2014 distance between two crests. 3. Angular Frequency \\[ \\omega = 2\\pi f \\] Explanation : How quickly the wave oscillates (in time). Why it's important : High frequency \u2192 fast oscillation. Note : \\(f\\) is frequency in Hz. 4. Single Wave Equation \\[ \\eta_i(x, y, t) = \\frac{A}{r_i} \\cdot \\cos(kr_i - \\omega t) \\] Explanation : Displacement from a single wave source at a point in space and time. \\(A\\) is the amplitude \\(\\frac{1}{r_i}\\) models decay with distance \\(\\cos(kr_i - \\omega t)\\) describes wave oscillation Closer = stronger wave ; farther = weaker. 5. Total Wave Equation (Superposition) \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\] Explanation : Add up contributions from all sources. Why it's important : This is how interference patterns form. 6. Constructive Interference Condition \\[ \\Delta r = m \\lambda \\quad (m = 0, \\pm1, \\pm2, \\dots) \\] Explanation : Waves reinforce when path difference is a whole multiple of wavelength. Example : If \\(\\lambda = 2\\) , then \\(\\Delta r = 2, 4, 6, \\dots\\) 7. Destructive Interference Condition \\[ \\Delta r = \\left(m + \\frac{1}{2} \\right)\\lambda \\] Explanation : Waves cancel when their path difference is a half multiple of the wavelength. Example : If \\(\\lambda = 2\\) , then \\(\\Delta r = 1, 3, 5, \\dots\\) 8. Wave Decay Due to Distance \\[ \\text{Amplitude} \\propto \\frac{1}{r_i} \\] Explanation : Waves lose strength as they spread out. Real-life: Drop a pebble \u2014 strong ripples near impact, weaker far out. 7. Visualizing Wave Interference: Square Source Dynamics Here\u2019s the enhanced Python script generating three graphs: Interference pattern at \\( t = 0 \\) Time evolution at the center \\( (0, 0) \\) Cross-sectional displacement along \\( y = 0 \\) import numpy as np import matplotlib.pyplot as plt # Parameters A = 1.0 # Amplitude lambda_ = 0.5 # Wavelength k = 2 * np.pi / lambda_ # Wave number omega = 2 * np.pi # Angular frequency (f = 1) t = 0 # Initial time # Define grid x = np.linspace(-2, 2, 200) y = np.linspace(-2, 2, 200) X, Y = np.meshgrid(x, y) # Source positions (square) sources = [(1, 1), (1, -1), (-1, -1), (-1, 1)] # Total wave displacement at t = 0 eta_sum = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) eta_i = A / np.sqrt(r + 0.01) * np.cos(k * r - omega * t) # Avoid division by zero eta_sum += eta_i # Graph 1: 2D Interference Pattern plt.figure(figsize=(10, 8)) plt.contourf(X, Y, eta_sum, levels=20, cmap='seismic') plt.colorbar(label='Displacement') plt.title('Interference Pattern from Square Sources (t = 0)') plt.xlabel('x') plt.ylabel('y') plt.show() # Graph 2: Time Evolution at (0, 0) t_values = np.linspace(0, 2, 100) eta_time = [] for t in t_values: eta = 0 for (x0, y0) in sources: r = np.sqrt((0 - x0)**2 + (0 - y0)**2) eta += A / np.sqrt(r) * np.cos(k * r - omega * t) eta_time.append(eta) plt.figure(figsize=(10, 4)) plt.plot(t_values, eta_time, 'b-', label='Displacement') plt.title('Displacement at (0, 0) Over Time') plt.xlabel('Time (s)') plt.ylabel('Displacement') plt.grid() plt.legend() plt.show() # Graph 3: Cross-section along y = 0 eta_cross = np.zeros_like(x) for i, x_val in enumerate(x): eta = 0 for (x0, y0) in sources: r = np.sqrt((x_val - x0)**2 + (0 - y0)**2) eta += A / np.sqrt(r + 0.01) * np.cos(k * r) eta_cross[i] = eta plt.figure(figsize=(10, 4)) plt.plot(x, eta_cross, 'r-', label='Displacement along y = 0') plt.title('Displacement Along y = 0 at t = 0') plt.xlabel('x') plt.ylabel('Displacement') plt.grid() plt.legend() plt.show() Results and Interpretation 2D Interference Pattern The contour plot shows a symmetric pattern due to the square\u2019s geometry. Bright red and blue areas indicate constructive interference (high positive/negative displacement), while white areas near zero show destructive interference . Diagonal lines of symmetry emerge from the equal spacing of sources. Time Evolution at (0, 0) The reference point is arbitrary: The line plot reveals periodic oscillations, as waves from all sources interfere at the center. Peaks and troughs depend on the phase alignment over time. Cross-section Along \\(y = 0\\) This graph shows how displacement varies along the x-axis at \\(y = 0\\) . Sharp peaks and dips highlight interference effects, with symmetry around \\(x = 0\\) . Discussion The square arrangement produces a highly symmetric interference pattern, with constructive interference strongest where path differences are integer multiples of \\(\\lambda\\) . Destructive interference dominates where path differences are half-wavelength multiples.The \\(\\frac{1}{r}\\) amplitude decay ensures distant points have weaker contributions, shaping the pattern\u2019s spread. This simulation could be extended to other polygons (e.g., triangle or pentagon) or varying \\(\\lambda\\) to explore richer patterns.","title":"Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#a-simulation-based-exploration-using-regular-polygons","text":"","title":"A Simulation-Based Exploration Using Regular Polygons"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-introduction","text":"Wave interference is a fundamental concept in physics that describes how two or more waves combine when they overlap in space. On a water surface, this phenomenon is visually intuitive and can be observed when multiple ripples interact, forming patterns of reinforcement (constructive interference) or cancellation (destructive interference). In this study, we simulate the interference patterns created by coherent wave sources placed at the vertices of regular polygons \u2014 such as triangles, squares, and pentagons. The regular placement ensures symmetry and makes it easier to study the resulting wave interactions.","title":"1. Introduction"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-real-world-relevance","text":"Noise-canceling headphones : Use destructive interference to cancel ambient sound. Optical instruments : Lasers interfere to form holograms or measure distances with extreme precision. Engineering and architecture : Vibration patterns in structures are often analyzed using interference principles.","title":"2. Real-World Relevance"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-wave-physics-background","text":"Each point source creates a circular wave that propagates outward. The mathematical expression for a wave from a point source is shown below: \\[ \\eta_i(x, y, t) = \\frac{A}{r_i} \\cdot \\cos\\Bigl(kr_i - \\omega t + \\phi_i\\Bigr) \\] Where: - \\(\\eta_i(x, y, t)\\) : Displacement at point \\((x, y)\\) and time \\(t\\) from source \\(i\\) - \\(A\\) : Amplitude (constant for all sources) - \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) : Distance from the source to the point - \\(k = \\frac{2\\pi}{\\lambda}\\) : Wave number (inverse of wavelength) - \\(\\omega = 2\\pi f\\) : Angular frequency (proportional to frequency) - \\(\\phi_i\\) : Initial phase of the wave from source \\(i\\) Since all waves are coherent, we assume: - Same \\(A\\) , \\(\\lambda\\) , \\(f\\) , and \\(\\phi = 0\\)","title":"3. Wave Physics Background"},{"location":"1%20Physics/3%20Waves/Problem_1/#4-superposition-principle","text":"The total surface displacement at any point is calculated using the principle of linear superposition. Below is the corresponding formula: \\[ \\eta_{sum}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\] This summation produces the interference pattern: - Bright regions : Constructive interference (waves add up) - Dark regions : Destructive interference (waves cancel)","title":"4. Superposition Principle"},{"location":"1%20Physics/3%20Waves/Problem_1/#5-graphical-representation","text":"Below is a Python script that uses Matplotlib to generate and display the interference patterns for a triangular, square, and pentagonal arrangement of point sources. import numpy as np import matplotlib.pyplot as plt # Constants for wave properties A = 1.0 # amplitude wavelength = 2.0 # wavelength frequency = 1.0 # frequency phi = 0.0 # phase offset k = 2 * np.pi / wavelength omega = 2 * np.pi * frequency # Create a grid of x, y points to evaluate wave displacements x = np.linspace(-10, 10, 500) y = np.linspace(-10, 10, 500) X, Y = np.meshgrid(x, y) def polygon_vertices(n_sides, radius=5, center=(0, 0)): \"\"\"Returns the coordinates of the vertices of a regular polygon\"\"\" angles = np.linspace(0, 2*np.pi, n_sides, endpoint=False) cx, cy = center return [(cx + radius*np.cos(a), cy + radius*np.sin(a)) for a in angles] def total_wave(X, Y, t, sources): \"\"\"Calculates the total wave displacement by summing the waves from all sources\"\"\" eta = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) + 1e-6 # to avoid division by zero eta += (A / np.sqrt(r)) * np.cos(k * r - omega * t + phi) return eta # Time snapshot for visualization t = 0 # Create the figure for plotting fig, axs = plt.subplots(1, 3, figsize=(18, 6)) titles = ['Triangle (3 sources)', 'Square (4 sources)', 'Pentagon (5 sources)'] # Generate and plot the interference patterns for each polygon for ax, sides, title in zip(axs, [3, 4, 5], titles): sources = polygon_vertices(sides) # Get the polygon vertices eta_sum = total_wave(X, Y, t, sources) # Compute the total wave displacement im = ax.imshow(eta_sum, extent=(-10, 10, -10, 10), cmap='seismic', origin='lower') # Plot the pattern ax.set_title(title) ax.set_xlabel('x') ax.set_ylabel('y') ax.scatter(*zip(*sources), color='black', marker='x', label='Sources') # Mark the sources ax.legend() # Add color bar for better understanding fig.colorbar(im, ax=axs.ravel().tolist(), shrink=0.7, label='Wave Displacement') # Adjust layout for better spacing plt.tight_layout() plt.show()","title":"5. Graphical Representation"},{"location":"1%20Physics/3%20Waves/Problem_1/#analysis-of-graphs","text":"","title":"Analysis of Graphs"},{"location":"1%20Physics/3%20Waves/Problem_1/#triangle-3-sources","text":"The interference pattern exhibits three-fold symmetry . Bright areas represent constructive interference , while dark areas show destructive interference .","title":"Triangle (3 Sources)"},{"location":"1%20Physics/3%20Waves/Problem_1/#square-4-sources","text":"The interference pattern forms a four-fold symmetric grid , with regions of amplification and cancellation of waves.","title":"Square (4 Sources)"},{"location":"1%20Physics/3%20Waves/Problem_1/#pentagon-5-sources","text":"The interference pattern becomes more complex with five-fold symmetry , showcasing intricate regions of constructive and destructive interference.","title":"Pentagon (5 Sources)"},{"location":"1%20Physics/3%20Waves/Problem_1/#6formulas-used-in-the-code","text":"","title":"6.Formulas Used in the Code"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-distance-to-source","text":"\\[ r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2} \\] Explanation : This is the Euclidean distance from a point \\((x, y)\\) to the wave source at \\((x_i, y_i)\\) . Why it's important : Farther points receive weaker waves and are reached later. Example : From \\((0,0)\\) to \\((3,4)\\) : \\[ r = \\sqrt{3^2 + 4^2} = 5 \\]","title":"1. Distance to Source"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-wave-number","text":"\\[ k = \\frac{2\\pi}{\\lambda} \\] Explanation : Number of wave cycles per unit length. Why it's important : Controls how tightly packed the waves are. Note : \\(\\lambda\\) is the wavelength \u2014 distance between two crests.","title":"2. Wave Number"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-angular-frequency","text":"\\[ \\omega = 2\\pi f \\] Explanation : How quickly the wave oscillates (in time). Why it's important : High frequency \u2192 fast oscillation. Note : \\(f\\) is frequency in Hz.","title":"3. Angular Frequency"},{"location":"1%20Physics/3%20Waves/Problem_1/#4-single-wave-equation","text":"\\[ \\eta_i(x, y, t) = \\frac{A}{r_i} \\cdot \\cos(kr_i - \\omega t) \\] Explanation : Displacement from a single wave source at a point in space and time. \\(A\\) is the amplitude \\(\\frac{1}{r_i}\\) models decay with distance \\(\\cos(kr_i - \\omega t)\\) describes wave oscillation Closer = stronger wave ; farther = weaker.","title":"4. Single Wave Equation"},{"location":"1%20Physics/3%20Waves/Problem_1/#5-total-wave-equation-superposition","text":"\\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\] Explanation : Add up contributions from all sources. Why it's important : This is how interference patterns form.","title":"5. Total Wave Equation (Superposition)"},{"location":"1%20Physics/3%20Waves/Problem_1/#6-constructive-interference-condition","text":"\\[ \\Delta r = m \\lambda \\quad (m = 0, \\pm1, \\pm2, \\dots) \\] Explanation : Waves reinforce when path difference is a whole multiple of wavelength. Example : If \\(\\lambda = 2\\) , then \\(\\Delta r = 2, 4, 6, \\dots\\)","title":"6. Constructive Interference Condition"},{"location":"1%20Physics/3%20Waves/Problem_1/#7-destructive-interference-condition","text":"\\[ \\Delta r = \\left(m + \\frac{1}{2} \\right)\\lambda \\] Explanation : Waves cancel when their path difference is a half multiple of the wavelength. Example : If \\(\\lambda = 2\\) , then \\(\\Delta r = 1, 3, 5, \\dots\\)","title":"7. Destructive Interference Condition"},{"location":"1%20Physics/3%20Waves/Problem_1/#8-wave-decay-due-to-distance","text":"\\[ \\text{Amplitude} \\propto \\frac{1}{r_i} \\] Explanation : Waves lose strength as they spread out. Real-life: Drop a pebble \u2014 strong ripples near impact, weaker far out.","title":"8. Wave Decay Due to Distance"},{"location":"1%20Physics/3%20Waves/Problem_1/#7-visualizing-wave-interference-square-source-dynamics","text":"Here\u2019s the enhanced Python script generating three graphs: Interference pattern at \\( t = 0 \\) Time evolution at the center \\( (0, 0) \\) Cross-sectional displacement along \\( y = 0 \\) import numpy as np import matplotlib.pyplot as plt # Parameters A = 1.0 # Amplitude lambda_ = 0.5 # Wavelength k = 2 * np.pi / lambda_ # Wave number omega = 2 * np.pi # Angular frequency (f = 1) t = 0 # Initial time # Define grid x = np.linspace(-2, 2, 200) y = np.linspace(-2, 2, 200) X, Y = np.meshgrid(x, y) # Source positions (square) sources = [(1, 1), (1, -1), (-1, -1), (-1, 1)] # Total wave displacement at t = 0 eta_sum = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) eta_i = A / np.sqrt(r + 0.01) * np.cos(k * r - omega * t) # Avoid division by zero eta_sum += eta_i # Graph 1: 2D Interference Pattern plt.figure(figsize=(10, 8)) plt.contourf(X, Y, eta_sum, levels=20, cmap='seismic') plt.colorbar(label='Displacement') plt.title('Interference Pattern from Square Sources (t = 0)') plt.xlabel('x') plt.ylabel('y') plt.show() # Graph 2: Time Evolution at (0, 0) t_values = np.linspace(0, 2, 100) eta_time = [] for t in t_values: eta = 0 for (x0, y0) in sources: r = np.sqrt((0 - x0)**2 + (0 - y0)**2) eta += A / np.sqrt(r) * np.cos(k * r - omega * t) eta_time.append(eta) plt.figure(figsize=(10, 4)) plt.plot(t_values, eta_time, 'b-', label='Displacement') plt.title('Displacement at (0, 0) Over Time') plt.xlabel('Time (s)') plt.ylabel('Displacement') plt.grid() plt.legend() plt.show() # Graph 3: Cross-section along y = 0 eta_cross = np.zeros_like(x) for i, x_val in enumerate(x): eta = 0 for (x0, y0) in sources: r = np.sqrt((x_val - x0)**2 + (0 - y0)**2) eta += A / np.sqrt(r + 0.01) * np.cos(k * r) eta_cross[i] = eta plt.figure(figsize=(10, 4)) plt.plot(x, eta_cross, 'r-', label='Displacement along y = 0') plt.title('Displacement Along y = 0 at t = 0') plt.xlabel('x') plt.ylabel('Displacement') plt.grid() plt.legend() plt.show()","title":"7. Visualizing Wave Interference: Square Source Dynamics"},{"location":"1%20Physics/3%20Waves/Problem_1/#results-and-interpretation","text":"","title":"Results and Interpretation"},{"location":"1%20Physics/3%20Waves/Problem_1/#2d-interference-pattern","text":"The contour plot shows a symmetric pattern due to the square\u2019s geometry. Bright red and blue areas indicate constructive interference (high positive/negative displacement), while white areas near zero show destructive interference . Diagonal lines of symmetry emerge from the equal spacing of sources.","title":"2D Interference Pattern"},{"location":"1%20Physics/3%20Waves/Problem_1/#time-evolution-at-0-0","text":"The reference point is arbitrary: The line plot reveals periodic oscillations, as waves from all sources interfere at the center. Peaks and troughs depend on the phase alignment over time.","title":"Time Evolution at (0, 0)"},{"location":"1%20Physics/3%20Waves/Problem_1/#cross-section-along-y-0","text":"This graph shows how displacement varies along the x-axis at \\(y = 0\\) . Sharp peaks and dips highlight interference effects, with symmetry around \\(x = 0\\) .","title":"Cross-section Along \\(y = 0\\)"},{"location":"1%20Physics/3%20Waves/Problem_1/#discussion","text":"The square arrangement produces a highly symmetric interference pattern, with constructive interference strongest where path differences are integer multiples of \\(\\lambda\\) . Destructive interference dominates where path differences are half-wavelength multiples.The \\(\\frac{1}{r}\\) amplitude decay ensures distant points have weaker contributions, shaping the pattern\u2019s spread. This simulation could be extended to other polygons (e.g., triangle or pentagon) or varying \\(\\lambda\\) to explore richer patterns.","title":"Discussion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Simulating the Effects of the Lorentz Force MOTIVATION The Lorentz force describes how charged particles move in electric and magnetic fields. It is a key concept in electromagnetism, especially in technologies such as particle accelerators, mass spectrometers, fusion devices, and in astrophysics. Understanding this force helps us simulate and predict the motion of particles under the influence of fields. 1. What is the Lorentz Force? The Lorentz force is the total force experienced by a charged particle when it moves in the presence of both electric and magnetic fields. It\u2019s described by the equation: \\[ \\mathbf{F} = q(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\] Where: \\(F\\) is the total force vector acting on the particle \\(q\\) is the electric charge of the particle \\(E\\) is the electric field vector \\(v\\) is the velocity vector of the particle \\(B\\) is the magnetic field vector \\(\u00d7\\) is the cross product (which determines the direction of the magnetic force) This force causes charged particles to accelerate, change direction, or follow complex curved paths depending on the configuration of the fields. 2. Applications of the Lorentz Force Understanding and controlling the Lorentz force is crucial in many physical systems and technologies: Particle Accelerators : Use magnetic and electric fields to steer and speed up particles for collisions and research (e.g., LHC at CERN). Mass Spectrometers : Separate particles based on mass-to-charge ratio using known magnetic fields. Fusion Reactors (Tokamaks) : Use strong magnetic fields to confine hot plasma \u2014 a collection of charged particles. Cathode Ray Tubes : Use electric and magnetic fields to control the electron beam that lights up the screen. Auroras (Northern and Southern Lights) : Caused by charged solar particles deflected by Earth\u2019s magnetic field. 3. Special Motion Scenarios and Their Explanations a) Motion in a Uniform Magnetic Field ( \\(E = 0\\) ) If there is no electric field and the magnetic field is constant, the particle experiences a force perpendicular to its velocity and the magnetic field. This results in circular or helical motion. The force does no work (it changes direction, not speed), so kinetic energy remains constant. The path depends on the angle between velocity and magnetic field: Perpendicular : Circular path At an angle : Helical path Parallel : Straight line (no force) Important Formulas: Magnetic force : \\[ \\mathbf{F} = q (\\mathbf{v} \\times \\mathbf{B}) \\] Larmor radius ( \\(r_L\\) ): \\[ r_L = \\frac{m v_{\\perp}}{|q| B} \\] Cyclotron frequency ( \\(\\omega\\) ): \\[ \\omega = \\frac{|q| B}{m} \\] b) Motion in a Uniform Electric Field ( \\(B = 0\\) ) When only an electric field is present: The particle accelerates linearly in the direction of the electric field. The motion resembles free fall under gravity. Formula: Electric force : \\[ \\mathbf{F} = q \\mathbf{E} \\] c) Motion in Crossed Fields ( \\(E \u22a5 B\\) ) In this case, the electric and magnetic fields are perpendicular to each other. The particle undergoes a drift \u2014 moving in a direction perpendicular to both \\(E\\) and \\(B\\) . This drift velocity is the same regardless of mass or charge and is called the \\(E\\) cross \\(B\\) drift. Formula: Drift velocity ( \\(\\mathbf{v_d}\\) ): \\[ \\mathbf{v_d} = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2} \\] 4. Effect of Changing Physical Parameters Each parameter influences the particle's path in different ways: Charge \\((q)\\) : Determines direction of curvature. Opposite charges curve in opposite directions. Mass \\((m)\\) : Affects how tightly a particle spirals in a magnetic field (smaller mass \u2192 tighter spiral). Initial Velocity \\((v)\\) : Affects the size of the orbit and energy. If initial velocity is angled with respect to \\((B)\\) , it creates helical motion. Field Strength \\((E, B)\\) : Stronger magnetic fields decrease orbit radius. Stronger electric fields increase acceleration and drift speed. 5. Kinetic Energy of a Moving Particle Even though the magnetic field affects the trajectory, it does not change the particle\u2019s speed \u2014 hence, it does not do work. The electric field, however, adds energy to the particle. Kinetic Energy Formula: \\[ K = \\frac{1}{2} m v^2 \\] In crossed fields, kinetic energy may oscillate but overall increases if the particle gains energy from \\((E)\\) . 6. Visualization and Physical Interpretation The resulting motion from different field setups is visually and physically rich: In a uniform magnetic field, the particle traces circular or helical paths. In an electric field, the path is a straight line with increasing speed. In crossed fields, the particle shows a cycloidal trajectory and net drift. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.6e-19 # Charge (C) m = 1.67e-27 # Mass (kg) dt = 1e-7 # Time step (s) t_max = 5e-5 # Total time (s) steps = int(t_max / dt) # Lorentz force def lorentz_force(v, E, B): return (q / m) * (E + np.cross(v, B)) # RK4 step def rk4_step(r, v, E, B, dt): k1_v = lorentz_force(v, E, B) k1_r = v k2_v = lorentz_force(v + 0.5 * dt * k1_v, E, B) k2_r = v + 0.5 * dt * k1_r k3_v = lorentz_force(v + 0.5 * dt * k2_v, E, B) k3_r = v + 0.5 * dt * k2_r k4_v = lorentz_force(v + dt * k3_v, E, B) k4_r = v + dt * k3_r v_new = v + (dt / 6) * (k1_v + 2 * k2_v + 2 * k3_v + k4_v) r_new = r + (dt / 6) * (k1_r + 2 * k2_r + 2 * k3_r + k4_r) return r_new, v_new # Simulation function def simulate(E, B, r0, v0): r = np.zeros((steps, 3)) v = np.zeros((steps, 3)) r[0], v[0] = r0, v0 for i in range(steps - 1): r[i + 1], v[i + 1] = rk4_step(r[i], v[i], E, B, dt) return r, v # Initial conditions r0 = np.array([0.0, 0.0, 0.0]) v0 = np.array([1000.0, 1000.0, 0.0]) scenarios = [ (np.array([0.0, 0.0, 0.0]), np.array([0.0, 0.0, 0.1]), \"Uniform Magnetic Field\"), (np.array([1000.0, 0.0, 0.0]), np.array([0.0, 0.0, 0.1]), \"Combined Fields\"), (np.array([0.0, 1000.0, 0.0]), np.array([0.0, 0.0, 0.1]), \"Crossed Fields\") ] # Graph 1: 3D Trajectories fig = plt.figure(figsize=(15, 5)) for i, (E, B, title) in enumerate(scenarios, 1): r, _ = simulate(E, B, r0, v0) ax = fig.add_subplot(1, 3, i, projection='3d') ax.plot(r[:, 0], r[:, 1], r[:, 2], lw=1) ax.set_title(title) ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.set_zlabel('z (m)') plt.tight_layout() plt.show() # Graph 2: 2D Projection with Larmor Radius r, _ = simulate(scenarios[0][0], scenarios[0][1], r0, v0) # Uniform B plt.figure(figsize=(6, 6)) plt.plot(r[:, 0], r[:, 1], label='Trajectory') v_perp = np.sqrt(v0[0]**2 + v0[1]**2) r_L = m * v_perp / (q * 0.1) circle = plt.Circle((0, 0), r_L, color='r', fill=False, linestyle='--', label=f'Larmor Radius = {r_L:.2e} m') plt.gca().add_artist(circle) plt.title(\"2D xy-Plane: Uniform Magnetic Field\") plt.xlabel('x (m)') plt.ylabel('y (m)') plt.legend() plt.grid() plt.axis('equal') plt.show() # Graph 3: Velocity vs. Time (x-component) r, v = simulate(scenarios[2][0], scenarios[2][1], r0, v0) # Crossed Fields t = np.linspace(0, t_max, steps) plt.figure(figsize=(8, 4)) plt.plot(t, v[:, 0], 'b-', label='v_x') plt.title(\"Velocity (x-component) vs. Time: Crossed Fields\") plt.xlabel('Time (s)') plt.ylabel('v_x (m/s)') plt.grid() plt.legend() plt.show() 7. 3D Trajectories for All Scenarios Explanation: What It Is: Three 3D plots showing a proton\u2019s path in: 1. Just a magnetic field. 2. Magnetic plus electric field. 3. Crossed magnetic and electric fields. Why It Looks Like That: The magnetic field makes the particle loop around due to: \\[ F = q \\mathbf{v} \\times \\mathbf{B} \\] Adding an electric field: \\[ F = q \\mathbf{E} \\] stretches the loops into a spiral or wavy path, depending on its direction. What It Means: Shows how: \\[ F = q \\mathbf{E} + q \\mathbf{v} \\times \\mathbf{B} \\] changes motion\u2014circles for magnetic only, spirals or wiggles when electric is added. Think cyclotrons or plasma traps. 8. 2D Projection with Larmor Radius Annotation (Uniform Magnetic Field) Explanation: What It Is: A 2D top-down view of the proton\u2019s circular path in a magnetic field, with a red circle showing the Larmor radius. Why It Looks Like That: The magnetic field forces the particle into a circle with radius: \\[ r_L = \\frac{m v_{\\perp}}{|q| B} \\] where \\((v_{\\perp})\\) is the speed perpendicular to \\(( B )\\) . The red circle matches this size. What It Means: Confirms the particle follows: \\[ r_L = \\frac{m v_{\\perp}}{|q| B} \\] in a magnetic field, like in a cyclotron where it spins in circles. 9. Velocity vs. Time (x-component) for Crossed Fields Explanation: What It Is: A line graph of the proton\u2019s x-speed over time when electric and magnetic fields are perpendicular. Why It Looks Like That: The speed waves because: \\[ F = q v \\times B \\] makes it loop, while: \\[ F = q E \\] pushes it sideways. The drift speed is: \\[ v_d = \\frac{E}{B} \\left( \\frac{B^2}{E} \\right) = \\frac{E}{B} \\] What It Means: Shows how velocity changes with: \\[ \\frac{d v}{d t} = \\frac{q}{m} (E + v \\times B) \\] like in devices that filter particles by speed. import numpy as np import matplotlib.pyplot as plt # Constants q = 1.6e-19 m = 1.67e-27 dt = 1e-7 t_max = 5e-5 steps = int(t_max / dt) # Lorentz force def lorentz_force(v, E, B): return (q / m) * (E + np.cross(v, B)) # RK4 step def rk4_step(r, v, E, B, dt): k1_v = lorentz_force(v, E, B) k1_r = v k2_v = lorentz_force(v + 0.5 * dt * k1_v, E, B) k2_r = v + 0.5 * dt * k1_r k3_v = lorentz_force(v + 0.5 * dt * k2_v, E, B) k3_r = v + 0.5 * dt * k2_r k4_v = lorentz_force(v + dt * k3_v, E, B) k4_r = v + dt * k3_r v_new = v + (dt / 6) * (k1_v + 2 * k2_v + 2 * k3_v + k4_v) r_new = r + (dt / 6) * (k1_r + 2 * k2_r + 2 * k3_r + k4_r) return r_new, v_new # Simulation function def simulate(E, B, r0, v0): r = np.zeros((steps, 3)) v = np.zeros((steps, 3)) r[0], v[0] = r0, v0 for i in range(steps - 1): r[i + 1], v[i + 1] = rk4_step(r[i], v[i], E, B, dt) return r, v # Initial conditions r0 = np.array([0.0, 0.0, 0.0]) v0 = np.array([1000.0, 1000.0, 0.0]) # Graph 4: B-field Variation B_values = [0.05, 0.1, 0.2] plt.figure(figsize=(8, 6)) for B_val in B_values: r, _ = simulate(np.array([0.0, 0.0, 0.0]), np.array([0.0, 0.0, B_val]), r0, v0) plt.plot(r[:, 0], r[:, 1], label=f'B = {B_val} T') plt.title(\"2D Trajectories for Varying Magnetic Field Strength\") plt.xlabel('x (m)') plt.ylabel('y (m)') plt.legend() plt.grid() plt.axis('equal') plt.show() 10. Parameter Exploration - \\(B\\) -field Variation (Uniform Magnetic Field) Explanation: What It Is: A 2D plot comparing the proton\u2019s circular paths for three magnetic field strengths (weak, medium, strong). Why It Looks Like That: Stronger \\(( B )\\) makes smaller circles since: \\[ r_L = \\frac{m v_{\\perp}}{|q| B} \\] gets smaller as \\( B \\) grows, increasing the magnetic force: \\[ F = q v \\times B \\] What It Means: We can control circle size with \\(( B )\\) in \\(( r_L )\\) , useful in cyclotrons or traps where: \\[ F = ma \\] shapes orbits. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.6e-19 m = 1.67e-27 dt = 1e-7 t_max = 5e-5 steps = int(t_max / dt) # Lorentz force def lorentz_force(v, E, B): return (q / m) * (E + np.cross(v, B)) # RK4 step def rk4_step(r, v, E, B, dt): k1_v = lorentz_force(v, E, B) k1_r = v k2_v = lorentz_force(v + 0.5 * dt * k1_v, E, B) k2_r = v + 0.5 * dt * k1_r k3_v = lorentz_force(v + 0.5 * dt * k2_v, E, B) k3_r = v + 0.5 * dt * k2_r k4_v = lorentz_force(v + dt * k3_v, E, B) k4_r = v + dt * k3_r v_new = v + (dt / 6) * (k1_v + 2 * k2_v + 2 * k3_v + k4_v) r_new = r + (dt / 6) * (k1_r + 2 * k2_r + 2 * k3_r + k4_r) return r_new, v_new # Simulation function def simulate(E, B, r0, v0): r = np.zeros((steps, 3)) v = np.zeros((steps, 3)) r[0], v[0] = r0, v0 for i in range(steps - 1): r[i + 1], v[i + 1] = rk4_step(r[i], v[i], E, B, dt) return r, v # Initial conditions r0 = np.array([0.0, 0.0, 0.0]) v0 = np.array([1000.0, 1000.0, 0.0]) # Graph 5: 3D Scatter with Time Gradient r, _ = simulate(np.array([1000.0, 0.0, 0.0]), np.array([0.0, 0.0, 0.1]), r0, v0) fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') t = np.linspace(0, t_max, steps) scatter = ax.scatter(r[:, 0], r[:, 1], r[:, 2], c=t, cmap='viridis') plt.colorbar(scatter, label='Time (s)') ax.set_title(\"3D Trajectory with Time Gradient: Combined Fields\") ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.set_zlabel('z (m)') plt.show() 11. 3D Scatter with Time Color Gradient (Combined Fields) Explanation: What It Is: A 3D scatter plot of the proton\u2019s spiral path with colors from blue (start) to yellow (end) over time. Why It Looks Like That: The magnetic field loops it with: \\[ F = q v \\times B \\] while the electric field pulls it along x with: \\[ F = q E \\] making a stretched spiral over time: \\[ \\frac{dr}{dt} = v \\] What It Means: Shows motion from: \\[ a = \\frac{q}{m} (E + v \\times B) \\] like gaining energy in an accelerator or drifting in a trap.","title":"Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulating-the-effects-of-the-lorentz-force","text":"","title":"Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#motivation","text":"The Lorentz force describes how charged particles move in electric and magnetic fields. It is a key concept in electromagnetism, especially in technologies such as particle accelerators, mass spectrometers, fusion devices, and in astrophysics. Understanding this force helps us simulate and predict the motion of particles under the influence of fields.","title":"MOTIVATION"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-what-is-the-lorentz-force","text":"The Lorentz force is the total force experienced by a charged particle when it moves in the presence of both electric and magnetic fields. It\u2019s described by the equation: \\[ \\mathbf{F} = q(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\] Where: \\(F\\) is the total force vector acting on the particle \\(q\\) is the electric charge of the particle \\(E\\) is the electric field vector \\(v\\) is the velocity vector of the particle \\(B\\) is the magnetic field vector \\(\u00d7\\) is the cross product (which determines the direction of the magnetic force) This force causes charged particles to accelerate, change direction, or follow complex curved paths depending on the configuration of the fields.","title":"1. What is the Lorentz Force?"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-applications-of-the-lorentz-force","text":"Understanding and controlling the Lorentz force is crucial in many physical systems and technologies: Particle Accelerators : Use magnetic and electric fields to steer and speed up particles for collisions and research (e.g., LHC at CERN). Mass Spectrometers : Separate particles based on mass-to-charge ratio using known magnetic fields. Fusion Reactors (Tokamaks) : Use strong magnetic fields to confine hot plasma \u2014 a collection of charged particles. Cathode Ray Tubes : Use electric and magnetic fields to control the electron beam that lights up the screen. Auroras (Northern and Southern Lights) : Caused by charged solar particles deflected by Earth\u2019s magnetic field.","title":"2. Applications of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-special-motion-scenarios-and-their-explanations","text":"","title":"3. Special Motion Scenarios and Their Explanations"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#a-motion-in-a-uniform-magnetic-field-e-0","text":"If there is no electric field and the magnetic field is constant, the particle experiences a force perpendicular to its velocity and the magnetic field. This results in circular or helical motion. The force does no work (it changes direction, not speed), so kinetic energy remains constant. The path depends on the angle between velocity and magnetic field: Perpendicular : Circular path At an angle : Helical path Parallel : Straight line (no force)","title":"a) Motion in a Uniform Magnetic Field (\\(E = 0\\))"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#important-formulas","text":"Magnetic force : \\[ \\mathbf{F} = q (\\mathbf{v} \\times \\mathbf{B}) \\] Larmor radius ( \\(r_L\\) ): \\[ r_L = \\frac{m v_{\\perp}}{|q| B} \\] Cyclotron frequency ( \\(\\omega\\) ): \\[ \\omega = \\frac{|q| B}{m} \\]","title":"Important Formulas:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#b-motion-in-a-uniform-electric-field-b-0","text":"When only an electric field is present: The particle accelerates linearly in the direction of the electric field. The motion resembles free fall under gravity.","title":"b) Motion in a Uniform Electric Field (\\(B = 0\\))"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#formula","text":"Electric force : \\[ \\mathbf{F} = q \\mathbf{E} \\]","title":"Formula:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#c-motion-in-crossed-fields-e-b","text":"In this case, the electric and magnetic fields are perpendicular to each other. The particle undergoes a drift \u2014 moving in a direction perpendicular to both \\(E\\) and \\(B\\) . This drift velocity is the same regardless of mass or charge and is called the \\(E\\) cross \\(B\\) drift.","title":"c) Motion in Crossed Fields (\\(E \u22a5 B\\))"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#formula_1","text":"Drift velocity ( \\(\\mathbf{v_d}\\) ): \\[ \\mathbf{v_d} = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2} \\]","title":"Formula:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-effect-of-changing-physical-parameters","text":"Each parameter influences the particle's path in different ways: Charge \\((q)\\) : Determines direction of curvature. Opposite charges curve in opposite directions. Mass \\((m)\\) : Affects how tightly a particle spirals in a magnetic field (smaller mass \u2192 tighter spiral). Initial Velocity \\((v)\\) : Affects the size of the orbit and energy. If initial velocity is angled with respect to \\((B)\\) , it creates helical motion. Field Strength \\((E, B)\\) : Stronger magnetic fields decrease orbit radius. Stronger electric fields increase acceleration and drift speed.","title":"4. Effect of Changing Physical Parameters"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#5-kinetic-energy-of-a-moving-particle","text":"Even though the magnetic field affects the trajectory, it does not change the particle\u2019s speed \u2014 hence, it does not do work. The electric field, however, adds energy to the particle.","title":"5. Kinetic Energy of a Moving Particle"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#kinetic-energy-formula","text":"\\[ K = \\frac{1}{2} m v^2 \\] In crossed fields, kinetic energy may oscillate but overall increases if the particle gains energy from \\((E)\\) .","title":"Kinetic Energy Formula:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#6-visualization-and-physical-interpretation","text":"The resulting motion from different field setups is visually and physically rich: In a uniform magnetic field, the particle traces circular or helical paths. In an electric field, the path is a straight line with increasing speed. In crossed fields, the particle shows a cycloidal trajectory and net drift. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.6e-19 # Charge (C) m = 1.67e-27 # Mass (kg) dt = 1e-7 # Time step (s) t_max = 5e-5 # Total time (s) steps = int(t_max / dt) # Lorentz force def lorentz_force(v, E, B): return (q / m) * (E + np.cross(v, B)) # RK4 step def rk4_step(r, v, E, B, dt): k1_v = lorentz_force(v, E, B) k1_r = v k2_v = lorentz_force(v + 0.5 * dt * k1_v, E, B) k2_r = v + 0.5 * dt * k1_r k3_v = lorentz_force(v + 0.5 * dt * k2_v, E, B) k3_r = v + 0.5 * dt * k2_r k4_v = lorentz_force(v + dt * k3_v, E, B) k4_r = v + dt * k3_r v_new = v + (dt / 6) * (k1_v + 2 * k2_v + 2 * k3_v + k4_v) r_new = r + (dt / 6) * (k1_r + 2 * k2_r + 2 * k3_r + k4_r) return r_new, v_new # Simulation function def simulate(E, B, r0, v0): r = np.zeros((steps, 3)) v = np.zeros((steps, 3)) r[0], v[0] = r0, v0 for i in range(steps - 1): r[i + 1], v[i + 1] = rk4_step(r[i], v[i], E, B, dt) return r, v # Initial conditions r0 = np.array([0.0, 0.0, 0.0]) v0 = np.array([1000.0, 1000.0, 0.0]) scenarios = [ (np.array([0.0, 0.0, 0.0]), np.array([0.0, 0.0, 0.1]), \"Uniform Magnetic Field\"), (np.array([1000.0, 0.0, 0.0]), np.array([0.0, 0.0, 0.1]), \"Combined Fields\"), (np.array([0.0, 1000.0, 0.0]), np.array([0.0, 0.0, 0.1]), \"Crossed Fields\") ] # Graph 1: 3D Trajectories fig = plt.figure(figsize=(15, 5)) for i, (E, B, title) in enumerate(scenarios, 1): r, _ = simulate(E, B, r0, v0) ax = fig.add_subplot(1, 3, i, projection='3d') ax.plot(r[:, 0], r[:, 1], r[:, 2], lw=1) ax.set_title(title) ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.set_zlabel('z (m)') plt.tight_layout() plt.show() # Graph 2: 2D Projection with Larmor Radius r, _ = simulate(scenarios[0][0], scenarios[0][1], r0, v0) # Uniform B plt.figure(figsize=(6, 6)) plt.plot(r[:, 0], r[:, 1], label='Trajectory') v_perp = np.sqrt(v0[0]**2 + v0[1]**2) r_L = m * v_perp / (q * 0.1) circle = plt.Circle((0, 0), r_L, color='r', fill=False, linestyle='--', label=f'Larmor Radius = {r_L:.2e} m') plt.gca().add_artist(circle) plt.title(\"2D xy-Plane: Uniform Magnetic Field\") plt.xlabel('x (m)') plt.ylabel('y (m)') plt.legend() plt.grid() plt.axis('equal') plt.show() # Graph 3: Velocity vs. Time (x-component) r, v = simulate(scenarios[2][0], scenarios[2][1], r0, v0) # Crossed Fields t = np.linspace(0, t_max, steps) plt.figure(figsize=(8, 4)) plt.plot(t, v[:, 0], 'b-', label='v_x') plt.title(\"Velocity (x-component) vs. Time: Crossed Fields\") plt.xlabel('Time (s)') plt.ylabel('v_x (m/s)') plt.grid() plt.legend() plt.show()","title":"6. Visualization and Physical Interpretation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#7-3d-trajectories-for-all-scenarios","text":"","title":"7. 3D Trajectories for All Scenarios"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#explanation","text":"","title":"Explanation:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#what-it-is","text":"Three 3D plots showing a proton\u2019s path in: 1. Just a magnetic field. 2. Magnetic plus electric field. 3. Crossed magnetic and electric fields.","title":"What It Is:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#why-it-looks-like-that","text":"The magnetic field makes the particle loop around due to: \\[ F = q \\mathbf{v} \\times \\mathbf{B} \\] Adding an electric field: \\[ F = q \\mathbf{E} \\] stretches the loops into a spiral or wavy path, depending on its direction.","title":"Why It Looks Like That:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#what-it-means","text":"Shows how: \\[ F = q \\mathbf{E} + q \\mathbf{v} \\times \\mathbf{B} \\] changes motion\u2014circles for magnetic only, spirals or wiggles when electric is added. Think cyclotrons or plasma traps.","title":"What It Means:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#8-2d-projection-with-larmor-radius-annotation-uniform-magnetic-field","text":"","title":"8. 2D Projection with Larmor Radius Annotation (Uniform Magnetic Field)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#explanation_1","text":"","title":"Explanation:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#what-it-is_1","text":"A 2D top-down view of the proton\u2019s circular path in a magnetic field, with a red circle showing the Larmor radius.","title":"What It Is:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#why-it-looks-like-that_1","text":"The magnetic field forces the particle into a circle with radius: \\[ r_L = \\frac{m v_{\\perp}}{|q| B} \\] where \\((v_{\\perp})\\) is the speed perpendicular to \\(( B )\\) . The red circle matches this size.","title":"Why It Looks Like That:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#what-it-means_1","text":"Confirms the particle follows: \\[ r_L = \\frac{m v_{\\perp}}{|q| B} \\] in a magnetic field, like in a cyclotron where it spins in circles.","title":"What It Means:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#9-velocity-vs-time-x-component-for-crossed-fields","text":"","title":"9. Velocity vs. Time (x-component) for Crossed Fields"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#explanation_2","text":"","title":"Explanation:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#what-it-is_2","text":"A line graph of the proton\u2019s x-speed over time when electric and magnetic fields are perpendicular.","title":"What It Is:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#why-it-looks-like-that_2","text":"The speed waves because: \\[ F = q v \\times B \\] makes it loop, while: \\[ F = q E \\] pushes it sideways. The drift speed is: \\[ v_d = \\frac{E}{B} \\left( \\frac{B^2}{E} \\right) = \\frac{E}{B} \\]","title":"Why It Looks Like That:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#what-it-means_2","text":"Shows how velocity changes with: \\[ \\frac{d v}{d t} = \\frac{q}{m} (E + v \\times B) \\] like in devices that filter particles by speed. import numpy as np import matplotlib.pyplot as plt # Constants q = 1.6e-19 m = 1.67e-27 dt = 1e-7 t_max = 5e-5 steps = int(t_max / dt) # Lorentz force def lorentz_force(v, E, B): return (q / m) * (E + np.cross(v, B)) # RK4 step def rk4_step(r, v, E, B, dt): k1_v = lorentz_force(v, E, B) k1_r = v k2_v = lorentz_force(v + 0.5 * dt * k1_v, E, B) k2_r = v + 0.5 * dt * k1_r k3_v = lorentz_force(v + 0.5 * dt * k2_v, E, B) k3_r = v + 0.5 * dt * k2_r k4_v = lorentz_force(v + dt * k3_v, E, B) k4_r = v + dt * k3_r v_new = v + (dt / 6) * (k1_v + 2 * k2_v + 2 * k3_v + k4_v) r_new = r + (dt / 6) * (k1_r + 2 * k2_r + 2 * k3_r + k4_r) return r_new, v_new # Simulation function def simulate(E, B, r0, v0): r = np.zeros((steps, 3)) v = np.zeros((steps, 3)) r[0], v[0] = r0, v0 for i in range(steps - 1): r[i + 1], v[i + 1] = rk4_step(r[i], v[i], E, B, dt) return r, v # Initial conditions r0 = np.array([0.0, 0.0, 0.0]) v0 = np.array([1000.0, 1000.0, 0.0]) # Graph 4: B-field Variation B_values = [0.05, 0.1, 0.2] plt.figure(figsize=(8, 6)) for B_val in B_values: r, _ = simulate(np.array([0.0, 0.0, 0.0]), np.array([0.0, 0.0, B_val]), r0, v0) plt.plot(r[:, 0], r[:, 1], label=f'B = {B_val} T') plt.title(\"2D Trajectories for Varying Magnetic Field Strength\") plt.xlabel('x (m)') plt.ylabel('y (m)') plt.legend() plt.grid() plt.axis('equal') plt.show()","title":"What It Means:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#10-parameter-exploration-b-field-variation-uniform-magnetic-field","text":"","title":"10. Parameter Exploration - \\(B\\)-field Variation (Uniform Magnetic Field)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#explanation_3","text":"","title":"Explanation:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#what-it-is_3","text":"A 2D plot comparing the proton\u2019s circular paths for three magnetic field strengths (weak, medium, strong).","title":"What It Is:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#why-it-looks-like-that_3","text":"Stronger \\(( B )\\) makes smaller circles since: \\[ r_L = \\frac{m v_{\\perp}}{|q| B} \\] gets smaller as \\( B \\) grows, increasing the magnetic force: \\[ F = q v \\times B \\]","title":"Why It Looks Like That:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#what-it-means_3","text":"We can control circle size with \\(( B )\\) in \\(( r_L )\\) , useful in cyclotrons or traps where: \\[ F = ma \\] shapes orbits. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.6e-19 m = 1.67e-27 dt = 1e-7 t_max = 5e-5 steps = int(t_max / dt) # Lorentz force def lorentz_force(v, E, B): return (q / m) * (E + np.cross(v, B)) # RK4 step def rk4_step(r, v, E, B, dt): k1_v = lorentz_force(v, E, B) k1_r = v k2_v = lorentz_force(v + 0.5 * dt * k1_v, E, B) k2_r = v + 0.5 * dt * k1_r k3_v = lorentz_force(v + 0.5 * dt * k2_v, E, B) k3_r = v + 0.5 * dt * k2_r k4_v = lorentz_force(v + dt * k3_v, E, B) k4_r = v + dt * k3_r v_new = v + (dt / 6) * (k1_v + 2 * k2_v + 2 * k3_v + k4_v) r_new = r + (dt / 6) * (k1_r + 2 * k2_r + 2 * k3_r + k4_r) return r_new, v_new # Simulation function def simulate(E, B, r0, v0): r = np.zeros((steps, 3)) v = np.zeros((steps, 3)) r[0], v[0] = r0, v0 for i in range(steps - 1): r[i + 1], v[i + 1] = rk4_step(r[i], v[i], E, B, dt) return r, v # Initial conditions r0 = np.array([0.0, 0.0, 0.0]) v0 = np.array([1000.0, 1000.0, 0.0]) # Graph 5: 3D Scatter with Time Gradient r, _ = simulate(np.array([1000.0, 0.0, 0.0]), np.array([0.0, 0.0, 0.1]), r0, v0) fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') t = np.linspace(0, t_max, steps) scatter = ax.scatter(r[:, 0], r[:, 1], r[:, 2], c=t, cmap='viridis') plt.colorbar(scatter, label='Time (s)') ax.set_title(\"3D Trajectory with Time Gradient: Combined Fields\") ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.set_zlabel('z (m)') plt.show()","title":"What It Means:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#11-3d-scatter-with-time-color-gradient-combined-fields","text":"","title":"11. 3D Scatter with Time Color Gradient (Combined Fields)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#explanation_4","text":"","title":"Explanation:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#what-it-is_4","text":"A 3D scatter plot of the proton\u2019s spiral path with colors from blue (start) to yellow (end) over time.","title":"What It Is:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#why-it-looks-like-that_4","text":"The magnetic field loops it with: \\[ F = q v \\times B \\] while the electric field pulls it along x with: \\[ F = q E \\] making a stretched spiral over time: \\[ \\frac{dr}{dt} = v \\]","title":"Why It Looks Like That:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#what-it-means_4","text":"Shows motion from: \\[ a = \\frac{q}{m} (E + v \\times B) \\] like gaining energy in an accelerator or drifting in a trap.","title":"What It Means:"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}